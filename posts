[{"title":"前端构建新玩法：Vite 上手与思考","slug":"vite-getting-started","date":1603476282000,"updated":1673100032289,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Vite","Bundleless","Webpack","模块化"],"meta":{},"content":"\n### Vite 的定义\n\nVite 是面向现代浏览器的一个更轻、更快的 Web 应用开发工具，核心基于 ECMAScript 标准原生模块系统（ES Modules）实现。\n\n表象功能上看，Vite 可以取代基于 Webpack 的 vue-cli 或者 cra 的集成式开发工具，提供全新的一种开发体验。\n\n具体细节往下看。\n\n#### Vite 的由来\n\n在此之前，如果我们所开发的应用比较复杂（代码量偏大），使用 Webpack 的开发过程相对没有那么「丝滑」，具体表现为以下两点：\n\n- Webpack Dev Server 冷启动时间会比较长，稍大一点的项目启动开发服务都需要等待 10 - 20 秒；\n- Webpack HMR 热更新的反应速度比较慢，修改完代码需要等待编译器全部编译完成才能开始同步到浏览器；\n\n### 快速上手\n\n这里我们话不多说，先上手体验一下 Vite，然后再来分析其内部的思路和想法。\n\nVite 官方目前提供了一个比较简单的脚手架：create-vite-app，可以使用这个脚手架快速创建一个使用 Vite 构建的 Vue.js 应用\n\n```shell\n$ npm init vite-app <project-name>\n$ cd <project-name>\n$ npm install\n$ npm run dev\n```\n\n如果使用 Yarn：\n\n```shell\n$ yarn create vite-app <project-name>\n$ cd <project-name>\n$ yarn\n$ yarn dev\n```\n\n> P.S. `npm init` 或者 `yarn create` 是这两个包管理工具提供的新功能，其内部就是自动去安装一个 `create-<xxx>` 的模块（临时），然后自动执行这个模块中的 bin。\n>\n> **例如**:\n>\n> `yarn create react-app my-react-app` 就相当于先 `yarn global add create-react-app`，然后自动执行 `create-react-app my-react-app`\n\n#### 对比差异点\n\n打开生成的项目过后，你会发现就是一个很普通的 Vue.js 应用，没有太多特殊的地方。\n\n不过相比于之前 vue-cli 创建的项目或者是基于 Webpack 搭建的 Vue.js 项目，这里的开发依赖非常简单，只有 `vite` 和 `@vue/compiler-sfc`。\n\n```json\n{\n  \"name\": \"vite-demo\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\"\n  },\n  \"dependencies\": {\n    \"vue\": \"^3.0.0-rc.1\"\n  },\n  \"devDependencies\": {\n    \"vite\": \"^1.0.0-rc.1\",\n    \"@vue/compiler-sfc\": \"^3.0.0-rc.1\"\n  }\n}\n```\n\n`vite` 就是我们今天要介绍的主角，而 `@vue/compiler-sfc` 就是用来编译我们项目中 `.vue` 结尾的单文件组件（SFC），它取代的就是 Vue.js 2.x 时使用的 `vue-template-compiler`。\n\n再者就是 Vue.js 的版本是 3.0。这里尤其需要注意：**Vite 目前只支持 Vue.js 3.0 版本。**\n\n> 如果你想，在后面介绍完实现原理过后，你也可以改造 Vite 让它支持 Vue.js 2.0。\n\n#### 基础体验\n\n这里我们所安装的 vite 模块提供了两个子命令：\n\n- `serve`：启动一个用于开发的服务器\n- `build`：构建整个项目（上线）\n\n当我们执行 `vite serve` 的时候，你会发现响应速度非常快，几乎就是秒开。\n\n可能单独体验你不会有太明显的感觉，你可以对比使用 `vue-cli-service`（内部还是 Webpack）启动开发服务器，\n\n当我们对比使用 `vue-cli-service serve` 的时候，你会有更明显的感觉。\n\n因为 Webpack Dev Server 在启动时，需要先 build 一遍，而 build 的过程是需要耗费很多时间的。\n\n![](https://cdn.zce.me/assets/0ef69679c77b65e2.png)\n\n而 Vite 则完全不同，当我们执行 `vite serve` 时，内部直接启动了 Web Server，并不会先编译所有的代码文件。\n\n那仅仅是启动 Web Server，速度上自然就快了很多。\n\n![](https://cdn.zce.me/assets/e22645e0e47a01e4.png)\n\n但是像 Webpack 这类工具的做法是将所有模块提前编译、打包进 bundle 里，换句话说，不管模块是否会被执行，都要被编译和打包到 bundle 里。随着项目越来越大打包后的 bundle 也越来越大，打包的速度自然也就越来越慢。\n\nVite 利用现代浏览器原生支持 ESM 特性，省略了对模块的打包。\n\n对于需要编译的文件，Vite 采用的是另外一种模式：即时编译。\n\n也就是说，只有具体去请求某个文件时才会编译这个文件。\n\n所以，这种「即时编译」的好处主要体现在：按需编译。\n\n#### Optimize\n\nVite 还提供了一个目前在帮助列表中并没有呈现的一个子命令：optimize。\n\n这个命令的作用就是单独的去「优化依赖」。\n\n所谓的「优化依赖」，指的就是自动去把代码中依赖的第三方模块提前编译出来。\n\n例如，我们在代码中通过 `import` 载入了 vue 这个模块，那通过这个命令就会自动将这个模块打包成一个单独的 ESM bundle, 放到 `node_modules/.vite_opt_cache` 目录中。\n\n这样后续请求这个文件时就不需要再即时去加载了。\n\n#### HMR\n\n同样也是模式的问题，热更新的时候，Vite 只需要立即编译当前所修改的文件即可，所以响应速度非常快。\n\n而 Webpack 修改某个文件过后，会自动以这个文件为入口重写 build 一次，所有的涉及到的依赖也都会被加载一遍，所以反应速度会慢很多。\n\n#### Build\n\nVite 在生产模式下打包，需要使用 `vite build` 命令。\n\n这个命令内部采用的是 Rollup 完成的应用打包，最终还是会把文件都提前编译并打包到一起。\n\n对于 Code Splitting 需求，Vite 内部采用的就是原生 Dynamic imports 特性实现的，所以打包结果还是只能够支持现代浏览器。\n\n不过好在 Dynamic imports 特性是可以有 Polyfill 的：https://github.com/GoogleChromeLabs/dynamic-import-polyfill ，也就是说，只要你想，它也可以运行在相对低版本的浏览器中。\n\n#### 打包 or 不打包\n\nVite 的出现，引发了另外一个值得我们思考的问题：究竟还有没有必要打包应用？\n\n之前我们使用 Webpack 打包应用代码，使之成为一个 bundle.js，主要有两个原因：\n\n1. 浏览器环境并不支持模块化\n2. 零散的模块文件会产生大量的 HTTP 请求\n\n随着浏览器的对 ES 标准支持的逐渐完善，第一个问题已经慢慢不存在了。现阶段绝大多数浏览器都是支持 ES Modules 的。\n\n![es-modules](https://cdn.zce.me/assets/0ee367555f75fe99.png)\n\n零散模块文件确实会产生大量的 HTTP 请求，而大量的 HTTP 请求在浏览器端就会并发请求资源的问题；\n\n![](https://cdn.zce.me/assets/3c284745ef6378fa.png)\n\n_如上图所示，红色圈出来的请求就是并行请求，但是后面的请求就因为域名链接数已超过限制，而被挂起等待了一段时间。_\n\n在 HTTP 1.1 的标准下，每次请求都需要单独建立 TCP 链接，经过完整的通讯过程，非常耗时；\n\n![](https://cdn.zce.me/assets/0f116e3423c7fb26.png)\n\n而且每次请求除了请求体中的内容，请求头中也会包含很多数据，大量请求的情况下也会浪费很多资源。\n\n但是这些问题随着 HTTP 2 的出现，也就不复存在了。\n\n![](https://cdn.zce.me/assets/efb4fd018eee1ce3.png)\n\n关于 HTTP 1.1 与 HTTP 2 之间的差异，可以通过这个链接体验：https://http2.akamai.com/demo ，直观感受下 HTTP/2 比 HTTP/1 到底快了多少。\n\n而且不打包也有一个好处，就是可以把按需加载实现到极致。\n\n> 关于 HTTP 2 的详细介绍，可以参考：\n>\n> - https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/\n> - https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference\n\n#### 开箱即用\n\n- TypeScript - 内置支持\n- less/sass/stylus/postcss - 内置支持（需要单独安装所对应的编译器）\n\n#### 特性小结\n\nVite 带来的优势主要体现在提升开发者在开发过程中的体验。\n\n- Dev Server 无需等待，即时启动；\n- 几乎实时的模块热更新；\n- 所需文件按需编译，避免编译用不到的文件；\n- 开箱即用，避免各种 Loader 和 Plugin 的配置；\n\n### 实现原理\n\nVite 的核心功能：Static Server + Compile + HMR\n\n核心思路：\n\n1. 将当前项目目录作为静态文件服务器的根目录\n2. 拦截部分文件请求\n   1. 处理代码中 import node_modules 中的模块\n   2. 处理 vue 单文件组件（SFC）的编译\n3. 通过 WebSocket 实现 HMR\n\n#### 手写实现\n\n详细参考 https://github.com/zce/vite-essentials\n\n```javascript\n#!/usr/bin/env node\n\nconst path = require('path')\nconst { Readable } = require('stream')\nconst Koa = require('koa')\nconst send = require('koa-send')\nconst compilerSfc = require('@vue/compiler-sfc')\n\nconst cwd = process.cwd()\n\nconst streamToString = stream =>\n  new Promise((resolve, reject) => {\n    const chunks = []\n    stream.on('data', chunk => chunks.push(chunk))\n    stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')))\n    stream.on('error', reject)\n  })\n\nconst app = new Koa()\n\n// 重写请求路径，/@modules/xxx => /node_modules/\napp.use(async (ctx, next) => {\n  if (ctx.path.startsWith('/@modules/')) {\n    const moduleName = ctx.path.substr(10) // => vue\n    const modulePkg = require(path.join(\n      cwd,\n      'node_modules',\n      moduleName,\n      'package.json'\n    ))\n    ctx.path = path.join('/node_modules', moduleName, modulePkg.module)\n  }\n  await next()\n})\n\n// 根据请求路径得到相应文件 /index.html\napp.use(async (ctx, next) => {\n  // ctx.path // http://localhost:3080/\n  // ctx.body = 'my-vite'\n  await send(ctx, ctx.path, { root: cwd, index: 'index.html' }) // 有可能还需要额外处理相应结果\n  await next()\n})\n\n// .vue 文件请求的处理，即时编译\napp.use(async (ctx, next) => {\n  if (ctx.path.endsWith('.vue')) {\n    const contents = await streamToString(ctx.body)\n    const { descriptor } = compilerSfc.parse(contents)\n    let code\n\n    if (ctx.query.type === undefined) {\n      code = descriptor.script.content\n      code = code.replace(/export\\s+default\\s+/, 'const __script = ')\n      code += `\n  import { render as __render } from \"${ctx.path}?type=template\"\n  __script.render = __render\n  export default __script`\n      // console.log(code)\n      ctx.type = 'application/javascript'\n      ctx.body = Readable.from(Buffer.from(code))\n    } else if (ctx.query.type === 'template') {\n      const templateRender = compilerSfc.compileTemplate({\n        source: descriptor.template.content\n      })\n      code = templateRender.code\n    }\n\n    ctx.type = 'application/javascript'\n    ctx.body = Readable.from(Buffer.from(code))\n  }\n  await next()\n})\n\n// 替换代码中特殊位置\napp.use(async (ctx, next) => {\n  if (ctx.type === 'application/javascript') {\n    const contents = await streamToString(ctx.body)\n    ctx.body = contents\n      .replace(/(from\\s+['\"])(?![\\.\\/])/g, '$1/@modules/')\n      .replace(/process\\.env\\.NODE_ENV/g, '\"production\"')\n  }\n})\n\napp.listen(3080)\n\nconsole.log('Server running @ http://localhost:3080')\n```\n","cover":"https://cdn.zce.me/assets/6210f6bffa8d77dc.png"},{"title":"使用 Parcel 零配置完成应用打包构建任务","slug":"parcel-getting-started","date":1588184871000,"updated":1673100032273,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","Parcel"],"meta":{},"content":"\n你好，我是汪磊，今天我要带你了解一个近两年非常火的打包工具：[Parcel](https://rollupjs.org)。\n\nParcel 是一款完全零配置的前端打包器，它提供了“傻瓜式”的使用体验，我们只需了解它提供的几个简单的命令，就可以直接使用它去构建我们的前端应用程序了。\n\n下面我们直接来看具体如何去使用 Parcel。\n\n### 快速上手\n\n这里我们先创建一个空目录，然后通过 `npm init` 初始化一个项目中的 package.json 文件。\n\n完成以后我们就可以安装 Parcel 模块了，具体命令如下：\n\n```shell\n$ npm install parcel-bundler --save-dev\n```\n\n这里需要注意 Parcel 的 npm 模块名称叫作 parcel-bundler，我们同样应该将它安装到项目的开发依赖中。\n\n安装完成过后，parcel-bundler 模块就在 `node_modules/.bin` 目录中提供了一个叫作 `parcel` 的 CLI 程序，后续我们就是使用这个 CLI 程序执行应用打包。\n\n既然是打包应用代码，那我们这里就得先有代码。我们回到项目中创建一些必需的文件，结构如下：\n\n```diff\n.\n├── src\n│   ├── index.html\n│   ├── logger.js\n│   └── main.js\n└── package.json\n```\n\n首先在根目录下新建一个 src 目录，用于存放开发阶段编写的源代码，同时创建两个 JS 文件，分别是 logger.js 和 main.js，然后再创建一个 index.html 文件，这个 index.html 文件会将是 Parcel 打包的入口文件。\n\n虽然 Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，不过 Parcel 官方还是建议我们使用 HTML 文件作为入口。官方的理由是 HTML 是应用在浏览器端运行时的入口。\n\n那在这个 HTML 入口文件中，我们可以像平时一样去编写代码，也可以正常去引用资源。在它里面引用的资源，最终都会被 Parcel 打包到一起。\n\n我们这里先尝试在 index.html 中引入 main.js 脚本文件，具体代码如下：\n\n```html\n<!-- ./src/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Parcel Tutorials</title>\n  </head>\n  <body>\n    <script src=\"main.js\"></script>\n  </body>\n</html>\n```\n\n紧接着，在 main.js 中按照 ES Modules 的方式导入 logger.js 中的成员，具体代码如下：\n\n```javascript\n// ./src/main.js\nimport { log } from './logger'\n\nlog('hello parcel')\n\n// ./src/logger.js\nexport const log = msg => {\n  console.log('---------- INFO ----------')\n  console.log(msg)\n}\n```\n\nParcel 同样支持对 ES Modules 模块的打包。\n\n完成以后，我们打开命令行终端，然后使用 npx 去运行 node_modules 目录下的 parcel 命令。具体命令如下：\n\n```shell\n$ npx parcel src/index.html\n```\n\nparcel 命令需要我们传入打包入口文件路径，那我们这里就应该是 `src/index.html`。\n\n此时如果执行这个命令，Parcel 就会根据这里传入的参数，先找到 index.html，然后在根据 HTML 中的 script 标签，找到 main.js，最后再顺着 import 语句找到 logger.js 模块，从而完成整体打包。\n\n回车执行过后，这里我们发现 Parcel 这个命令不仅仅帮我们打包了应用，而且还同时开启了一个开发服务器，这就跟 Webpack Dev Server 一样。\n\n我们打开这个地址，启动浏览器，然后打开开发人员工具。Parcel 同样支持自动刷新这样的功能。具体效果如下：\n\n![](https://cdn.zce.me/assets/a03a2ef5161b956e.png)\n\n以上就是 Parcel 的基本使用，相比于 Webpack，Parcel 在使用上的确简化了很多。\n\n#### 模块热替换\n\n如果你需要的是模块热替换的体验，Parcel 中也可以支持。我们回到 main.js 文件中，这里同样需要使用 HMR 的 API。具体代码如下：\n\n```javascript\n// ./src/main.js\nimport { log } from './logger'\n\nlog('hello parcel')\n\n// HMR API\nif (module.hot) {\n  module.hot.accept(() => {\n    console.log('HMR～')\n  })\n}\n```\n\n我们需要先判断一下 `module.hot` 对象是否存在，如果存在则证明当前环境可以使用 HMR 的 API，那我们就可以使用 `module.hot.accept` 方法去处理热替换。\n\n不过这里的 `accept` 方法与 Webpack 提供的 HMR 有点不太一样，Webpack 中的 `accept` 方法支持接收两个参数，用来处理指定的模块更新后的逻辑。\n\n而这里 Parcel 提供的 `accept` 只需要接收一个回调参数，作用就是当前模块更新或者所依赖的模块更新过后自动执行传入的回调函数，这相比于之前 Webpack 中的用法要简单很多。\n\n关于模块更新后的处理逻辑，这里我们就不再过多介绍了，你可以参考我们在 [Webpack HMR](/2020/04/webpack-hot-module-replacement/) 中的介绍。\n\n#### 自动安装依赖\n\n除了热替换，Parcel 还支持一个非常友好的功能：自动安装依赖。试想一下，你正在开发一个应用的过程中，突然需要使用某个第三方模块，那此时你就需要先停止正在运行的 Dev Server，然后再去安装这个模块，安装完成过后再重新启动 Dev Server。有了自动安装依赖的功能就不必如此麻烦了。\n\n我们回到 main.js 文件中，假设我们这里想要使用一下 jquery。虽然我们并没有安装这个模块，但是因为有了自动安装依赖功能，我们这里只管正常导入，正常使用就好了。具体效果如下：\n\n<video src=https://cdn.zce.me/assets/0379e6e47c43ae61.mp4 muted autoplay playsinline loop></video>\n\n在文件保存过后，Parcel 会自动去安装刚刚导入的模块包，极大程度地避免手动操作。\n\n#### 其他类型资源加载\n\n除此以外，Parcel 同样支持加载其他类型的资源模块，而且相比于其他的打包器，在 Parcel 中加载其他类型的资源模块同样是零配置的。\n\n例如我们这里再来添加一个 style.css 的样式文件，并且在这个文件中添加一些简单的样式，具体如下：\n\n```diff\n .\n ├── src\n │   ├── index.html\n │   ├── logger.js\n │   ├── main.js\n+│   └── style.css\n └── package.json\n```\n\n然后回到 main.js 中通过 import 导入这个样式文件，具体如下：\n\n```javascript\n// ./src/main.js\nimport { log } from './logger'\nimport './style.css'\n\nlog('hello parcel')\n```\n\n保存过后，样式文件可以立即生效。效果如下：\n\n![](https://cdn.zce.me/assets/fe9c51919977a2c2.png)\n\n你会发现，导入样式的操作，整个过程我们并没有停下来做额外的事情。\n\n总之，Parcel 希望给开发者的体验就是想做什么，只管去做，其他额外的事情就交给工具来处理。\n\n#### 动态导入\n\n另外，Parcel 同样支持直接使用动态导入，内部也会自动处理代码拆分，我们也一起来尝试一下。\n\n这里我们先将静态导入的 jQuery 注释掉。然后使用动态导入的方式导入 jQuery 模块。具体代码如下：\n\n```javascript\n// ./src/main.js\n// import $ from 'jquery'\nimport { log } from './logger'\n\nlog('hello parcel')\n\nimport('jquery').then($ => {\n  $(document.body).append('<h1>Hello Parcel</h1>')\n})\n```\n\n`import` 函数返回的就是一个 `Promise` 对象，在这个 `Promise` 对象 `then` 方法的回调中，我们就能够拿到导入的模块对象了，然后我们就可以把使用 jQuery 的代码移到这个回调函数中。\n\n保存过后，回到浏览器，找到开发人员工具的 Network 面板，这里就能够看到拆分出来的 jquery 所对应的 bundle 文件请求了。具体效果如下图：\n\n![](https://cdn.zce.me/assets/f14495b21ccc8390.png)\n\n那以上基本上就是 Parcel 最常用的一些特性了，使用上根本没有任何难度，从头到尾我们都只是执行了一个 Parcel 命令。\n\n#### 生产模式打包\n\n接下来我们来看，Parcel 如何以生产模式打包。生产模式打包，具体命令如下：\n\n```shell\n$ npx parcel build src/index.html\n```\n\n我们只需要执行 parcel build 然后跟上打包入口文件路径，就可以以生产模式运行打包了。\n\n这里补充一点，相同体量的项目打包，Parcel 的构建速度会比 Webpack 快很多。因为 Parcel  内部使用的是多进程同时工作，充分发挥了多核 CPU 的性能。\n\n> P.S. Webpack 中也可以使用一个叫作 [happypack](https://github.com/amireh/happypack) 的插件实现这一点。\n\n那我们这里再来看一下输出的打包结果，具体结果如下：\n\n![](https://cdn.zce.me/assets/432eae972975d89a.png)\n\n此时，dist 目录下就都是本次打包的结果了。这里的输出文件也都会被压缩，而且样式代码也会被单独提取到单个文件中。\n\n那这就是 Parcel 的体验，整体体验下来就是一个感觉：舒服，因为它在使用上真的太简单了。\n\n### 写在最后\n\nParcel 是 2017 年发布的，出现的原因是因为当时的 Webpack 使用过于烦琐，文档也不是很清晰明了，所以 Parcel 一经推出就迅速被推上风口浪尖。其核心特点就是：\n\n- 真正做到了完全零配置，对项目没有任何的侵入；\n- 自动安装依赖，开发过程更专注；\n- 构建速度更快，因为内部使用了多进程同时工作，能够充分发挥多核 CPU 的效率。\n\n但是目前看来，如果你去观察开发者的实际使用情况，绝大多数项目的打包还是会选择 Webpack。个人认为原因有两点：\n\n1. Webpack 生态更好，扩展更丰富，出现问题容易解决；\n2. 随着这两年的发展，Webpack 越来越好用，开发者也越来越熟悉。\n\n所以，Parcel 这样的工具对于开发者而言，我们去了解它，也就是为了保持对新鲜技术和工具的敏感度，从而更好地把握技术趋势和走向，仅此而已。\n\n以上就是近期 Webpack 系列全部的内容，我是汪磊，我们下个系列再见 👋\n","cover":"https://cdn.zce.me/assets/2f4c3c326f5b9198.png","audio":"https://cdn.zce.me/audio/2020/04/webpack-13.mp3"},{"title":"Webpack 与 Rollup 二者之间该如何选择？","slug":"webpack-vs-rollup","date":1588098471000,"updated":1673100032265,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","Rollup"],"meta":{},"content":"\n你好，我是汪磊，今天我要跟你介绍另外一款同样十分优秀的打包工具：Rollup。\n\n![](https://cdn.zce.me/assets/29b5780d31d6ba02.png)\n\nRollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。\n\n从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。因为 Webpack 在配合一些插件的使用下，几乎可以完成开发过程中绝大多数前端工程化的工作。而 Rollup 可以说仅仅是一个 ES Modules 打包器，没有更多其他的功能了。\n\n例如，在 Webpack 中支持 HMR 这种对开发过程十分友好的功能，而在 Rollup 中就没有办法完全支持。\n\nRollup 诞生的目的并不是要与 Webpack 这样的工具全面竞争。它的初衷只是希望能够**提供一个高效的 ES Modules 打包器，充分利用 ES Modules 的各项特性，构建出结构扁平，性能出众的类库**。\n\n至于它的其他特点和优势，我们需要上手过后才能深入了解。\n\n### 快速上手\n\n这里我准备了一个简单的示例，具体结构如下：\n\n```diff\n.\n├── src\n│   ├── index.js\n│   ├── logger.js\n│   └── messages.js\n└── package.json\n```\n\n在这个示例的源代码中我准备了三个文件，并且使用 ES Modules 组织的代码模块化。部分代码如下：\n\n```javascript\n// ./src/messages.js\nexport default {\n  hi: 'Hey Guys, I am zce~'\n}\n\n// ./src/logger.js\nexport const log = msg => {\n  console.log('---------- INFO ----------')\n  console.log(msg)\n  console.log('--------------------------')\n}\nexport const error = msg => {\n  console.error('---------- ERROR ----------')\n  console.error(msg)\n  console.error('---------------------------')\n}\n\n// ./src/index.js\nimport { log } from './logger'\nimport messages from './messages'\nlog(messages.hi)\n```\n\n如上述代码所示，其中：\n\n- messages.js: 文件中以默认导出的方式导出了一个对象；\n- logger.js: 文件中单个导出了两个函数成员；\n- 最后在 index.js: 文件中导入了这两个模块，并且使用了它们。\n\n接下来，我们尝试使用 Rollup 完成这个示例应用的打包。这里需要先通过 npm 安装 rollup 这个模块。具体命令如下：\n\n```shell\n$ npm i rollup --save-dev\n```\n\n安装完成过后，rollup 这个模块同样会在 `node_modules/.bin` 目录中为我们提供一个 CLI 程序，我们就可以通过这个 CLI 去使用 Rollup 打包。具体命令如下：\n\n```shell\n$ npx rollup\n```\n\n> P.S. 对于 `node_modules/.bin` 目录下的 CLI，我们可以使用 npx 命令或者 yarn 命令直接启动。\n\n执行 rollup 命令，在不传递任何参数的情况下，这个命令会自动打印出它的帮助信息。具体如下图：\n\n![](https://cdn.zce.me/assets/c1767e77783c260a.png)\n\n在这个帮助信息的一开始，就已经告诉我们 rollup 命令的正确用法了：我们应该通过参数指定一个打包入口文件。正确命令如下：\n\n```shell\n$ npx rollup ./src/index.js\n```\n\n这里指定的打包入口是 src/index.js 文件。再次执行 rollup 命令，具体执行结果如下：\n\n![](https://cdn.zce.me/assets/927cb0387bc150fe.png)\n\n根据控制台的输出结果，我们发现 Rollup 直接将打包结果打印到控制台中了。\n\n当然，正常情况下我们还是需要将打包结果输出到一个文件中。具体就是通过 CLI 的 `--file` 参数指定输出文件路径，具体命令如下：\n\n```shell\n$ npx rollup ./src/index.js --file ./dist/bundle.js\n```\n\n这样打包的结果就会输出到文件中。\n\n完成以后，我们找到 Rollup 打包输出的文件，具体结果如下：\n\n![](https://cdn.zce.me/assets/69f38f7ab4d63082.png)\n\n在这个文件中我们的第一印象就是，Rollup 打包结果惊人的简洁，基本上就跟我们手写的代码一样。相比于 Webpack 大量的引导代码和一堆的模块函数，这里的输出结果没有任何多余代码，就是把打包过程中的各个模块按照依赖顺序，先后拼接到了一起。\n\n而且我们仔细观察打包结果，你会发现，在我们输出的结果中只会保留那些用到的部分，对于未引用部分都没有输出。这是因为 Rollup 默认会自动开启 Tree-shaking 优化输出结果，Tree-shaking 的概念最早也就是 Rollup 这个工具提出的。\n\n#### 配置文件\n\nRollup 同样支持以配置文件的方式去配置打包过程中的各项参数，我们可以在项目的根目录下新建一个 rollup.config.js 的配置文件。具体结构如下：\n\n```diff\n .\n ├── src\n │   ├── index.js\n │   ├── logger.js\n │   └── messages.js\n ├── package.json\n+└── rollup.config.js\n```\n\n这个文件虽然同样是运行在 Node.js 环境中，但是 Rollup 会额外处理配置文件，所以在 rollup.config.js 中我们可以直接使用 ES Modules 标准。具体代码如下：\n\n```javascript\n// ./rollup.config.js\nexport default {\n  input: 'src/index.js',\n  output: {\n    file: 'dist/bundle.js',\n    format: 'es' // 输出格式\n  }\n}\n```\n\n这个文件中需要导出一个配置对象，在这个对象中我们可以通过 `input` 属性指定打包的入口文件路径，通过 `output` 指定输出相关配置，`output` 属性是一个对象，在 `output` 对象中可以使用 `file` 属性指定输出的文件名，`format` 属性指定输出代码的格式。\n\n完成以后，我们回到命令行，再次执行 rollup 命令，不过需要注意的是，这里需要通过 `--config` 参数来表明使用项目中的配置文件。你也可以通过这个参数来指定不同的配置文件名称。具体命令如下：\n\n```shell\n$ npx rollup --config # 使用默认配置文件\n$ npx rollup --config rollup.prod.js # 指定配置文件路径\n```\n\n#### 输出格式\n\nRollup 打包支持多种输出格式，这里我们回到配置文件中，配置同时输出所有格式下的文件，具体配置如下：\n\n```javascript\n// ./rollup.config.js\n// 所有 Rollup 支持的格式\nconst formats = ['es', 'amd', 'cjs', 'iife', 'umd', 'system']\n\nexport default formats.map(format => ({\n  input: 'src/index.js',\n  output: {\n    file: `dist/bundle.${format}.js`,\n    format\n  }\n}))\n```\n\n在这个配置当中我们导出了一个数组，数组中的每个成员都是一个单独的打包配置，这样 Rollup 就会分别按照每个配置单独打包。这一点与 Webpack 非常相似。\n\n配置完成之后，我们回到命令行终端，再次运行 Rollup 打包。那这次打包过后，dist 目录下就会生成不同格式的输出结果，如下图所示：\n\n![](https://cdn.zce.me/assets/f483661b798e435e.png)\n\n你可以自己依次去了解一下每种格式的输出结果，其实不同的输出格式大都是为了适配不同的运行环境，并没有什么需要额外理解的地方。\n\n#### 使用插件\n\nRollup 自身的功能就只是 ES Modules 模块的合并，如果有更高级的要求，例如加载其他类型的资源文件或者支持导入 CommonJS 模块，又或是编译 ES 新特性，这些额外的需求 Rollup 同样支持使用插件去扩展实现。\n\nWebpack 中划分了 Loader、Plugin 和 Minimizer 三种扩展方式，而插件是 Rollup 的唯一的扩展方式。\n\n这里我们先来尝试使用一个可以让我们在代码中导入 JSON 文件的插件：[@rollup/plugin-json](https://github.com/rollup/plugins/tree/master/packages/json)，通过这个过程来了解如何在 Rollup 中使用插件。\n\n首先我们需要将 @rollup/plugin-json 作为项目的开发依赖安装进来。具体安装命令：\n\n```shell\n$ npm i @rollup/plugin-json --save-dev\n```\n\n安装完成过后，我们打开配置文件。由于 rollup 的配置文件中可以直接使用 ES Modules，所以我们这里使用 `import` 导入这个插件模块。具体代码如下：\n\n```javascript\n// ./rollup.config.js\nimport json from '@rollup/plugin-json'\n\nexport default {\n  input: 'src/index.js',\n  output: {\n    file: 'dist/bundle.js',\n    format: 'es'\n  },\n  plugins: [json()]\n}\n```\n\n@rollup/plugin-json 模块的默认导出就是一个插件函数。我们可以将这个函数的调用结果添加到配置对象的 `plugins` 数组中，注意这里是将调用结果放到数组中，而不是将这个函数直接放进去。\n\n配置好这个插件过后，我们就可以在代码中通过 `import` 导入 json 文件了。我们回到 index.js 文件中，这里我们尝试通过 `import` 导入 package.json，具体代码如下：\n\n```javascript\n// ./src/index.js\nimport { name, version } from '../package.json'\n\nconsole.log(name, version)\n```\n\n那这个 JSON 文件中的每一个属性都会作为单独的导出成员。我们可以提取一下 JSON 中的 name 和 version，然后把它打印出来。\n\n完成以后，我们打开命令行终端，再次运行 Rollup 打包。打包完成以后，我们找到输出的 bundle.js，具体结果如下：\n\n![](https://cdn.zce.me/assets/2832b6701aa29588.png)\n\n此时你就能看到，package.json 中的 name 和 version 正常被打包进来了，而且其他没用到的属性也都被 Tree-shaking 移除掉了。\n\n以上就是 Rollup 中插件的使用。\n\n#### 加载 NPM 模块\n\nRollup 默认只能够按照文件路径的方式加载本地的模块文件，对于 node_modules 目录中的第三方模块，并不能像 Webpack 一样，直接通过模块名称直接导入。\n\n为了抹平这个差异，Rollup 给出了一个 [@rollup/plugin-node-resolve](https://github.com/rollup/plugins/tree/master/packages/node-resolve) 插件，通过使用这个插件，我们就可以在代码中直接使用模块名称导入模块了。\n\n同样，我们需要先安装这个插件，具体命令如下：\n\n```shell\n$ npm i @rollup/plugin-node-resolve --save-dev\n```\n\n安装完成过后，打开配置文件，这里同样导入插件函数，然后把它配置到 `plugins` 数组中。具体配置如下：\n\n```javascript\n// ./rollup.config.js\nimport json from '@rollup/plugin-json'\nimport resolve from '@rollup/plugin-node-resolve'\n\nexport default {\n  input: 'src/index.js',\n  output: {\n    file: 'dist/bundle.js',\n    format: 'es'\n  },\n  plugins: [json(), resolve()]\n}\n```\n\n完成以后我们就可以回到代码中直接导入 `node_modules` 中的第三方模块了。例如：\n\n```javascript\n// ./src/index.js\nimport { camelCase } from 'lodash-es'\nconsole.log(camelCase('hello rollup'))\n```\n\n这里我导入的是我提前安装好的一个 [lodash-es](https://www.npmjs.com/package/lodash-es) 模块，这个模块就是常用的 Lodash 模块的 ESM 版本。导入过后我们就可以使用这个模块所提供的工具方法了。\n\n> P.S. 相比于普通的 lodash，lodash-es 可以更好地支持 Tree-shaking。\n\n完成过后我们再次打开命令行终端，运行 Rollup 打包，此时 lodash 就能够打包到我们的 bundle.js 中了。\n\n这里使用 Lodash 的 ESM 版本而不是 Lodash 普通版本的原因是 Rollup 默认只能处理 ESM 模块。如果要使用普通版本则需要额外处理。\n\n#### 加载 CommonJS 模块\n\n由于 Rollup 设计的是只处理 ES Modules 模块的打包，所以如果在代码中导入 CommonJS 模块，默认是不被支持的。但是目前大量的 NPM 模块还是使用 CommonJS 方式导出成员，所以为了兼容这些模块。官方给出了一个插件，叫作 [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs)。\n\n这个插件在用法上跟前面两个插件是一样的，我就不单独演示了。我们直接看一下这个插件的效果。这里我添加了一个 cjs-module.js 文件，具体代码如下：\n\n```javascript\n// ./src/cjs-module.js\nmodule.exports = {\n  foo: 'bar'\n}\n```\n\n这个文件中使用 CommonJS 的方式导出了一个对象。然后回到入口文件中通过 ES Modules 的方式导入，具体代码如下：\n\n```javascript\n// ./src/index.js\n// 导入 CommonJS 模块成员\nimport cjs from './cjs-module'\n\n// 使用模块成员\nconsole.log(cjs) // cjs => { foo: 'bar' }\n```\n\n入口文件导入的结果就是 cjs-module.js 中导出的对象了。\n\n### Code Splitting\n\nRollup 的最新版本中已经开始支持代码拆分了。我们同样可以使用符合 ES Modules 标准的动态导入方式实现模块的按需加载。例如：\n\n```javascript\n// ./src/index.js\n// 动态导入的模块会自动分包\nimport('./logger').then(({ log }) => {\n  log('code splitting~')\n})\n```\n\nRollup 内部也会处理代码拆分。不过按照之前的配置方式，这里直接打包会报出一个错误：\n\n![](https://cdn.zce.me/assets/c019df7a712b79a8.png)\n\n出现这个错误的原因是：在 Rollup 在分包过后会输出多个 JS 文件，需要我们在配置中指定输出的目录，而不是一个具体的文件名，具体配置如下：\n\n```javascript\n// ./rollup.config.js\nexport default {\n  input: 'src/index.js',\n  output: {\n    // file: 'dist/bundle.js', // code splitting 输出的是多个文件\n    dir: 'dist',\n    format: 'es'\n  }\n}\n```\n\n这里我们将 `output` 配置中的 `file` 选项删掉，取而代之的是添加一个 `dir` 选项，把它设置为 `'dist'`，也就是输出到 dist 目录中。\n\n这样的话，再次打包就可以正常输出了。具体输出结果如下：\n\n![](https://cdn.zce.me/assets/c3674bd416d2d97d.png)\n\n这次打包过程中，Rollup 就会自动提取动态导入的模块到单独的 JS 文件中了。\n\n#### 输出格式问题\n\n目前采用的输出格式是 `es`，所以自动分包过后，得到的代码还是使用 ES Modules 实现的动态模块加载，具体输出结果如下：\n\n![](https://cdn.zce.me/assets/e292cad225eb5291.png)\n\n很明显，这种方式的代码仍然会存在环境兼容性问题：如果在低版本浏览器，这种输出结果是无法正常执行的。\n\n解决这个问题的办法就是修改 Rollup 打包输出的格式。目前所有支持动态导入的输出格式中，只有 `amd` 和 `system` 两种格式打包的结果适合于浏览器环境。\n\n所以在这种情况下，我们可以选择以 `amd` 或者 `system` 格式输出。这里我们以 `amd` 为例，这里我们先将 Rollup 配置中的 `format` 设置为 `'amd'`。具体配置如下：\n\n```javascript\n// ./rollup.config.js\nexport default {\n  input: 'src/index.js',\n  output: {\n    dir: 'dist',\n    format: 'amd'\n  }\n}\n```\n\n这样的话，再次打包输出的结果就是采用 AMD 标准组织的代码了，具体如下：\n\n![](https://cdn.zce.me/assets/df64129e21434d88.png)\n\n需要注意一点，这种 AMD 标准在浏览器中也不是直接支持的，也就是说我们还是需要使用一个支持这个标准的库来加载这些输出的模块，例如 [Require.js](https://requirejs.org)，具体使用方式参考：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>AMD Format output</title>\n  </head>\n  <body>\n    <script\n      src=\"https://unpkg.com/requirejs@2.3.6/require.js\"\n      data-main=\"dist/index.js\"\n    ></script>\n  </body>\n</html>\n```\n\n> P.S. 本文中所有的案例源代码：[https://github.com/zce/rollup-demo](https://github.com/zce/rollup-demo)\n\n### 写在最后\n\n通过以上的探索，我们发现 Rollup 确实有它的优势：\n\n- 输出结果更加扁平，执行效率更高；\n- 自动移除未引用代码；\n- 打包结果依然完全可读。\n\n但是它的缺点也同样明显：\n\n- 加载非 ESM 的第三方模块比较复杂；\n- 因为模块最终都被打包到全局中，所以无法实现 HMR；\n- 浏览器环境中，代码拆分功能必须使用 Require.js 这样的 AMD 库。\n\n综合以上特点，我们发现如果我们开发的是一个应用程序，需要大量引用第三方模块，同时还需要 HMR 提升开发体验，而且应用过大就必须要分包。那这些需求 Rollup 都无法满足。\n\n而如果我们是开发一个 JavaScript 框架或者库，那这些优点就特别有必要，而缺点呢几乎也都可以忽略，所以在很多像 React 或者 Vue 之类的框架中都是使用的 Rollup 作为模块打包器，而并非 Webpack。\n\n但是到目前为止，开源社区中大多数人还是希望这两个工具共同存在，并且能够相互支持和借鉴，原因很简单：让更专业的工具完成更专业的事情。\n\n总结一下：**Webpack 大而全，Rollup 小而美**。\n\n在对它们的选择上，我的基本原则是：**应用开发使用 Webpack，类库或者框架开发使用 Rollup**。\n\n**不过这并不是绝对的标准，只是经验法则**。因为 Rollup 也可用于构建绝大多数应用程序，而 Webpack 同样也可以构建类库或者框架。\n\n另外随着近几年 Webpack 的发展，Rollup 中的很多优势几乎已经抹平了，所以这种对比慢慢地也就没有太大意义了。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n","cover":"https://cdn.zce.me/assets/31f60c36a06b0286.png","audio":"https://cdn.zce.me/audio/2020/04/webpack-12.mp3"},{"title":"生产环境下 Webpack 构建结果该如何优化？","slug":"webpack-production-optimization","date":1588012071000,"updated":1673100032257,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","Optimization"],"meta":{},"content":"\n你好，我是汪磊，今天我们要一起探索的是 Webpack 在生产模式打包过程中的一些常用配置和一些的优化插件。\n\n在前面的文章中，我们了解到的一些用法和特性都是为了在开发阶段能够拥有更好的开发体验。而随着这些体验的提升，一个新的问题出现在我们面前：我们的打包结果会变得越来越臃肿。\n\n这是因为在这个过程中 Webpack 为了实现这些特性，会自动往打包结果中添加一些内容。例如我们之前用到的 [Source Map](/2020/04/best-practices-of-webpack-sourcemap/) 和 [HMR](/2020/04/webpack-hot-module-replacement/)，它们都会在输出结果中添加额外代码来实现各自的功能。\n\n但是这些额外的代码对生产环境来说是冗余的。因为生产环境和开发环境有很大的差异，在生产环境中我们强调的是以更少量、更高效的代码完成业务功能，也就是注重运行效率。而开发环境中我们注重的只是开发效率。\n\n那针对这个问题，Webpack 4 推出了 mode 的用法，为我们提供了不同模式下的一些预设配置，其中生产模式下就已经包括了很多优化配置。\n\n同时 Webpack 也建议我们为不同的工作环境创建不同的配置，以便于让我们的打包结果可以适用于不同的环境。\n\n接下来我们一起来探索一下生产环境中的一些优化方式和注意事项。\n\n### 不同环境下的配置\n\n我们先为不同的工作环境创建不同的 Webpack 配置。创建不同环境配置的方式主要有两种：\n\n- 在配置文件中添加相应的判断条件，根据环境不同导出不同配置。\n- 为不同环境单独添加一个配置文件，一个环境对应一个配置文件。\n\n我们分别尝试一下通过这两种方式，为开发环境和生产环境创建不同配置。\n\n首先我们来看在配置文件中添加判断的方式。我们回到配置文件中，Webpack 配置文件还支持导出一个函数，然后在函数中返回所需要的配置对象。这个函数可以接收两个参数，第一个是 `env`，是我们通过 CLI 传递的环境名参数，第二个是 `argv`，是运行 CLI 过程中的所有参数。具体代码如下：\n\n```javascript\n// ./webpack.config.js\nmodule.exports = (env, argv) => {\n  return {\n    // ... webpack 配置\n  }\n}\n```\n\n那我们就可以借助这个特点，为开发环境和生产环境创建不同配置。我先将不同模式下公共的配置定义为一个 config 对象，具体代码如下：\n\n```javascript\n// ./webpack.config.js\nmodule.exports = (env, argv) => {\n  const config = {\n    // ... 不同模式下的公共配置\n  }\n  return config\n}\n```\n\n然后通过判断，再为 `config` 对象添加不同环境下的特殊配置。具体如下：\n\n```javascript\n// ./webpack.config.js\nmodule.exports = (env, argv) => {\n  const config = {\n    // ... 不同模式下的公共配置\n  }\n\n  if (env === 'development') {\n    // 为 config 添加开发模式下的特殊配置\n    config.mode = 'development'\n    config.devtool = 'cheap-eval-module-source-map'\n  } else if (env === 'production') {\n    // 为 config 添加生产模式下的特殊配置\n    config.mode = 'production'\n    config.devtool = 'nosources-source-map'\n  }\n\n  return config\n}\n```\n\n例如这里，我们判断 `env` 等于 `'development'`（开发模式）的时候，我们将 mode 设置为 `'development'`，将 `devtool` 设置为 `'cheap-eval-module-source-map'`；而当 `env` 等于 `'production'`（生产模式）时，我们又将 `mode` 和 `devtool` 设置为生产模式下需要的值。\n\n当然，你还可以分别为不同模式设置其他不同的属性、插件，这也都是类似的。\n\n通过这种方式完成配置过后，我们打开命令行终端，这里我们再去执行 webpack 命令时就可以通过 `--env` 参数去指定具体的环境名称，从而实现在不同环境中使用不同的配置。\n\n那这就是通过在 Webpack 配置文件导出的函数中对环境进行判断，从而实现不同环境对应不同配置。这种方式是 Webpack 建议的方式。\n\n你也可以直接定义环境变量，然后在全局判断环境变量，根据环境变量的不同导出不同配置。这种方式也是类似的，这里我们就不做过多介绍了。\n\n#### 不同环境的配置文件\n\n通过判断环境名参数返回不同配置对象的方式只适用于中小型项目，因为一旦项目变得复杂，我们的配置也会一起变得复杂起来。所以对于大型的项目来说，还是建议使用不同环境对应不同配置文件的方式来实现。\n\n一般在这种方式下，项目中最少会有三个 webpack 的配置文件。其中两个用来分别适配开发环境和生产环境，另外一个则是公共配置。因为开发环境和生产环境的配置并不是完全不同的，所以需要一个公共文件来抽象两者相同的配置。具体配置文件结构如下：\n\n```diff\n.\n├── webpack.common.js ···························· 公共配置\n├── webpack.dev.js ······························· 开发模式配置\n└── webpack.prod.js ······························ 生产模式配置\n```\n\n首先我们在项目根目录下新建一个 webpack.common.js，在这个文件中导出不同模式下的公共配置；然后再来创建一个 webpack.dev.js 和一个 webpack.prod.js 分别定义开发和生产环境特殊的配置。\n\n在不同环境的具体配置中我们先导入公共配置对象，然后这里可以使用 `Object.assign()` 方法把公共配置对象复制到具体环境的配置对象中，并且同时去覆盖其中的一些配置。具体如下：\n\n```javascript\n// ./webpack.common.js\nmodule.exports = {\n  // ... 公共配置\n}\n\n// ./webpack.prod.js\nconst common = require('./webpack.common')\nmodule.exports = Object.assign(common, {\n  // 生产模式配置\n})\n\n// ./webpack.dev.js\nconst common = require('./webpack.common')\nmodule.exports = Object.assign(common, {\n  // 开发模式配置\n})\n```\n\n如果你熟悉 `Object.assign()` 方法，就应该知道，这个方法会完全覆盖掉前一个对象中的同名属性。这个特点对于普通值类型属性的覆盖都没有什么问题。但是像配置中的 `plugins` 这种数组，我们只是希望在原有公共配置的插件基础上添加一些插件，那 `Object.assign()` 就做不到了。\n\n所以我们需要更合适的方法来合并这里的配置与公共的配置。你可以使用 [Lodash](http://lodash.com) 提供的 `merge` 函数来实现，不过社区中提供了更为专业的模块 [webpack-merge](https://github.com/survivejs/webpack-merge)，它专门用来满足我们这里合并 Webpack 配置的需求。\n\n我们可以先通过 npm 安装一下 webpack-merge 模块。具体命令如下：\n\n```shell\n$ npm i webpack-merge --save-dev\n# or yarn add webpack-merge --dev\n```\n\n安装完成过后我们回到配置文件中，这里先载入这个模块。那这个模块导出的就是一个 `merge` 函数，我们使用这个函数来合并我们这里的配置与公共的配置。具体代码如下：\n\n```javascript\n// ./webpack.common.js\nmodule.exports = {\n  // ... 公共配置\n}\n\n// ./webpack.prod.js\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common')\nmodule.exports = merge(common, {\n  // 生产模式配置\n})\n\n// ./webpack.dev.jss\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common')\nmodule.exports = merge(common, {\n  // 开发模式配置\n})\n```\n\n使用 webpack-merge 过后，我们这里的配置对象就可以跟普通的 webpack 配置一样，需要什么就配置什么，merge 函数内部会自动处理合并的逻辑。\n\n分别配置完成过后，我们再次回到命令行终端，然后尝试运行 webpack 打包。不过因为这里已经没有默认的配置文件了，所以我们需要通过 `--config` 参数来指定我们所使用的配置文件路径。例如：\n\n```javascript\n$ webpack --config webpack.prod.js\n```\n\n当然，如果你觉得这样操作让我们的命令变得更复杂了。那你也可以把这个构建命令定义到 npm scripts 中，方便使用。\n\n### 生产模式下的优化插件\n\n在 Webpack 4 中新增的 production 模式下，内部就自动开启了很多通用的优化功能。对于使用者而言，开箱即用是非常方便的，但是对于学习者而言，这种开箱即用会导致我们忽略掉很多需要了解的东西。以至于出现问题无从下手。\n\n如果你想要深入了解 Webpack 的使用，我建议你去单独研究每一个配置背后的作用。这里我们先一起学习 production 模式下几个主要的优化功能，顺便了解一下 Webpack 如何优化打包结果。\n\n#### Define Plugin\n\n首先是 DefinePlugin，DefinePlugin 是用来为我们代码中注入全局成员的。在 production 模式下，默认通过这个插件往代码中注入了一个 `process.env.NODE_ENV`。很多第三方模块都是通过这个成员去判断运行环境，从而决定是否执行例如打印日志之类的操作。\n\n这里我们来单独使用一下这个插件。我们回到配置文件中，DefinePlugin 是一个内置的插件，所以我们先导入 webpack 模块，然后再到 `plugins` 中添加这个插件。这个插件的构造函数接收一个对象参数，对象中的成员都可以被注入到代码中。具体代码如下：\n\n```javascript\n// ./webpack.config.js\nconst webpack = require('webpack')\n\nmodule.exports = {\n/  // ... 其他配置\n  plugins: [\n    new webpack.DefinePlugin({\n      API_BASE_URL: 'https://api.example.com'\n    })\n  ]\n}\n```\n\n例如我们这里通过 DefinePlugin 定义一个 `API_BASE_URL` 变量，用来为我们的代码注入 API 服务地址，它的值是一个字符串。\n\n然后我们回到代码中打印这个 `API_BASE_URL`。具体代码如下：\n\n```javascript\n// ./src/main.js\nconsole.log(API_BASE_URL)\n```\n\n完成以后我们打开控制台，然后运行 webpack 打包。打包完成过后我们找到打包的结果，然后找到 main.js 对应的模块。具体结果如下：\n\n![](https://cdn.zce.me/assets/6a44af0aaa5c15bb.png)\n\n这里我们发现 DefinePlugin 其实就是把我们配置的字符串内容直接替换到了代码中，而目前这个字符串的内容为 `https://api.example.com`，字符串中并没有包含引号，所以替换进来语法自然有问题。\n\n正确的做法是传入一个字符串字面量语句。具体实现如下：\n\n```javascript\n// ./webpack.config.js\nconst webpack = require('webpack')\n\nmodule.exports = {\n  // ... 其他配置\n  plugins: [\n    new webpack.DefinePlugin({\n      // 值要求的是一个代码片段\n      API_BASE_URL: '\"https://api.example.com\"'\n    })\n  ]\n}\n```\n\n这样代码内的 `API_BASE_URL` 就会被替换为 `'https://api.example.com'`。具体结果如下：\n\n![](https://cdn.zce.me/assets/d9dc9c010f637f55.png)\n\n另外，这里有一个非常常用的小技巧，如果我们需要注入的是一个值，就可以通过 `JSON.stringify()` 的方式来得到表示这个值的字面量。这样就不容易出错了。具体实现如下：\n\n```javascript\n// ./webpack.config.js\nconst webpack = require('webpack')\n\nmodule.exports = {\n  // ... 其他配置\n  plugins: [\n    new webpack.DefinePlugin({\n      // 值要求的是一个代码片段\n      API_BASE_URL: JSON.stringify('https://api.example.com')\n    })\n  ]\n}\n```\n\nDefinePlugin 的作用虽然简单，但是却非常有用，我们可以用它在代码中注入一些可能变化的值。\n\n#### Mini CSS Extract Plugin\n\n对于 CSS 文件的打包，一般我们会使用 style-loader 进行处理，这种处理方式最终的打包结果就是 CSS 代码会内嵌到 JS 代码中。\n\nmini-css-extract-plugin 是一个可以将 CSS 代码从打包结果中提取出来的插件，\n\n它的使用也非常简单，同样也需要先通过 npm 安装一下这个插件。具体命令如下：\n\n```javascript\n$ npm i mini-css-extract-plugin --save-dev\n```\n\n安装完成过后，我们回到 Webpack 的配置文件。具体配置如下：\n\n```javascript\n// ./webpack.config.js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = {\n  mode: 'none',\n  entry: {\n    main: './src/index.js'\n  },\n  output: {\n    filename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 'style-loader', // 将样式通过 style 标签注入\n          MiniCssExtractPlugin.loader,\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [new MiniCssExtractPlugin()]\n}\n```\n\n我们这里先导入这个插件模块，导入过后我们就可以将这个插件添加到配置对象的 `plugins` 数组中了。这样 Mini CSS Extract Plugin 在工作时就会自动提取代码中的 CSS 了。\n\n除此以外，Mini CSS Extract Plugin 还需要我们使用 MiniCssExtractPlugin 中提供的 loader 去替换掉 style-loader，以此来捕获到所有的样式。\n\n这样的话，打包过后，样式就会存放在独立的文件中，直接通过 `link` 标签引入页面。\n\n不过这里需要注意的是，如果你的 CSS 体积不是很大的话，提取到单个文件中，效果可能适得其反，因为单独的文件就需要单独请求一次。个人经验是如果 CSS 超过 200KB 才需要考虑是否提取出来，作为单独的文件。\n\n#### Optimize CSS Assets Webpack Plugin\n\n使用了 Mini CSS Extract Plugin 过后，样式就被提取到单独的 CSS 文件中了。但是这里同样有一个小问题。\n\n我们回到命令行，这里我们以生产模式运行打包。那按照之前的了解，生产模式下会自动压缩输出的结果，我们可以打开打包生成的 JS 文件。具体结果如下：\n\n![](https://cdn.zce.me/assets/8418f05c93118a29.png)\n\n然后我们再打开输出的样式文件。具体结果如下：\n\n![](https://cdn.zce.me/assets/bb3bf698476e2a4a.png)\n\n这里我们发现 JavaScript 文件正常被压缩了，而样式文件并没有被压缩。\n\n这是因为，Webpack 内置的压缩插件仅仅是针对 JS 文件的压缩，其他资源文件的压缩都需要额外的插件。\n\nWebpack 官方推荐了一个 [Optimize CSS Assets Webpack Plugin](https://www.npmjs.com/package/optimize-css-assets-webpack-plugin) 插件。我们可以使用这个插件来压缩我们的样式文件。\n\n我们回到命令行，先来安装这个插件，具体命令如下：\n\n```shell\n$ npm i optimize-css-assets-webpack-plugin --save-dev\n```\n\n安装完成过后，我们回到配置文件中，添加对应的配置。具体代码如下：\n\n```javascript\n// ./webpack.config.js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\n\nmodule.exports = {\n  mode: 'none',\n  entry: {\n    main: './src/index.js'\n  },\n  output: {\n    filename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader']\n      }\n    ]\n  },\n  plugins: [new MiniCssExtractPlugin(), new OptimizeCssAssetsWebpackPlugin()]\n}\n```\n\n这里同样先导入这个插件，导入完成以后我们把这个插件添加到 `plugins` 数组中。\n\n那此时我们再次回到命令行运行打包。\n\n打包完成过后，我们的样式文件就会以压缩格式输出了。具体结果如下：\n\n![](https://cdn.zce.me/assets/0c7a400b68ce66d4.png)\n\n不过这里还有个额外的小点，可能你会在这个插件的官方文档中发现，文档中的这个插件并不是配置在 `plugins` 数组中的，而是添加到了 `optimization` 对象中的 `minimizer` 属性中。具体如下：\n\n```javascript\n// ./webpack.config.js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\n\nmodule.exports = {\n  mode: 'none',\n  entry: {\n    main: './src/index.js'\n  },\n  output: {\n    filename: '[name].bundle.js'\n  },\n  optimization: {\n    minimizer: [new OptimizeCssAssetsWebpackPlugin()]\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader']\n      }\n    ]\n  },\n  plugins: [new MiniCssExtractPlugin()]\n}\n```\n\n那这是为什么呢？\n\n其实也很简单，如果我们配置到 `plugins` 属性中，那么这个插件在任何情况下都会工作。而配置到 `minimizer` 中，就只会在 minimize 特性开启时才工作。\n\n所以 Webpack 建议像这种压缩插件，应该我们配置到 `minimizer` 中，便于 `minimize` 选项的统一控制。\n\n但是这么配置也有个缺点，此时我们再次运行生产模式打包，打包完成后再来看一眼输出的 JS 文件，此时你会发现，原本可以自动压缩的 JS，现在却不能压缩了。具体 JS 的输出结果如下：\n\n![](https://cdn.zce.me/assets/683095dcb6fe459d.png)\n\n那这是因为我们设置了 minimizer，Webpack 认为我们需要使用自定义压缩器插件，那内部的 JS 压缩器就会被覆盖掉。我们必须手动再添加回来。\n\n内置的 JS 压缩插件叫作 terser-webpack-plugin，我们回到命令行手动安装一下这个模块。\n\n```shell\n$ npm i terser-webpack-plugin --save-dev\n```\n\n安装完成过后，这里我们再手动添加这个模块到 `minimizer` 配置当中。具体代码如下：\n\n```javascript\n// ./webpack.config.js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\n\nmodule.exports = {\n  mode: 'none',\n  entry: {\n    main: './src/index.js'\n  },\n  output: {\n    filename: '[name].bundle.js'\n  },\n  optimization: {\n    minimizer: [new TerserWebpackPlugin(), new OptimizeCssAssetsWebpackPlugin()]\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader']\n      }\n    ]\n  },\n  plugins: [new MiniCssExtractPlugin()]\n}\n```\n\n那这样的话，我们再次以生产模式运行打包，JS 文件和 CSS 文件就都可以正常压缩了。\n\n### 写在最后\n\n最后再来简单总结一下，今天我们介绍了如何为 Webpack 添加不同环境下的不同配置，以及在生产模式打包时我们经常用到的几个插件。\n\n这当中需要你理解的地方并没有太多，更多的是了解这些插件的具体作用和使用方法。除此之外，你也需要更多地了解社区当中其他的常用插件。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n\n> Photo by [Austin Distel](https://unsplash.com/@austindistel) on [Unsplash](https://unsplash.com)\n","cover":"https://cdn.zce.me/assets/ef47785406405928.jpg","audio":"https://cdn.zce.me/audio/2020/04/webpack-11.mp3"},{"title":"利用 Webpack CodeSplitting 完成复杂应用拆包","slug":"webpack-code-splitting","date":1587925671000,"updated":1673100032249,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","CodeSplitting"],"meta":{},"content":"\n你好，我是汪磊，今天我将继续和你分享 Webpack 另外的一个高级特性，Code Splitting（代码分包）。\n\n### All in One 的弊端\n\n通过 Webpack 实现前端项目整体模块化的优势固然明显，但是它也会存在一些弊端：它最终会将我们所有的代码打包到一起。试想一下，如果我们的应用非常复杂，模块非常多，那么这种 All in One 的方式就会导致打包的结果过大，甚至超过 4 ～ 5M。\n\n在绝大多数的情况下，应用刚开始工作时，并不是所有的模块都是必需的。如果这些模块全部被打包到一起，即便应用只需要一两个模块工作，也必须先把 bundle.js 整体加载进来，而且前端应用一般都是运行在浏览器端，这也就意味着应用的响应速度会受到影响，也会浪费大量的流量和带宽。\n\n所以这种 All in One 的方式并不合理，更为合理的方案是**把打包的结果按照一定的规则分离到多个 bundle 中，然后根据应用的运行需要按需加载**。这样就可以降低启动成本，提高响应速度。\n\n可能你会联想到我们在[开篇](/2020/04/webpack-the-cornerstone-of-modern-app/)中讲过，_Webpack 就是通过把项目中散落的模块打包到一起，从而提高加载效率_，那么为什么这里又要分离？这不是自相矛盾吗？\n\n其实这并不矛盾，只是物极必反罢了。Web 应用中的资源受环境所限，太大不行，太碎更不行。因为我们开发过程中划分模块的颗粒度一般都会非常的细，很多时候一个模块只是提供了一个小工具函数，并不能形成一个完整的功能单元。\n\n如果我们不将这些资源模块打包，直接按照开发过程中划分的模块颗粒度进行加载，那么运行一个小小的功能，就需要加载非常多的资源模块。\n\n再者，目前仍是主流（🐶）的 HTTP 1.1 本身就存在一些缺陷，例如：\n\n- 同一个域名下的并行请求是有限制的；\n- 每次请求本身都会有一定的延迟；\n- 每次请求除了传输内容，还有额外的请求头，大量请求的情况下，这些请求头加在一起也会浪费流量和带宽。\n\n综上所述，模块打包肯定是必要的，但当应用体积越来越大时，我们也要学会变通。\n\n### Code Splitting\n\n为了解决打包结果过大导致的问题，Webpack 设计了一种分包功能：Code Splitting（代码分割）。\n\nCode Splitting 通过把项目中的资源模块按照我们设计的规则打包到不同的 bundle 中，从而降低应用的启动成本，提高响应速度。\n\nWebpack 实现分包的方式主要有两种：\n\n- 根据业务不同配置多个打包入口，输出多个打包结果；\n- 结合 ES Modules 的动态导入（Dynamic Imports）特性，按需加载模块。\n\n#### 多入口打包\n\n多入口打包一般适用于传统的多页应用程序，最常见的划分规则就是一个页面对应一个打包入口，对于不同页面间公用的部分，再提取到公共的结果中。\n\nWebpack 配置多入口打包的方式非常简单，这里我准备了一个[相应的示例](https://github.com/zce/webpack-multi-entry)，具体结构如下：\n\n> **示例源码**:\n>\n> - GitHub：[https://github.com/zce/webpack-multi-entry](https://github.com/zce/webpack-multi-entry)\n> - CodeSandbox：[https://codesandbox.io/s/github/zce/webpack-multi-entry](https://codesandbox.io/s/github/zce/webpack-multi-entry)\n\n```javascript\n.\n├── dist\n├── src\n│   ├── common\n│   │   ├── fetch.js\n│   │   └── global.css\n│   ├── album.css\n│   ├── album.html\n│   ├── album.js\n│   ├── index.css\n│   ├── index.html\n│   └── index.js\n├── package.json\n└── webpack.config.js\n```\n\n这个示例中有两个页面，分别是 index 和 album。代码组织的逻辑也很简单：\n\n- index.js: 负责实现 index 页面功能逻辑；\n- album.js: 负责实现 album 页面功能逻辑；\n- global.css: 是公用的样式文件；\n- fetch.js: 是一个公用的模块，负责请求 API。\n\n我们回到配置文件中，这里我们尝试为这个案例配置多入口打包，具体配置如下：\n\n```javascript\n// ./webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: {\n    index: './src/index.js',\n    album: './src/album.js'\n  },\n  output: {\n    filename: '[name].bundle.js' // [name] 是入口名称\n  },\n  // ... 其他配置\n  plugins: [\n    new HtmlWebpackPlugin({\n      title: 'Multi Entry',\n      template: './src/index.html',\n      filename: 'index.html'\n    }),\n    new HtmlWebpackPlugin({\n      title: 'Multi Entry',\n      template: './src/album.html',\n      filename: 'album.html'\n    })\n  ]\n}\n```\n\n一般 `entry` 属性中只会配置一个打包入口，如果我们需要配置多个入口，可以把 `entry` 定义成一个对象。\n\n> 注意：这里 `entry` 是定义为对象而不是数组，如果是数组的话就是把多个文件打包到一起，还是一个入口。\n\n在这个对象中一个属性就是一个入口，属性名称就是这个入口的名称，值就是这个入口对应的文件路径。那我们这里配置的就是 index 和 album 页面所对应的 JS 文件路径。\n\n一旦我们的入口配置为多入口形式，那输出文件名也需要修改，因为两个入口就有两个打包结果，不能都叫 bundle.js。我们可以在这里使用 `[name]` 这种占位符来输出动态的文件名，`[name]` 最终会被替换为入口的名称。\n\n除此之外，在配置中还通过 html-webpack-plugin 分别为 index 和 album 页面生成了对应的 HTML 文件。\n\n完成配置之后，我们就可以打开命令行终端，运行 Webpack 打包，那此次打包会有两个入口。打包完成后，我们找到输出目录，这里就能看到两个入口文件各自的打包结果了，如下图所示：\n\n![](https://cdn.zce.me/assets/c039ba8e262da492.png)\n\n但是这里还有一个小问题，我们打开任意一个输出的 HTML 文件，具体结果如下图：\n\n![](https://cdn.zce.me/assets/293683f18389e606.png)\n\n你就会发现 index 和 album 两个打包结果都被页面载入了，而我们希望的是每个页面只使用它对应的那个输出结果。\n\n所以这里还需要修改配置文件，我们回到配置文件中，找到输出 HTML 的插件，默认这个插件会自动注入所有的打包结果，如果需要指定所使用的 bundle，我们可以通过 `HtmlWebpackPlugin` 的 `chunks` 属性来设置。我们分别为两个页面配置使用不同的 chunk，具体配置如下：\n\n> 💡：每个打包入口都会形成一个独立的 chunk（块）。\n\n```javascript\n// ./webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: {\n    index: './src/index.js',\n    album: './src/album.js'\n  },\n  output: {\n    filename: '[name].bundle.js' // [name] 是入口名称\n  },\n  // ... 其他配置\n  plugins: [\n    new HtmlWebpackPlugin({\n      title: 'Multi Entry',\n      template: './src/index.html',\n      filename: 'index.html',\n      chunks: ['index'] // 指定使用 index.bundle.js\n    }),\n    new HtmlWebpackPlugin({\n      title: 'Multi Entry',\n      template: './src/album.html',\n      filename: 'album.html',\n      chunks: ['album'] // 指定使用 album.bundle.js\n    })\n  ]\n}\n```\n\n完成以后我们再次回到命令行终端，然后运行打包，打包结果如下图：\n\n![](https://cdn.zce.me/assets/4a4cc7bac2f4c4cf.png)\n\n这一次打包的结果就完全正常了。\n\n那这就是配置多入口打包的方法，以及如何指定在 HTML 中注入的 bundle。\n\n##### 提取公共模块\n\n多入口打包本身非常容易理解和使用，但是它也存在一个小问题，就是不同的入口中一定会存在一些公共使用的模块，如果按照目前这种多入口打包的方式，就会出现多个打包结果中有相同的模块的情况。\n\n例如我们上述案例中，index 入口和 album 入口中就共同使用了 global.css 和 fetch.js 这两个公共的模块。这里是因为我们的示例比较简单，所以重复的影响没有那么大，但是如果我们公共使用的是 jQuery 或者 Vue.js 这些体积较大的模块，那影响就会比较大，不利于公共模块的缓存。\n\n所以我们还需要把这些公共的模块提取到一个单独的 bundle 中。Webpack 中实现公共模块提取非常简单，我们只需要在优化配置中开启 `splitChunks` 功能就可以了，具体配置如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: {\n    index: './src/index.js',\n    album: './src/album.js'\n  },\n  output: {\n    filename: '[name].bundle.js' // [name] 是入口名称\n  },\n  optimization: {\n    splitChunks: {\n      // 自动提取所有公共模块到单独 bundle\n      chunks: 'all'\n    }\n  }\n  // ... 其他配置\n}\n```\n\n我们回到配置文件中，这里在 `optimization` 属性中添加 `splitChunks` 属性，那这个属性的值是一个对象，这个对象需要配置一个 `chunks` 属性，我们这里将它设置为 `'all'`，表示所有公共模块都可以被提取。\n\n完成以后我们打开命令行终端，再次运行 Webpack 打包，打包结果如下图：\n\n![](https://cdn.zce.me/assets/821296266a03ae0a.png)\n\n此时在我们的 dist 下就会额外生成一个 JS 文件，在这个文件中就是 index 和 album 中公共的模块部分了。\n\n除此之外，splitChunks 还支持很多高级的用法，可以实现各种各样的分包策略，这些我们可以在[文档](https://webpack.js.org/plugins/split-chunks-plugin/)中找到对应的介绍。\n\n#### 动态导入\n\n除了多入口打包的方式，Code Splitting 更常见的实现方式还是结合 ES Modules 的动态导入特性，从而实现按需加载。\n\n按需加载是开发浏览器应用中一个非常常见的需求。一般我们常说的按需加载指的是加载数据或者加载图片，但是我们这里所说的按需加载，指的是在应用运行过程中，需要某个资源模块时，才去加载这个模块。这种方式极大地降低了应用启动时需要加载的资源体积，提高了应用的响应速度，同时也节省了带宽和流量。\n\nWebpack 中支持使用动态导入的方式实现模块的按需加载，而且所有动态导入的模块都会被自动提取到单独的 bundle 中，从而实现分包。\n\n相比于多入口的方式，动态导入更为灵活，因为我们可以通过代码中的逻辑去控制需不需要加载某个模块，或者什么时候加载某个模块。而且我们分包的目的中，很重要的一点就是让模块实现按需加载，从而提高应用的响应速度。\n\n接下来，我们具体来看如何使用动态导入特性，这里我已经设计了一个可以发挥按需加载作用的场景，具体效果如下图所示：\n\n![](https://cdn.zce.me/assets/7b4afb4493a7bce6.gif)\n\n在这个应用的主体区域，如果我们访问的是首页，它显示的是一个文章列表，如果我们访问的是相册页，它显示的就是相册列表。\n\n回到代码中，我们来看目前的实现方式，具体结构如下：\n\n```diff\n.\n├── src\n│   ├── album\n│   │   ├── album.css\n│   │   └── album.js\n│   ├── common\n│   │   ├── fetch.js\n│   │   └── global.css\n│   ├── posts\n│   │   ├── posts.css\n│   │   └── posts.js\n│   ├── index.html\n│   └── index.js\n├── package.json\n└── webpack.config.js\n```\n\n文章列表对应的是这里的 posts 组件，而相册列表对应的是 album 组件。我在打包入口（index.js）中同时导入了这两个模块，然后根据页面锚点的变化决定显示哪个组件，核心代码如下：\n\n```javascript\n// ./src/index.js\nimport posts from './posts/posts'\nimport album from './album/album'\nconst update = () => {\n  const hash = window.location.hash || '#posts'\n  const mainElement = document.querySelector('.main')\n  mainElement.innerHTML = ''\n  if (hash === '#posts') {\n    mainElement.appendChild(posts())\n  } else if (hash === '#album') {\n    mainElement.appendChild(album())\n  }\n}\nwindow.addEventListener('hashchange', update)\nupdate()\n```\n\n在这种情况下，就可能产生资源浪费。试想一下：如果用户只需要访问其中一个页面，那么加载另外一个页面对应的组件就是浪费。\n\n如果我们采用动态导入的方式，就不会产生浪费的问题了，因为所有的组件都是惰性加载，只有用到的时候才会去加载。具体实现代码如下：\n\n```javascript\n// ./src/index.js\n// import posts from './posts/posts'\n// import album from './album/album'\nconst update = () => {\n  const hash = window.location.hash || '#posts'\n  const mainElement = document.querySelector('.main')\n  mainElement.innerHTML = ''\n  if (hash === '#posts') {\n    // mainElement.appendChild(posts())\n    import('./posts/posts').then(({ default: posts }) => {\n      mainElement.appendChild(posts())\n    })\n  } else if (hash === '#album') {\n    // mainElement.appendChild(album())\n    import('./album/album').then(({ default: album }) => {\n      mainElement.appendChild(album())\n    })\n  }\n}\nwindow.addEventListener('hashchange', update)\nupdate()\n```\n\n> P.S. 为了动态导入模块，可以将 import 关键字作为函数调用。当以这种方式使用时，import 函数返回一个 Promise 对象。这就是 ES Modules 标准中的[Dynamic Imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports)。\n\n这里我们先移除 `import` 这种静态导入，然后在需要使用组件的地方通过 `import` 函数导入指定路径，那这个方法返回的是一个 `Promise`。在这个 `Promise` 的 `then` 方法中我们能够拿到模块对象。由于我们这里的 posts 和 album 模块是以默认成员导出，所以我们需要解构模块对象中的 `default`，先拿到导出成员，然后再正常使用这个导出成员。\n\n完成以后，Webpack Dev Server 自动重新打包，我们再次回到浏览器，此时应用仍然是可以正常工作的。\n\n那我们再回到命令行终端，重新运行打包，然后看看此时的打包结果具体是怎样的。打包完成以后我们打开 dist 目录，具体结果如下图所示：\n\n![](https://cdn.zce.me/assets/2485b10c8b96e15f.png)\n\n此时 dist 目录下就会额外多出三个 JS 文件，其中有两个文件是动态导入的模块，另外一个文件是动态导入模块中公共的模块，这三个文件就是由动态导入自动分包产生的。\n\n以上就是动态导入在 Webpack 中的使用。整个过程我们无需额外配置任何地方，只需要按照 ES Modules 动态导入的方式去导入模块就可以了，Webpack 内部会自动处理分包和按需加载。\n\n如果你使用的是 Vue.js 之类的 SPA 开发框架的话，那你项目中路由映射的组件就可以通过这种动态导入的方式实现按需加载，从而实现分包。\n\n##### 魔法注释\n\n默认通过动态导入产生的 bundle 文件，它的 name 就是一个序号，这并没有什么不好，因为大多数时候，在生产环境中我们根本不用关心资源文件的名称。\n\n但是如果你还是需要给这些 bundle 命名的话，就可以使用 Webpack 所特有的魔法注释去实现。具体方式如下：\n\n```javascript\n// 魔法注释\nimport(/* webpackChunkName: 'posts' */ './posts/posts').then(\n  ({ default: posts }) => {\n    mainElement.appendChild(posts())\n  }\n)\n```\n\n所谓魔法注释，就是在 import 函数的形式参数位置，添加一个行内注释，这个注释有一个特定的格式：`webpackChunkName: '<chunk-name>'`，这样就可以给分包的 chunk 起名字了。\n\n完成过后，我们再次打开命令行终端，运行 Webpack 打包，那此时我们生成 bundle 的 name 就会使用刚刚注释中提供的名称了，具体结果如下：\n\n![](https://cdn.zce.me/assets/d23c90181fc4891f.png)\n\n除此之外，魔法注释还有个特殊用途：如果你的 `<chunk-name>` 相同的话，那相同的 `<chunk-name>` 最终就会被打包到一起，例如我们这里可以把这两个 `<chunk-name>` 都设置为 components，然后再次运行打包，那此时这两个模块都会被打包到一个文件中，具体操作如下图所示：\n\n![](https://cdn.zce.me/assets/7a7f1332c739a130.png)\n\n借助这个特点，你就可以根据自己的实际情况，灵活组织动态加载的模块了。\n\n### 写在最后\n\n最后我们来总结一下今天的核心内容，我们介绍了为什么要进行分包，以及 Webpack Code Splitting 的两种实现方式，分别是多入口打包和动态导入，其中动态导入会更常用到。\n\n在这里，我想跟你再额外聊几句我的看法，其实从事开发工作就是不断“制造”问题，再不断解决问题。也正是在这样的一个制造问题解决问题的过程中，行业的技术、标准、工具不断迭代，不断完善，这是一个向好的过程。作为开发人员千万不要怕麻烦，应该多思考，多积累，才能更好地适应，甚至是引领行业的变化。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n\n> Photo by [Kevin Schmid](https://unsplash.com/@lighttouchedphotography) on [Unsplash](https://unsplash.com)\n","cover":"https://cdn.zce.me/assets/5bd445e86b010b95.jpg","audio":"https://cdn.zce.me/audio/2020/04/webpack-10.mp3"},{"title":"玩转 Webpack 的 TreeShaking 与 sideEffects 特性","slug":"webpack-tree-shaking-and-sideeffects","date":1587839271000,"updated":1673100032217,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","Tree-shaking"],"meta":{},"content":"\n你好，我是汪磊，今天我想和你分享 Webpack 的两个高级特性，分别是 Tree Shaking 和 sideEffects。\n\n它们都属于 Webpack 打包结果优化的必备特性，而且现在应用的也十分广泛。\n\n### Tree Shaking\n\nTree Shaking 翻译过来的意思就是“摇树”。伴随着摇树的动作，树上的枯树枝和树叶就会掉落下来。\n\n我们这里要介绍的 Tree-shaking 也是同样的道理，不过通过 Tree-shaking “摇掉”的是代码中那些没有用到的部分，这部分没有用的代码更专业的说法应该叫作未引用代码（dead-code）。\n\nTree-shaking 最早是 [Rollup](https://rollupjs.org) 工具中推出的一个特性，Webpack 从 2.0 过后开始支持这个特性。\n\n我们使用 Webpack 生产模式打包过程中，就会自动开启这个功能，以此来检测我们代码中的未引用代码，然后自动移除它们，从而达到对打包结果的优化。\n\n我们可以先来体验一下这个功能的效果，这里我的源代码非常简单，只有两个文件。\n\n```javascript\n└─ 09-tree-shaking\n   ├── src\n   │   ├── components.js\n   │   └── main.js\n   ├── package.json\n   └── webpack.config.js\n```\n\n其中 components.js 中导出了一些函数，这些函数各自模拟了一个组件，具体代码如下：\n\n```javascript\n// ./src/components.js\nexport const Button = () => {\n  return document.createElement('button')\n  console.log('dead-code')\n}\nexport const Link = () => {\n  return document.createElement('a')\n}\nexport const Heading = level => {\n  return document.createElement('h' + level)\n}\n```\n\n其中 Button 组件函数中，在 `return` 过后还有一个 `console.log()` 语句，很明显这句代码永远都不会被执行，所以这个 `console.log()` 就属于未引用代码。\n\n此外，在 main.js 文件中只是导入了 compnents.js，具体代码如下：\n\n```javascript\n// ./src/main.js\nimport { Button } from './components'\ndocument.body.appendChild(Button())\n```\n\n注意这里导入 components 模块时，我们只提取了模块中的 Button 成员，那这就导致 components 模块中很多地方都不会被用到，那这些地方就是冗余的，具体冗余部分如下：\n\n```javascript\n// ./src/components.js\nexport const Button = () => {\n  return document.createElement('button')\n  // 未引用代码\n  console.log('dead-code')\n}\n// 未引用代码\nexport const Link = () => {\n  return document.createElement('a')\n}\n// 未引用代码\nexport const Heading = level => {\n  return document.createElement('h' + level)\n}\n```\n\n**去除冗余代码**是生产环境优化中一个很重要的工作，Webpack 的 Tree-shaking 功能就很好地实现了这一点。\n\n我们打开命令行终端，这里我们尝试以 production 模式运行打包，具体命令如下：\n\n```shell\n$ npx webpack --mode=production\n```\n\nWebpack 的 Tree-shaking 特性在生产模式下会自动开启。打包完成以后我们打开输出的 bundle.js，具体结果如下：\n\n![经过 Tree-shaking 后的 bundle.js](https://cdn.zce.me/assets/31758dbe409207d1.png)\n\n通过搜索你会发现，components 模块中冗余的代码根本没有输出。这就是经过 Tree-shaking 处理过后的效果。\n\n试想一下，如果我们在项目中引入 [Lodash](https://lodash.com) 这种工具库，大部分情况下我们只会使用其中的某几个工具函数，而其他没有用到的部分就都属于冗余代码。通过 Tree-shaking 就可以极大地减少最终打包后 bundle 的体积。\n\n需要注意的是，**Tree-shaking  并不是指 Webpack 中的某一个配置选项，而是一组功能搭配使用过后实现的效果**，这组功能在生产模式下都会自动启用，所以使用生产模式打包就会有 Tree-shaking 的效果。\n\n#### 开启 Tree Shaking\n\n由于目前官方文档中对于 Tree-shaking 的介绍有点混乱，所以我们这里再来介绍一下在其他模式下，如何一步一步手动开启 Tree-shaking。通过这个过程，还可以顺便了解 Tree-shaking 的工作过程和 Webpack 其他的一些优化功能。\n\n这里还是使用上述的案例结构，我们再次运行 Webpack 打包，不过这一次我们不再使用 production 模式，而是使用 none，也就是不开启任何内置功能和插件，具体命令如下：\n\n```shell\n$ npx webpack --mode=none\n```\n\n打包完成过后，我们再次找到输出的 bundle.js 文件，具体结果如下：\n\n![none 模式下的打包结果](https://cdn.zce.me/assets/b75bd0fda19825e8.png)\n\n这里的打包结果跟我们在[之前文章](/2020/04/how-to-use-webpack-modular-package/)中分析的是一样的，源代码中的一个模块对应这里的一个函数。\n\n我们这里注意一下 components 对应的这个模块，虽然外部没有使用这里的 `Link` 函数和 `Heading` 函数，但是仍然导出了它们，具体如下图所示：\n\n![bundle.js 中的 components 模块](https://cdn.zce.me/assets/7f1b626fd9e0d013.png)\n\n显然这种导出是没有任何意义的。\n\n明确目前打包结果的状态过后，我们打开 Webpack 的配置文件，在配置对象中添加一个 `optimization` 属性，这个属性用来集中配置 Webpack 内置优化功能，它的值也是一个对象。\n\n在 `optimization` 对象中我们可以先开启一个 `usedExports` 选项，表示在输出结果中只导出外部使用了的成员，具体配置代码如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // ... 其他配置项\n  optimization: {\n    // 模块只导出被使用的成员\n    usedExports: true\n  }\n}\n```\n\n配置完成后，重新打包，然后我们再来看一下输出的 bundle.js，具体结果如下图：\n\n![usedExports 后的 components 模块](https://cdn.zce.me/assets/676676dfdd8dd42d.png)\n\n此时你会发现 components 模块所对应的函数，就不再导出 `Link` 和 `Heading` 这两个函数了，那它们对应的代码就变成了未引用代码。而且如果你使用的是 VS Code，会发现 VS Code 将这两个函数名的颜色变淡了，这是为了表示它们未被引用。\n\n对于这种未引用代码，如果我们开启压缩代码功能，就可以自动压缩掉这些没有用到的代码。\n\n我们可以回到配置文件中，尝试在 `optimization` 配置中开启 `minimize`，具体配置如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // ... 其他配置项\n  optimization: {\n    // 模块只导出被使用的成员\n    usedExports: true,\n    // 压缩输出结果\n    minimize: true\n  }\n}\n```\n\n然后再次回到命令行重新运行打包，具体结果如下图所示：\n\n![结合 minimize 后的结果](https://cdn.zce.me/assets/18fd3a64aaa68939.png)\n\n仔细查看打包结果，你会发现，`Link` 和 `Heading` 这些未引用代码都被自动移除了。\n\n这就是 Tree-shaking 的实现，整个过程用到了 Webpack 的两个优化功能：\n\n- **usedExports** - 打包结果中只导出外部用到的成员；\n- **minimize** - 压缩打包结果。\n\n如果把我们的代码看成一棵大树，那你就可以这样理解：\n\n- **usedExports** 的作用就是标记树上哪些是枯树枝、枯树叶；\n- **minimize** 的作用就是负责把枯树枝、枯树叶摇下来。\n\n#### 合并模块 \\*\n\n除了 `usedExports` 选项之外，我们还可以使用一个 `concatenateModules` 选项继续优化输出。\n\n普通打包只是将一个模块最终放入一个单独的函数中，如果我们的模块很多，就意味着在输出结果中会有很多的模块函数。\n\n`concatenateModules` 配置的作用就是尽可能将所有模块合并到一起输出到一个函数中，这样既提升了运行效率，又减少了代码的体积。\n\n我们回到配置文件中，这里我们在 `optimization` 属性中开启 `concatenateModules`。同时，为了更好地看到效果，我们先关闭 `minimize`，具体配置如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // ... 其他配置项\n  optimization: {\n    // 模块只导出被使用的成员\n    usedExports: true,\n    // 尽可能合并每一个模块到一个函数中\n    concatenateModules: true,\n    // 压缩输出结果\n    minimize: false\n  }\n}\n```\n\n然后回到命令行终端再次运行打包。那此时 bundle.js 中就不再是一个模块对应一个函数了，而是把所有的模块都放到了一个函数中，具体结果如下：\n\n![开启 concatenateModules 后的结果](https://cdn.zce.me/assets/14062e4f32635e16.png)\n\n这个特性又被称为 **Scope Hoisting**，也就是作用域提升，它是 Webpack 3.0 中添加的一个特性。\n\n如果再配合 `minimize` 选项，打包结果的体积又会减小很多。\n\n#### 结合 babel-loader 的问题\n\n因为早期的 Webpack 发展非常快，那变化也就比较多，所以当我们去找资料时，得到的结果不一定适用于当前我们所使用的版本。而 Tree-shaking 的资料更是如此，很多资料中都表示“_为 JS 模块配置 babel-loader，会导致 Tree-shaking 失效_”。\n\n针对这个问题，这里我统一说明一下：\n\n首先你需要明确一点：**Tree-shaking 实现的前提是 ES Modules**，也就是说：**最终交给 Webpack 打包的代码，必须是使用 ES Modules 的方式来组织的模块化**。\n\n为什么这么说呢？\n\n我们都知道 Webpack 在打包所有的模块代码之前，先是将模块根据配置交给不同的 Loader 处理，最后再将 Loader 处理的结果打包到一起。\n\n很多时候，我们为了更好的兼容性，会选择使用 [babel-loader](https://github.com/babel/babel-loader) 去转换我们源代码中的一些 ECMAScript 的新特性。而 Babel 在转换 JS 代码时，很有可能处理掉我们代码中的 ES Modules 部分，把它们转换成 CommonJS 的方式，如下图所示：\n\n![babel-loader](https://cdn.zce.me/assets/e1aba93739bd991f.png)\n\n当然了，Babel 具体会不会处理 ES Modules 代码，取决于我们有没有为它配置使用转换 ES Modules 的插件。\n\n很多时候，我们为 Babel 配置的都是一个 `preset`（预设插件集合），而不是某些具体的插件。例如，目前市面上使用最多的 [@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env)，这个预设里面就有[转换 ES Modules 的插件](https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs)。所以当我们使用这个预设时，代码中的 ES Modules 部分就会被转换成 CommonJS 方式。那 Webpack 再去打包时，拿到的就是以 CommonJS 方式组织的代码了，所以 Tree-shaking 不能生效。\n\n那我们这里具体来尝试一下。为了可以更容易分辨结果，我们只开启 usedExports，完整配置如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [['@babel/preset-env']]\n          }\n        }\n      }\n    ]\n  },\n  optimization: {\n    usedExports: true\n  }\n}\n```\n\n配置完成过后，我们打开命令行终端，运行 Webpack 打包命令，然后再找到 bundle.js，具体结果如下：\n\n![结合 babel-loader 的打包结果](with-https://cdn.zce.me/assets/e1aba93739bd991f.png)\n\n仔细查看你会发现，结果并不是像刚刚说的那样，**这里 usedExports 功能仍然正常工作了**，此时，如果我们压缩代码，这些未引用的代码依然会被移除。这也就说明 Tree-shaking 并没有失效。\n\n那到底是怎么回事呢？为什么很多资料都说 babel-loader 会导致 Tree-shaking 失效，但当我们实际尝试后又发现并没有失效？\n\n其实，这是因为**在最新版本（8.x）的 babel-loader 中，已经自动帮我们关闭了对 ES Modules 转换的插件**，你可以参考[对应版本 babel-loader 的源码](https://github.com/babel/babel-loader/blob/v8.1.0/src/injectCaller.js)，核心代码如下：\n\n![对应版本 babel-loader 的源码](https://cdn.zce.me/assets/be22efe6a969c288.png)\n\n通过查阅 babel-loader 模块的源码，我们发现它已经在 `injectCaller` 函数中标识了当前环境支持 ES Modules。\n\n然后再找到我们所使用的 @babal/preset-env 模块源码，部分核心代码如下：\n\n![@babal/preset-env 模块源码](https://cdn.zce.me/assets/95ed1ae32e8ef48c.png)\n\n在这个模块中，根据环境标识自动禁用了对 ES Modules 的转换插件，所以**经过 babel-loader 处理后的代码默认仍然是 ES Modules**，那 Webpack 最终打包得到的还是 ES Modules 代码，Tree-shaking 自然也就可以正常工作了。\n\n我们也可以在 babel-loader 的配置中强制开启 ES Modules 转换插件来试一下，具体配置如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [['@babel/preset-env', { modules: 'commonjs' }]]\n          }\n        }\n      }\n    ]\n  },\n  optimization: {\n    usedExports: true\n  }\n}\n```\n\n给 Babel 的 Preset 添加配置的方式比较特别，这里很多人都会配错，一定要注意。它需要把预设数组中的成员定义成一个数组，然后这个数组中的第一个成员就是所使用的 Preset 的名称，第二个成员就是给这个 Preset 定义的配置对象。\n\n我们在这个对象中将 `modules` 属性设置为 `'commonjs'`，默认这个属性是 `'auto'`，也就是根据环境判断是否开启 ES Modules 插件，我们设置为 `'commonjs'` 就表示我们强制使用 Babel 的 ES Modules 插件把代码中的 ES Modules 转换为 CommonJS。\n\n完成以后，我们再次打开命令行终端，运行 Webpack 打包。然后找到 bundle.js，结果如下：\n\n![强制开启 ESM 转换插件](https://cdn.zce.me/assets/ba07214c36eaca35.png)\n\n此时，你就会发现 usedExports 没法生效了。即便我们开启压缩代码，Tree-shaking 也会失效。\n\n总结一下，这里通过实验发现，最新版本的 babel-loader 并不会导致 Tree-shaking 失效。如果你不确定现在使用的 babel-loader 会不会导致这个问题，最简单的办法就是在配置中将 @babel/preset-env 的 `modules` 属性设置为 `false`，确保不会转换 ES Modules，也就确保了 Tree-shaking 的前提。\n\n另外，我们刚刚探索的过程也值得你仔细再去琢磨一下，通过这样的探索能够帮助你了解很多背后的原因，做到“知其然，知其所以然”。\n\n### sideEffects\n\nWebpack 4 中新增了一个 sideEffects 特性，它允许我们通过配置标识我们的代码是否有副作用，从而提供更大的压缩空间。\n\n> 💡：模块的副作用指的就是模块执行的时候除了导出成员，是否还做了其他的事情。\n\n这个特性一般只有我们去开发一个 npm 模块时才会用到。因为官网把对 sideEffects 特性的介绍跟 Tree-shaking 混到了一起，所以很多人误认为它们之间是因果关系，个人观点，它们其实没有什么太大的关系。\n\n我们先把 sideEffects 特性本身的作用弄明白，你就更容易理解为什么说它跟 Tree-shaking 没什么关系了。\n\n这里我先设计一个 sideEffects 能够发挥效果的场景，案例具体结构如下：\n\n```diff\n.\n├── src\n│   ├── components\n│   │   ├── button.js\n│   │   ├── heading.js\n│   │   ├── index.js\n│   │   └── link.js\n│   └── main.js\n├── package.json\n└── webpack.config.js\n```\n\n基于上一个案例的基础上，我们把 components 模块拆分出多个组件文件，然后在 components/index.js 中集中导出，以便于外界集中导入，具体 index.js 代码如下：\n\n```javascript\n// ./src/components/index.js\nexport { default as Button } from './button'\nexport { default as Link } from './link'\nexport { default as Heading } from './heading'\n```\n\n这也是我们经常见到一种同类文件的组织方式。另外，在每个组件中，我们都添加了一个 `console` 操作（副作用代码），具体代码如下：\n\n```javascript\n// ./src/components/button.js\nconsole.log('Button component~') // 副作用代码\n\nexport default () => {\n  return document.createElement('button')\n}\n```\n\n我们再到打包入口文件（main.js）中去载入 components 中的 Button 成员，具体代码如下：\n\n```javascript\n// ./src/main.js\nimport { Button } from './components'\ndocument.body.appendChild(Button())\n```\n\n那这样就会出现一个问题，虽然我们在这里只是希望载入 Button 模块，但实际上载入的是 components/index.js，而 index.js 中又载入了这个目录中全部的组件模块，这就会导致所有组件模块都会被加载执行。\n\n我们打开命令行终端，尝试运行打包，打包完成过后找到打包结果，具体结果如下：\n\n![](https://cdn.zce.me/assets/63be1abb604810e1.png)\n\n根据打包结果发现，所有的组件模块都被打包进了 bundle.js。\n\n此时如果我们开启 Tree-shaking 特性（只设置 useExports），这里没有用到的导出成员其实最终也可以被移除，打包效果如下：\n\n![开启 useExports](https://cdn.zce.me/assets/006d4d998f9ce30b.png)\n\n但是由于这些成员所属的模块中有副作用代码，所以就导致最终 Tree-shaking 过后，这些模块并不会被完全移除。\n\n可能你会认为这些代码应该保留下来，而实际情况是，这些模块内的副作用代码一般都是为这个模块服务的，例如这里我添加的 `console.log(...)`，就是希望表示一下当前这个模块被加载了。但是最终整个模块都没用到，也就没必要留下这些副作用代码了。\n\n所以说，**Tree-shaking 只能移除没有用到的代码成员，而想要完整移除没有用到的模块，那就需要开启 sideEffects 特性了。**\n\n#### sideEffects 作用\n\n我们打开 Webpack 的配置文件，在 `optimization` 中开启 `sideEffects` 特性，具体配置如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  optimization: {\n    sideEffects: true\n  }\n}\n```\n\n> 💡：注意这个特性在 production 模式下同样会自动开启。\n\n那此时 Webpack 在打包某个模块之前，会先检查这个模块所属的 package.json 中的 `sideEffects` 标识，以此来判断这个模块是否有副作用，如果没有副作用的话，这些没用到的模块就不再被打包。换句话说，即便这些没有用到的模块中存在一些副作用代码，我们也可以通过 package.json 中的 `sideEffects` 去强制声明没有副作用。\n\n那我们打开项目 package.json 添加一个 `sideEffects` 字段，把它设置为 `false`，具体代码如下：\n\n```json\n{\n  \"name\": \"09-side-effects\",\n  \"version\": \"0.1.0\",\n  \"author\": \"zce <w@zce.me> (https://zce.me)\",\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"build\": \"webpack\"\n  },\n  \"devDependencies\": {\n    \"webpack\": \"^4.43.0\",\n    \"webpack-cli\": \"^3.3.11\"\n  },\n  \"sideEffects\": false\n}\n```\n\n这样就表示我们这个项目中的所有代码都没有副作用，让 Webpack 放心大胆地去“干”。\n\n完成以后我们再次运行打包，然后同样找到打包输出的 bundle.js 文件，结果如下：\n\n![sideEffects 特性产生的结果](https://cdn.zce.me/assets/8a48872107c0efc4.png)\n\n此时那些没有用到的模块就彻底不会被打包进来了。那这就是 sideEffects 的作用。\n\n这里设置了两个地方：\n\n- webpack.config.js 中的 `sideEffects` 用来开启这个功能；\n- package.json 中的 `sideEffects` 用来标识我们的代码没有副作用。\n\n目前很多第三方的库或者框架都已经使用了 sideEffects 标识，所以我们再也不用担心为了一个小功能引入一个很大体积的库了。例如，某个 UI 组件库中只有一两个组件会用到，那只要它支持 sideEffects，你就可以放心大胆的直接用了。\n\n#### sideEffects 注意\n\n使用 sideEffects 这个功能的前提是确定你的代码没有副作用，或者副作用代码没有全局影响，否则打包时就会误删掉你那些有意义的副作用代码。\n\n例如，我这里准备的 extend.js 模块：\n\n```javascript\n// ./src/extend.js\n// 为 Number 的原型添加一个扩展方法\nNumber.prototype.pad = function (size) {\n  const leadingZeros = Array(size + 1).join(0)\n  return leadingZeros + this\n}\n```\n\n在这个模块中并没有导出任何成员，仅仅是在 `Number` 的原型上挂载了一个 `pad` 方法，用来为数字添加前面的导零，这是一种很早以前常见的基于原型的扩展方法。\n\n我们回到 main.js 中去导入 extend 模块，具体代码如下：\n\n```javascript\n// ./src/main.js\nimport './extend' // 内部包含影响全局的副作用\nconsole.log((8).pad(3)) // => '0008'\n```\n\n因为这个模块确实没有导出任何成员，所以这里也就不需要提取任何成员。导入过后就可以使用它为 `Number` 提供扩展方法了。\n\n这里为 `Number` 类型做扩展的操作就是 extend 模块对全局产生的副作用。\n\n此时如果我们还是通过 package.json 标识我们代码没有副作用，那么再次打包过后，就会出现问题。我们可以找到打包结果，如下图所示：\n\n![使用 sideEffects 产生的影响](https://cdn.zce.me/assets/6e68984abb948716.png)\n\n我们看到，对 `Number` 的扩展模块并不会打包进来。\n\n缺少了对 `Number` 的扩展操作，我们的代码再去运行的时候，就会出现错误。这种扩展的操作属于对全局产生的副作用。\n\n这种基于原型的扩展方式，在很多 Polyfill 库中都会大量出现，比较常见的有 [es6-promise](https://github.com/stefanpenner/es6-promise)，这种模块都属于典型的副作用模块。\n\n除此之外，我们在 JS 中直接载入的 CSS 模块，也都属于副作用模块，同样会面临这种问题。\n\n所以说不是所有的副作用都应该被移除，有一些必要的副作用需要保留下来。\n\n最好的办法就是在 package.json 中的 sideEffects 字段中标识需要保留副作用的模块路径（可以使用通配符），具体配置如下：\n\n```json\n{\n  \"name\": \"09-side-effects\",\n  \"version\": \"0.1.0\",\n  \"author\": \"zce <w@zce.me> (https://zce.me)\",\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"build\": \"webpack\"\n  },\n  \"devDependencies\": {\n    \"webpack\": \"^4.43.0\",\n    \"webpack-cli\": \"^3.3.11\"\n  },\n  \"sideEffects\": [\"./src/extend.js\", \"*.css\"]\n}\n```\n\n这样 Webpack 的 sideEffects 就不会忽略确实有必要的副作用模块了。\n\n### 写在最后\n\n最后我们来总结一下，今天介绍到了两个 Webpack 中的高级特性，分别是 Tree-shaking 和 sideEffects。\n\nTree-shaking 的本身没有太多需要你理解和思考的地方，你只需要了解它的效果，以及相关的配置即可。\n\n而 sideEffects 可能需要你花点时间去理解一下，重点就是想明白哪些副作用代码是可以随着模块的移除而移除，哪些又是不可以移除的。总结下来其实也很简单：对全局有影响的副作用代码不能移除，而只是对模块有影响的副作用代码就可以移除。\n\n总之不管是 Tree-shaking 还是 sideEffects，我个人认为，它们都是为了弥补 JavaScript 早期在模块系统设计上的不足。随着 Webpack 这类技术的发展，JavaScript 的模块化确实越来越好用，也越来越合理。\n\n除此之外，我还想强调一点，当你对这些特性有了一定的了解之后，就应该意识到：**尽可能不要写影响全局的副作用代码**。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n\n> Photo by [Jonathan Cosens Photography](https://unsplash.com/@jcosens) on [Unsplash](https://unsplash.com)\n","cover":"https://cdn.zce.me/assets/f3d988b8a991a2dd.jpg","audio":"https://cdn.zce.me/audio/2020/04/webpack-09.mp3"},{"title":"如何让你的模块支持热替换（HMR）机制？","slug":"webpack-hot-module-replacement","date":1587752871000,"updated":1673100032189,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","HMR"],"meta":{},"content":"\n你好，我是汪磊，在[之前的文章](/2020/04/webpack-dev-server-improve-your-local-dev-efficiency/)中我们已经简单了解了 Webpack Dev Server 的一些基本用法和特性，它为我们使用 Webpack 构建的项目提供了一个比较友好的开发环境和一个用于调试的开发服务器。\n\n使用 Webpack Dev Server 就可以让我们在开发过程中专注编码，因为它可以自动监视我们代码的变化，然后自动进行打包，最后通过自动刷新的方式同步到浏览器，以便于我们即时预览，效果如下：\n\n<video src=https://cdn.zce.me/assets/2d62ea703c991cb6.mp4 muted autoplay playsinline loop></video>\n\n### 自动刷新的问题\n\n但是当你实际去使用 Webpack Dev Server 自动刷新的特性去完成具体的开发任务时，你会发现还是有一些不舒服的地方。\n\n例如，这里是一个编辑器应用，我想要即时调试这个编辑器中内容文本的样式。那正常的操作肯定是我先尝试在编辑器里面去添加一些文本，作为展示样例，再回到开发工具中，找到控制编辑器样式的 CSS 文件，然后进行编辑，具体操作如下：\n\n<video src=https://cdn.zce.me/assets/31ad463bbafbce89.mp4 muted autoplay playsinline loop></video>\n\n那这时候我们就能够发现问题了：当我们修改完编辑器文本对应的样式过后，原本想着可以即时看到最新的界面效果，但是这时编辑器中的内容却没有了。\n\n这时就不得不再次回到应用中再来添加一些测试文本，查看样式效果。那如果修改后还是对样式不满意的话，你还需要继续调整样式，调整之后又会面临文本内容丢失的问题。那久而久之你就会发现，自动刷新这个功能还是有点鸡肋，并没有想象的那么好用。\n\n出现这个问题的原因，是因为我们每次修改完代码，Webpack 都可以监视到变化，然后自动打包，再通知浏览器自动刷新，一旦页面整体刷新，那页面中的任何操作状态都将会丢失，所以才会出现我们上面所看到的情况。\n\n但是聪明的你总会想到一些应对方法，例如：\n\n- 回到代码中先写死一个文本内容到编辑器中，这样即便页面刷新，也不会丢失。\n- 通过代码将编辑器中的内容及时保存到 LocalStorage 之类的地方，刷新过后再取回来。\n\n总之就是：_你有问题，我有办法_。\n\n确实这些都是好办法，但是也存在一些不足，因为它们都是典型的“有漏补漏”的操作，并不能根治自动刷新导致页面状态丢失问题，而且这些方法都需要去编写一些与业务本身无关的辅助代码，不利于维护。\n\n更好的办法自然是能够实现在页面不刷新的情况下，代码也可以及时的更新到浏览器的页面中，重新执行，避免页面状态丢失。针对这个需求，Webpack 同样可以满足。\n\n### 模块热替换（HMR）\n\nHMR 全称 Hot Module Replacement，翻译过来叫作“模块热替换”或“模块热更新”。\n\n计算机行业经常听到一个叫作热拔插的名词，指的就是我们可以在一个正在运行的机器上随时插拔设备，机器的运行状态不会受插拔的影响，而且插上去的设备可以立即工作，例如我们电脑上的 USB 端口就可以热拔插。\n\n模块热替换中的“热”和这里提到的“热拔插”是相同的意思，都是指在运行过程中的即时变化。\n\nWebpack 中的模块热替换，指的是我们可以在应用运行过程中，实时的去替换掉应用中的某个模块，而应用的运行状态不会因此而改变。例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失；而如果使用的是 HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用。\n\n这里我们可以先来对比一下使用热更新和使用自动刷新两种方式之间的体验差异，我们尝试在项目中开启 HMR 特性，具体效果如下图所示：\n\n<video src=https://cdn.zce.me/assets/e789889e573e827f.mp4 muted autoplay playsinline loop></video>\n\n有了 HMR 支持后，我们同样先在页面中随意添加一些内容，也就是为页面制造一些运行状态，然后我们回到开发工具中，再来尝试修改文本的样式，保存过后页面并没有整体刷新，而且我们能立即看到最新的样式。这种体验相对于自动刷新会友好很多。\n\nHMR 对于项目中其他代码文件的修改，也可以有相同的热更新体验。你可以再去尝试修改一下 JS 文件，保存过后，浏览器中同样不会刷新页面，而是直接执行了你刚刚修改的这个模块，具体效果如下：\n\n<video src=https://cdn.zce.me/assets/12f604e09ae83416.mp4 muted autoplay playsinline loop></video>\n\n不仅如此，对于非文本文件同样也可以使用热更新。例如这个案例中显示的 Logo 图片，如果你在外部修改了它，同样也可以及时更新到浏览器中。\n\n那这就是 HMR 的作用和体验，HMR 可以算是 Webpack 中最为强大的特性之一，而且也是最受欢迎的特性，因为它确实极大程度地提高了开发者的工作效率。\n\n#### 开启 HMR\n\n对于 HMR 这种强大的功能而言，使用起来并不算特别复杂。接下来我们就一起了解一下如何去实现项目中的 HMR。\n\nHMR 已经集成在了 webpack 模块中了，所以不需要再单独安装什么模块。\n\n使用这个特性最简单的方式就是，在运行 webpack-dev-server 命令时，通过 `--hot` 参数去开启这个特性。\n\n或者也可以在配置文件中通过添加对应的配置来开启这个功能。那我们这里打开配置文件，这里需要配置两个地方：\n\n- 首先需要将 devServer 对象中的 `hot` 属性设置为 `true；`\n- 然后需要载入一个插件，这个插件是 webpack 内置的一个插件，所以我们先导入 webpack 模块，有了这个模块过后，这里使用的是一个叫作 HotModuleReplacementPlugin 的插件。\n\n具体配置代码如下：\n\n```javascript\n// ./webpack.config.js\nconst webpack = require('webpack')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // ...\n  devServer: {\n    // 开启 HMR 特性，如果资源不支持 HMR 会 fallback 到 live reloading\n    hot: true\n    // 只使用 HMR，不会 fallback 到 live reloading\n    // hotOnly: true\n  },\n  plugins: [\n    // ...其他插件\n    // HMR 特性所需要的插件\n    new webpack.HotModuleReplacementPlugin()\n  ]\n}\n```\n\n配置完成以后，我们打开命令行终端，运行 webpack-dev-server，启动开发服务器。那接下来你就可以来体验 HMR 了。\n\n我们回到开发工具中，这里我们先来尝试修改一下 CSS 文件。样式文件修改保存过后，确实能够以不刷新的形式更新到页面中。\n\n然后我们再来尝试一下修改 JS 文件。保存过后你会发现，这里的页面依然自动刷新了，好像并没有之前所说 HMR 的体验。\n\n为了再次确认，你可以尝试先在页面中的编辑器里随意添加一些文字，然后修改代码，保存过后你就会看到页面自动刷新，页面中的状态也就丢失了，具体效果如下图：\n\n<video src=https://cdn.zce.me/assets/169a12c68563ef15.mp4 muted autoplay playsinline loop></video>\n\n那这是为什么呢？为什么 CSS 文件热替换没出现问题，而到了 JS 这块就不行了呢？我们又该如何去实现其他类型模块的热替换呢？\n\n#### HMR 的疑问\n\n通过之前的体验我们发现模块热替换确实提供了非常友好的体验，但是当我们自己去尝试开启 HMR 过后，效果却不尽如人意。\n\n很明显：HMR 并不像 Webpack 的其他特性一样可以开箱即用，需要有一些额外的操作。\n\n具体来说，Webpack 中的 HMR 需要我们手动通过代码去处理，当模块更新过后该，如何把更新后的模块替换到页面中。\n\n**Q1**：可能你会问，为什么我们开启 HMR 过后，样式文件的修改就可以直接热更新呢？我们好像也没有手动处理样式模块的更新啊？\n\n**A1**：这是因为样式文件是经过 Loader 处理的，在 style-loader 中就已经自动处理了样式文件的热更新，所以就不需要我们额外手动去处理了。\n\n**Q2**：你可能会想，凭什么样式就可以自动处理，而我们的脚本就需要自己手动处理呢？\n\n**A2**：这个原因也很简单，因为样式模块更新过后，只需要把更新后的 CSS 及时替换到页面中，它就可以覆盖掉之前的样式，从而实现更新。\n\n而我们所编写的 JavaScript 模块是没有任何规律的，你可能导出的是一个对象，也可能导出的是一个字符串，还可能导出的是一个函数，使用时也各不相同。所以 Webpack 面对这些毫无规律的 JS 模块，根本不知道该怎么处理更新后的模块，也就无法直接实现一个可以通用所有情况的模块替换方案。\n\n那这就是为什么样式文件可以直接热更新，而 JS 文件更新后页面还是回退到自动刷新的原因。\n\n**Q3**：那可能还有一些平时使用 vue-cli 或者 create-react-app 这种框架脚手架工具的人会说，“我的项目就没有手动处理，JavaScript 代码照样可以热替换，也没你说的那么麻烦”。\n\n**A3**：这是因为你使用的是框架，使用框架开发时，我们项目中的每个文件就有了规律，例如 React 中要求每个模块导出的必须是一个函数或者类，那这样就可以有通用的替换办法，所以这些工具内部都已经帮你实现了通用的替换操作，自然就不需要手动处理了。\n\n当然如果你之前没有接触过这样的工具，也可以忽略这一条，这也并不影响后面的理解。\n\n综上所述，我们还是需要自己手动通过代码来处理，当 JavaScript 模块更新过后，该如何将更新后的模块替换到页面中。\n\n#### HMR APIs\n\n`HotModuleReplacementPlugin` 为我们的 JavaScript 提供了一套用于处理 HMR 的 API，我们需要在我们自己的代码中，使用这套 API 将更新后的模块替换到正在运行的页面中。\n\n接下来我们回到代码中，尝试通过 HMR 的 API 手动处理模块更新后的热替换。\n\n这里我们打开 main.js，具体代码如下：\n\n```javascript\n// ./src/main.js\nimport createEditor from './editor'\nimport logo from './icon.png'\nimport './global.css'\nconst img = new Image()\nimg.src = logo\ndocument.body.appendChild(img)\nconst editor = createEditor()\ndocument.body.appendChild(editor)\n```\n\n这是 Webpack 打包的入口文件，正常情况下，在这个文件中会加载一些其他模块。正是因为在 main.js 中使用了这些模块，所以一旦这些模块更新了过后，我们在 main.js 中就必须重新使用更新后的模块。\n\n所以说，我们需要在这个文件中添加一些额外的代码，去处理它所依赖的这些模块更新后的热替换逻辑。\n\n对于开启 HMR 特性的环境中，我们可以访问到全局的 `module` 对象中的 `hot` 成员，这个成员是一个对象，这个对象就是 HMR API 的核心对象，它提供了一个 `accept` 方法，用于注册当某个模块更新后的处理函数。`accept` 方法第一个参数接收的就是所监视的依赖模块路径，第二个参数就是依赖模块更新后的处理函数。\n\n那我们这里先尝试注册 ./editor 模块更新过后的处理函数，第一个参数就是 editor 模块的路径，第二个参数则需要我们传入一个函数，然后在这个函数中打印一个消息，具体代码如下：\n\n```javascript\n// ./main.js\n// ... 原本的业务代码\nmodule.hot.accept('./editor', () => {\n  // 当 ./editor.js 更新，自动执行此函数\n  console.log('editor 更新了～～')\n})\n```\n\n完成过后，我们打开命令行终端再次启动 webpack-dev-server 命令，然后回到浏览器，打开开发人员工具。\n\n此时，如果我们修改了 editor 模块，保存过后，浏览器的控制台中就会自动打印我们上面在代码中添加的消息，而且浏览器也不会自动刷新了。\n\n那也就是说一旦这个模块的更新被我们手动处理了，就不会触发自动刷新；反之，如果没有手动处理，热替换会自动 fallback（回退）到自动刷新。\n\n#### JS 模块热替换\n\n了解了这个 HMR API 的作用过后，接下来需要考虑的就是：具体如何实现 editor 模块的热替换。\n\n这个模块导出的是一个 `createEditor` 函数，我们先正常把它打印到控制台，然后在模块更新后的处理函数中再打印一次，具体代码如下：\n\n```javascript\n// ./main.js\nimport createEditor from './editor'\n// ... 原本的业务代码\nconsole.log(createEditor)\nmodule.hot.accept('./editor', () => {\n  console.log(createEditor)\n})\n```\n\n这个时候如果你再次修改 editor 模块，保存过后，你就会发现当模块更新后，我们这里拿到的 `createEditor` 函数也就更新为了最新的结果，具体结果如下图所示：\n\n![createEditor 的更新](https://cdn.zce.me/assets/e8dff91007de8fba.png)\n\n既然模块文件更新后 `createEditor` 函数可以自动更新，那剩下的就好办了。我们这里使用 `createEditor` 函数是用来创建一个界面元素的，那模块一旦更新了，这个元素也就需要重新创建，所以我们这里先移除原来的元素，然后再调用更新后的 `createEditor` 函数，创建一个新的元素追加到页面中，具体代码如下：\n\n```javascript\n// ./main.js\nimport createEditor from './editor'\nconst editor = createEditor()\ndocument.body.appendChild(editor)\n// ... 原本的业务代码\n// HMR -----------------------------------\nmodule.hot.accept('./editor', () => {\n  document.body.removeChild(editor) // 移除之前创建的元素\n  const newEditor = createEditor() // 用新模块创建新元素\n  document.body.appendChild(newEditor)\n})\n```\n\n但如果只是这样实现的话，一次热替换结束后，第二次就没法再实现热替换了。因为第二次执行这个函数的时候，editor 变量指向的元素已经在上一次执行时被移除了，所以我们这里还应该记录下来每次热替换创建的新元素，以便于下一次热替换时的操作，具体代码如下：\n\n```javascript\n// ./main.js\nimport createEditor from './editor'\nconst editor = createEditor()\ndocument.body.appendChild(editor)\n// ... 原本的业务代码\n// HMR -----------------------------------\nlet lastEditor = editor\nmodule.hot.accept('./editor', () => {\n  document.body.removeChild(lastEditor) // 移除之前创建的元素\n  lastEditor = createEditor() // 用新模块创建新元素\n  document.body.appendChild(lastEditor)\n})\n```\n\n完成以后，我们再来尝试修改 editor 模块，此时就应该是正常的热替换效果了，具体效果如下图：\n\n<video src=https://cdn.zce.me/assets/1bcbae912ef2fd6b.mp4 muted autoplay playsinline loop></video>\n\n#### 热替换的状态保持\n\n此时，如果我们尝试在界面上输入一些内容（形成页面操作状态），然后回到代码中再次修改 editor 模块。那此时你仍然会发现问题，由于热替换时，把界面上之前的编辑器元素移除了，替换成了一个新的元素，所以页面上之前的状态同样会丢失。\n\n这也就证明我们的热替换操作还需要改进，我们必须在替换时把状态保留下来。\n\n我们回到 main.js 中，要想保留这个状态也很简单，就是在替换前先拿到编辑器中的内容，然后替换后在放回去就行了。那因为我这里使用的是可编辑元素，而不是文本框，所以我们需要通过 `innerHTML` 拿到之前编辑的内容，然后设置到更新后创建的新元素中，具体代码如下：\n\n```javascript\n// ./main.js\nimport createEditor from './editor'\nconst editor = createEditor()\ndocument.body.appendChild(editor)\n// ... 原本的业务代码\n// HMR --------------------------------\nlet lastEditor = editor\nmodule.hot.accept('./editor', () => {\n  // 当 editor.js 更新，自动执行此函数\n  // 临时记录更新前编辑器内容\n  const value = lastEditor.innerHTML\n  // 移除更新前的元素\n  document.body.removeChild(lastEditor)\n  // 创建新的编辑器\n  // 此时 createEditor 已经是更新过后的函数了\n  lastEditor = createEditor()\n  // 还原编辑器内容\n  lastEditor.innerHTML = value\n  // 追加到页面\n  document.body.appendChild(lastEditor)\n})\n```\n\n这样就可以解决界面状态保存的问题了。\n\n至此，对于 editor 模块的热替换逻辑就算是全部实现了。通过这个过程你应该能够发现，为什么 Webpack 需要我们自己处理 JS 模块的热更新了：因为不同的模块有不同的情况，不同的情况，在这里处理时肯定也是不同的。就好像，我们这里是一个文本编辑器应用，所以需要保留状态，如果不是这种类型那就不需要这样做。所以说 Webpack 没法提供一个通用的 JS 模块替换方案。\n\n#### 图片模块热替换\n\n相比于 JavaScript 模块热替换，图片的热替换逻辑就简单多了，这里我们快速来看一下。\n\n我们同样通过 `module.hot.accept` 注册这个图片模块的热替换处理函数，在这个函数中，我们只需要重新给图片元素的 src 设置更新后的图片路径就可以了。因为图片修改过后图片的文件名会发生变化，而这里我们就可以直接得到更新后的路径，所以重新设置图片的 src 就能实现图片热替换，具体代码如下：\n\n```javascript\n// ./src/main.js\nimport logo from './icon.png'\n// ... 其他代码\nmodule.hot.accept('./icon.png', () => {\n  // 当 icon.png 更新后执行\n  // 重写设置 src 会触发图片元素重新加载，从而局部更新图片\n  img.src = logo\n})\n```\n\n#### 常见问题\n\n如果你刚开始使用 Webpack 的 HMR 特性，肯定会遇到一些问题，接下来我分享几个最容易发生的问题。\n\n第一个问题，如果处理热替换的代码（处理函数）中有错误，结果也会导致自动刷新。例如我们这里在处理函数中故意加入一个运行时错误，代码如下：\n\n```javascript\n// ./src/main.js\n// ... 其他代码\nmodule.hot.accept('./editor', () => {\n  // 刻意造成运行异常\n  undefined.foo()\n})\n```\n\n直接测试你会发现 HMR 不会正常工作，而且根本看不到异常，效果如下图：\n\n<video src=https://cdn.zce.me/assets/1e65fd46dfc1bd91.mp4 muted autoplay playsinline loop></video>\n\n这是因为 HMR 过程报错导致 HMR 失败，HMR 失败过后，会自动回退到自动刷新，页面一旦自动刷新，控制台中的错误信息就会被清除，这样的话，如果不是很明显的错误，就很难被发现。\n\n在这种情况下，我们可以使用 hotOnly 的方式来解决，因为现在使用的 hot 方式，如果热替换失败就会自动回退使用自动刷新，而 hotOnly 的情况下并不会使用自动刷新。\n\n我们回到配置文件中，这里我们将 devServer 中的 `hot: true` 修改为 `hotOnly: true`，具体代码如下：\n\n```javascript\n// ./webpack.config.js\nconst webpack = require('webpack')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // ...\n  devServer: {\n    // 只使用 HMR，不会 fallback 到 live reloading\n    hotOnly: true\n  },\n  plugins: [\n    // ...\n    // HMR 特性所需要的插件\n    new webpack.HotModuleReplacementPlugin()\n  ]\n}\n```\n\n配置完成以后，重新启动 webpack-dev-server。此时我们再去修改代码，无论是否处理了这个代码模块的热替换逻辑，浏览器都不会自动刷新了，这样的话，热替换逻辑中的错误信息就可以直接看到了，具体效果如下图：\n\n![HMR Error 信息呈现](https://cdn.zce.me/assets/ee9a3d054e884be0.png)\n\n第二个问题，对于使用了 HMR API 的代码，如果我们在没有开启 HMR 功能的情况下运行 Webpack 打包，此时运行环境中就会报出 _Cannot read property 'accept' of undefined_ 的错误，具体错误信息如下：\n\n![没有开启 HMR 功能](https://cdn.zce.me/assets/9b06215b588fb9fd.png)\n\n原因是 `module.hot` 是 HMR 插件提供的成员，没有开启这个插件，自然也就没有这个对象。\n\n解决办法也很简单，与我们在业务代码中判断 API 兼容一样，我们先判断是否存在这个对象，然后再去使用就可以了，具体代码如下：\n\n```javascript\n// HMR -----------------------------------\nif (module.hot) {\n  // 确保有 HMR API 对象\n  module.hot.accept('./editor', () => {\n    // ...\n  })\n}\n```\n\n除此之外，可能你还有一个问题：我们在代码中写了很多与业务功能本身无关的代码，会不会对生产环境有影响？\n\n那这个问题的答案很简单，我通过一个简单的操作来帮你解答，我们回到配置文件中，确保已经将热替换特性关闭，并且移除掉了 HotModuleReplacementPlugin 插件，然后打开命令行终端，正常运行一下 Webpack 打包，打包过后，我们找到打包生成的 bundle.js 文件，然后找到里面 main.js 对应的模块，具体结果如下图：\n\n![生产环境下的 build 结果](https://cdn.zce.me/assets/0ed02dc9e2e3b0f0.png)\n\n你会发现之前我们编写的处理热替换的代码都被移除掉了，只剩下一个 `if (false) {}` 的空判断，这种没有意义的判断，在压缩过后也会自动去掉，所以根本不会对生产环境有任何影响。\n\n### 写在最后\n\n以上就是我们对 Webpack 模块热替换特性做的一些探索，整体下来可能你会觉得 HMR 比较麻烦，需要写一些额外的代码，甚至觉得不如不用。\n\n我个人的看法是利大于弊，这个道理就像是为什么现在的开发者都愿意写单元测试一样，对于长期开发的项目而言，这点额外的工作不算什么，而且如果你能为自己的代码设计出一些规律，那你也可以实现一个通用替换方案。\n\n当然，如果你是使用 React 或者 Vue.js 这类的框架开发，那么使用 HMR 功能会更加简单，因为大部分框架都有成熟的 HMR 方案，你只需要使用就可以了。但是如果你是使用纯原生 JavaScript 开发，那 HMR 功能使用起来相对就会麻烦一点。这也正是为什么大部分人都喜欢选择集成式框架的原因。\n\n关于框架的 HMR，因为在大多数情况下是开箱即用的，所以这里不做过多介绍，详细可以参考：\n\n- [React HMR 方案](https://github.com/gaearon/react-hot-loader)；\n- [Vue.js HMR 方案](https://vue-loader.vuejs.org/guide/hot-reload.html)。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n","cover":"https://cdn.zce.me/assets/3076f9a5b5525c59.jpg","audio":"https://cdn.zce.me/audio/2020/04/webpack-08.mp3"},{"title":"如何配置 Webpack SourceMap 的最佳实践？","slug":"best-practices-of-webpack-sourcemap","date":1587666471000,"updated":1673100032149,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","SourceMap"],"meta":{},"content":"\n你好，我是汪磊，上一期我们介绍了[如何使用 Webpack Dev Server 提高开发效率](/2020/04/webpack-dev-server-improve-your-local-dev-efficiency/)，今天我们来介绍需要编译的前端项目该如何调试。\n\n通过构建或者编译之类的操作，我们将开发阶段编写的源代码转换为能够在生产环境中运行的代码，这种进步同时也意味着我们实际运行的代码和我们真正编写的代码之间存在很大的差异。\n\n在这种情况下，如果需要调试我们的应用，或是应用运行的过程中出现意料之外的错误，那我们将无从下手。因为无论是调试还是报错，都是基于构建后的代码进行的，我们只能看到错误信息在构建后代码中具体的位置，却很难直接定位到源代码中对应的位置。\n\n所以我们今天来聊聊如何借助工具解决现代化前端应用的调试问题。\n\n### Source Map 简介\n\nSource Map（源代码地图）就是解决此类问题最好的办法，从它的名字就能够看出它的作用：映射转换后的代码与源代码之间的关系。一段转换后的代码，通过转换过程中生成的 Source Map 文件就可以逆向解析得到对应的源代码。\n\n![源代码与编译转换后代码之间的映射](https://cdn.zce.me/assets/2d455d7f1ac9bd3d.png)\n\n目前很多第三方库在发布的文件中都会同时提供一个 .map 后缀的 Source Map 文件。例如 jQuery。我们可以打开它的 Source Map 文件看一下，如下图所示：\n\n![jQuery 的 Source Map](https://cdn.zce.me/assets/52776012285a10bb.png)\n\n这是一个 JSON 格式的文件，为了更容易阅读，我提前对该文件进行了格式化。这个 JSON 里面记录的就是转换后和转换前代码之间的映射关系，主要存在以下几个属性：\n\n- `version` 是指定所使用的 Source Map 标准版本；\n- `sources` 中记录的是转换前的源文件名称，因为有可能出现多个文件打包转换为一个文件的情况，所以这里是一个数组；\n- `names` 是源代码中使用的一些成员名称，我们都知道一般压缩代码时会将我们开发阶段编写的有意义的变量名替换为一些简短的字符，这个属性中记录的就是原始的名称；\n- `mappings` 属性，这个属性最为关键，它是一个叫作 _base64-VLQ_ 编码的字符串，里面记录的信息就是转换后代码中的字符与转换前代码中的字符之间的映射关系，具体如下图所示：\n\n![jQuery Source Map 的 Mappings](https://cdn.zce.me/assets/70c1e586e14a57a0.png)\n\n一般我们会在转换后的代码中通过添加一行注释的方式来去引入 Source Map 文件。不过这个特性只是用于开发调试的，所以最新版本的 jQuery 已经去除了引入 Source Map 的注释，我们需要手动添加回来，这里我们在最后一行添加 `//# sourceMappingURL=jquery-3.4.1.min.map`，具体效果如下：\n\n![引入 jQuery 的 Source Map 文件](https://cdn.zce.me/assets/2dc9f7033206c188.png)\n\n这样我们在 Chrome 浏览器中如果打开了开发人员工具，它就会自动请求这个文件，然后根据这个文件的内容逆向解析出来源代码，以便于调试。同时因为有了映射关系，所以代码中如果出现了错误，也就能自动定位找到源代码中的位置了。\n\n我们回到浏览器中，打开开发人员工具，找到 Source 面板，这里我们就能看到转换前的 jQuery 源代码了，具体效果如下图所示：\n\n![根据 Source Map 解析出来的源代码](https://cdn.zce.me/assets/a10963d5465ccc1f.png)\n\n我们还可以添加一个断点，然后刷新页面，进行单步调试，此时调试过程中使用的就是源代码而不是压缩过后的代码，具体效果如下图所示：\n\n![Source Map 的效果](https://cdn.zce.me/assets/483d4eccd810b2cd.png)\n\n### Webpack 中配置 Source Map\n\n我们使用 Webpack 打包的过程，同样支持为打包结果生成对应的 Source Map。用法上也很简单，不过它提供了很多不同模式，导致大部分初学者操作起来可能会比较懵。那接下来我们就一起研究一下在 Webpack 中如何开启 Source Map，然后再来了解一下几种不同的 Source Map 模式之间存在哪些差异。\n\n我们回到配置文件中，这里我们要使用的配置属性叫作 `devtool`。这个属性就是用来配置开发过程中的辅助工具，也就是与 Source Map 相关的一些功能。我们可以先将这个属性设置为 `source-map`，具体代码如下：\n\n```javascript\n// ./webpack.config.js\nmodule.exports = {\n  devtool: 'source-map' // source map 设置\n}\n```\n\n然后打开命令行终端，运行 Webpack 打包。打包完成过后，我们打开 dist 目录，此时这个目录中就会生成我们 bundle.js 的 Source Map 文件，与此同时 bundle.js 中也会通过注释引入这个 Source Map 文件，具体如下图所示：\n\n![Webpack 输出 Source Map 文件](https://cdn.zce.me/assets/4f76c14c6c8c7872.png)\n\n我们再回到命令行，通过 [serve](http://github.com/vercel/serve) 工具把打包结果运行起来，然后打开浏览器，再打开开发人员工具，此时我们就可以直接定位到错误所在的位置了。当然如果需要调试，这里也可以直接调试源代码。\n\n<video src=https://cdn.zce.me/assets/042fe91796095a96.mp4 muted autoplay playsinline loop></video>\n\n如果你只是需要使用 Source Map 的话，操作到这里就已经实现了。但是只会使用这种最普通的 Source Map 模式还远远不够。\n\n为什么这么说呢？\n\n因为现阶段 Webpack 支持的 Source Map 模式有很多种。每种模式下所生成的 Source Map 效果和生成速度都不一样。显然，效果好的一般生成速度会比较慢，而生成速度快的一般就没有什么效果。\n\n那具体哪种 Source Map 模式才是最好呢？这里我们还需要继续去探索。\n\nWebpack 中的 `devtool` 配置，除了可以使用 `source-map` 这个值，它还支持很多其他的选项，具体的我们可以参考[文档](https://webpack.js.org/configuration/devtool/#devtool)中的不同模式的对比表。\n\n| **devtool 取值** | **初次构建** | **重新构建** | **适合生产环境** | **品质** |\n| :-- | :-- | :-- | :-- | :-- |\n| (none) | 最快 | 最快 | 是 | 无 |\n| eval | 最快 | 最快 | 否 | 转换后代码 |\n| cheap-eval-source-map | 快 | 更快 | 否 | 转换后代码（只有行信息） |\n| cheap-module-eval-source-map | 慢 | 更快 | 否 | 源代码（只有行信息） |\n| eval-source-map | 最慢 | 慢 | 否 | 完整源代码 |\n| cheap-source-map | 快 | 慢 | 是 | 转换后代码（只有行信息） |\n| cheap-module-source-map | 慢 | 更慢 | 是 | 源代码（只有行信息） |\n| inline-cheap-source-map | 快 | 慢 | 否 | 转换后代码（只有行信息） |\n| inline-cheap-module-source-map | 慢 | 更慢 | 否 | 源代码（只有行信息） |\n| source-map | 最慢 | 最慢 | 是 | 完整源代码 |\n| inline-source-map | 最慢 | 最慢 | 否 | 完整源代码 |\n| hidden-source-map | 最慢 | 最慢 | 是 | 完整源代码 |\n| nosources-source-map | 最慢 | 最慢 | 是 | 无源码内容，只有行列信息 |\n\n上表分别从初次构建速度、监视模式重新构建速度、是否适合生成环境使用，以及 Source Map 的质量，这四个维度去横向对比了不同的 Source Map 模式之间的差异。\n\n通过表格中四个维度的对比你可能觉得不够清晰，也不太好理解，所以接下来我们会根据表格中的介绍，通过实际操作来体会这些模式之间的差异，从而带你找到适合自己的最佳实践。\n\n#### Eval 模式\n\n首先来看 eval 模式。在去具体了解 Webpack eval 模式的 Source Map 之前，我们需要先了解一下 JavaScript 中 `eval` 的一些特点。\n\n`eval` 其实指的是 JavaScript 中的一个函数，可以用来运行字符串中的 JavaScript 代码。例如下面这段代码，字符串中的 `console.log(\"foo~\")` 就会作为一段 JavaScript 代码被执行：\n\n```javascript\nconst code = 'console.log(\"foo~\")'\neval(code) // 将 code 中的字符串作为 JS 代码执行\n```\n\n在默认情况下，这段代码运行在一个临时的虚拟机环境中，我们在控制台中就能够看到：\n\n![JavaScript 中的 eval 函数](https://cdn.zce.me/assets/6cc4e2dfa17b3ad6.png)\n\n其实我们可以通过 `sourceURL` 来声明这段代码所属文件路径，接下来我们再来尝试在执行的 JavaScript 字符串中添加一个 `sourceURL` 的声明，具体操作如下：\n\n![eval 函数的 sourceURL](https://cdn.zce.me/assets/2cda6cf1d484441b.png)\n\n具体就是在 `eval` 函数执行的字符串代码中添加一个注释，注释的格式：`# sourceURL=./path/to/file.js`，这样的话这段代码就会执行在指定路径下。\n\n在了解了 `eval` 函数可以通过 `sourceURL` 指定代码所属文件路径这个特点过后，我们再来尝试使用这个叫作 eval 模式的 Source Map。\n\n我们回到 Webpack 的配置文件中，将 `devtool` 属性设置为 `eval`，具体如下：\n\n```javascript\n// ./webpack.config.js\nmodule.exports = {\n  devtool: 'eval'\n}\n```\n\n然后我们回到命令行终端再次运行打包，打包过后，找到生成的 bundle.js 文件，你会发现每个模块中的代码都被包裹到了一个 `eval` 函数中，而且每段模块代码的最后都会通过 sourceURL 的方式声明这个模块对应的源文件路径，具体如下：\n\n![eval 模式 Source Map](webpack-https://cdn.zce.me/assets/73af8f2e0e1992a9.png)\n\n那此时如果我们回到浏览器运行这里的 bundle.js，一旦出现错误，浏览器的控制台就可以定位到具体是哪个模块中的代码，具体效果如下：\n\n![eval 模式下的效果](https://cdn.zce.me/assets/540babc11b5baac5.png)\n\n但是当你点击控制台中的文件名打开这个文件后，看到的却是打包后的模块代码，而并非我们真正的源代码，具体如下：\n\n![eval 模式映射出的源代码](https://cdn.zce.me/assets/a5462d988ba704c6.png)\n\n综上所述，在 eval 模式下，Webpack 会将每个模块转换后的代码都放到 `eval` 函数中执行，并且通过 sourceURL 声明对应的文件路径，这样浏览器就能知道某一行代码到底是在源代码的哪个文件中。\n\n因为在 eval 模式下并不会生成 Source Map 文件，所以它的构建速度最快，但是缺点同样明显：它只能定位源代码的文件路径，无法知道具体的行列信息。\n\n#### 案例准备工作\n\n为了可以更好地对比不同模式的 Source Map 之间的差异，这里我们使用一个新项目，同时创建出不同模式下的打包结果，通过具体实验来横向对比它们之间的差异。\n\n在这个案例中，项目中只有两个 JS 模块，在 main.js 中，我故意加入了一个运行时错误，具体项目结构和部分代码如下：\n\n```diff\n└─ 07-devtool-diff\n   ├── src\n   │   ├── heading.js\n   │   └── main.js\n   ├── package.json\n   └── webpack.config.js\n```\n\n```javascript\n// ./src/main.js\nimport createHeading from './heading.js'\nconst heading = createHeading()\ndocument.body.append(heading)\nconsole.log('main.js running')\n// 运行时错误\nconsole.log111('main.js running')\n```\n\n然后我们打开 Webpack 的配置文件，在这个文件中定义一个数组，数组中每一个成员都是 `devtool` 配置取值的一种，具体代码如下：\n\n```javascript\nconst allDevtoolModes = [\n  'eval',\n  'cheap-eval-source-map',\n  'cheap-module-eval-source-map',\n  'eval-source-map',\n  'cheap-source-map',\n  'cheap-module-source-map',\n  'inline-cheap-source-map',\n  'inline-cheap-module-source-map',\n  'source-map',\n  'inline-source-map',\n  'hidden-source-map',\n  'nosources-source-map'\n]\n```\n\nWebpack 的配置文件除了可以导出一个配置对象，还可以导出一个数组，数组中每一个元素就是一个单独的打包配置，那这样就可以在一次打包过程中同时执行多个打包任务。\n\n例如，我们这里导出一个数组，然后在这个数组中添加两个打包配置，它们的 `entry` 都是 `./src/main.js`，不过它们输出的文件名不同，具体代码如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = [\n  {\n    entry: './src/main.js',\n    output: {\n      filename: 'output1.js'\n    }\n  },\n  {\n    entry: './src/main.js',\n    output: {\n      filename: 'output2.js'\n    }\n  }\n]\n```\n\n这么配置的话，再次打包就会有两个打包子任务工作，我们的 dist 中生成的结果也就是两个文件，具体结果如下：\n\n![多任务打包输出](https://cdn.zce.me/assets/e1ac5b23d5b2296b.png)\n\n了解了 Webpack 这种配置用法过后，我们再次回到配置文件中，遍历刚刚定义的数组，为每一个模式单独创建一个打包配置，这样就可以一次性生成所有模式下的不同结果，这比我们一个一个去试验的效率更高，而且对比起来也更明显。\n\n具体配置代码如下：\n\n```javascript\n// ./webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nconst allModes = [\n  'eval',\n  'cheap-eval-source-map',\n  'cheap-module-eval-source-map',\n  'eval-source-map',\n  'cheap-source-map',\n  'cheap-module-source-map',\n  'inline-cheap-source-map',\n  'inline-cheap-module-source-map',\n  'source-map',\n  'inline-source-map',\n  'hidden-source-map',\n  'nosources-source-map'\n]\n\nmodule.exports = allModes.map(item => ({\n  devtool: item,\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: `js/${item}.js`\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env']\n          }\n        }\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: `${item}.html`\n    })\n  ]\n}))\n```\n\n这里简单解释一下这个配置中的部分配置用意：\n\n1. 定义 `devtool` 属性，它就是当前所遍历的模式名称；\n2. 将 `mode` 设置为 `none`，确保 Webpack 内部不做额外处理；\n3. 设置打包入口和输出文件名称，打包入口都是 `./src/main.js`，输出文件名称我们就放在 js 目录中，以模式名称命名，至于为什么放在单独目录中，你可以在接下来的内容中找到答案；\n4. 为 js 文件配置一个 babel-loader，配置 babel-loader 的目的是稍后能够辨别其中一类模式的差异。\n5. 配置一个 html-webpack-plugin，也就是为每个打包任务生成一个 HTML 文件，通过前面的内容，我们知道 html-webpack-plugin 可以生成使用打包结果的 HTML，接下来我们就是通过这些 HTML 在浏览器中进行尝试。\n\n配置完成以后，我们再次回到命令行终端运行打包，那此时这个打包过程就自动生成了不同模式下的打包结果，具体结果如下图所示：\n\n![不同模式下的打包结果](https://cdn.zce.me/assets/071f2ac7d9c762b4.png)\n\n然后我们通过 serve 把结果运行起来，打开浏览器，此时我们能够在页面中看到每一个使用不同模式 Source Map 的 HTML 文件，具体如下图：\n\n![不同模式下的打包结果入口](https://cdn.zce.me/assets/6efe58004bc8f3ac.png)\n\n那如果刚刚没有把 JS 文件输出到单独目录中，这里的文件就会非常多，导致 HTML 文件寻找起来特别麻烦。\n\n#### 不同模式的对比\n\n有了不同模式下生成的结果过后，我们就可以仔细去对比不同 Source Map 模式之间的具体差异了。其实也没必要真的一个一个去看，这里我先带你看几个比较典型的模式，然后找出它们的规律，这样你就再也不用头大了。\n\n首先 eval 模式，这个模式刚刚已经单独看过了，它就是将模块代码放到 `eval` 函数中执行，并且通过 `sourceURL` 标注所属文件路径，在这种模式下没有 Source Map 文件，所以只能定位是哪个文件出错，具体效果如下图：\n\n![eval 模式](https://cdn.zce.me/assets/73af8f2e0e1992a9.png)\n\n然后我们再来看一个叫作 eval-source-map 的模式，这个模式也是使用 eval 函数执行模块代码，不过这里有所不同的是，eval-source-map 模式除了定位文件，还可以定位具体的行列信息。相比于 eval 模式，它能够生成 Source Map 文件，可以反推出源代码，具体效果如下：\n\n<video src=eval-https://cdn.zce.me/assets/042fe91796095a96.mp4 muted autoplay playsinline loop></video>\n\n紧接着我们再来看一个叫作 cheap-eval-source-map 的模式。根据这个模式的名字就能推断出一些信息，它就是在 eval-source-map 基础上添加了一个 cheap，也就是便宜的，或者叫廉价的。用计算机行业的常用说法，就是阉割版的 eval-source-map，因为它虽然也生成了 Source Map 文件，但是这种模式下的 Source Map 只能定位到行，而定位不到列，所以在效果上差了一点点，但是构建速度会提升很多，具体效果如下图：\n\n<video src=cheap-eval-https://cdn.zce.me/assets/042fe91796095a96.mp4 muted autoplay playsinline loop></video>\n\n接下来再看一个叫作 cheap-module-eval-source-map 的模式。慢慢地我们就发现 Webpack 中这些模式的名字不是随意的，好像都有某种规律。这里就是在 cheap-eval-source-map 的基础上多了一个 module，具体效果如下图：\n\n<video src=cheap-module-eval-https://cdn.zce.me/assets/042fe91796095a96.mp4 muted autoplay playsinline loop></video>\n\n这种模式同样也只能定位到行，它的特点相比于 cheap-eval-source-map 并不明显 ，如果你没有发现差异，可以再去看看上一种模式，仔细做一个对比，相信对比之后你会发现，cheap-module-eval-source-map 中定位的源代码与我们编写的源代码是一模一样的，而 cheap-eval-source-map 模式中定位的源代码是经过 ES6 转换后的结果，具体对比如下（左图是 cheap-eval-source-map）：\n\n![cheap-eval-source-map 对比 cheap-module-eval-source-map](https://cdn.zce.me/assets/b73e7d7c7173f13b.png)\n\n这也是为什么之前我要给 JS 文件配置 Loader 的原因：因为这种名字中带有 module 的模式，解析出来的源代码是没有经过 Loader 加工的，而名字中不带 module 的模式，解析出来的源代码是经过 Loader 加工后的结果。也就是说如果我们想要还原一模一样的源代码，就需要选择 cheap-module-eval-source-map 模式。\n\n了解了这些过后，你基本上就算通盘了解了 Webpack 中所有 Source Map 模式之间的差异，因为其它的模式无外乎就是这几个特点的排列组合罢了。\n\n例如，我们再来看一个 cheap-source-map 模式，这个模式的名字中没有 eval，意味着它没用 eval 执行代码，而名字中没有 module，意味着 Source Map 反推出来的是 Loader 处理后的代码，有 cheap 表示只能定位源代码的行号。\n\n那以上就是我们在日常开发过程中经常用到的几种 Source Map 模式，你在尝试的时候一定要注意：找规律很重要。\n\n除此之外，还有几个特殊一点的模式，我们单独介绍一下：\n\n- **inline-source-map 模式**：它跟普通的 source-map 效果相同，只不过这种模式下 Source Map 文件不是以物理文件存在，而是以 data URLs 的方式出现在代码中。我们前面遇到的 eval-source-map 也是这种 inline 的方式。\n- **hidden-source-map 模式**：在这个模式下，我们在开发工具中看不到 Source Map 的效果，但是它也确实生成了 Source Map 文件，这就跟 jQuery 一样，虽然生成了 Source Map 文件，但是代码中并没有引用对应的 Source Map 文件，开发者可以自己选择使用。\n- **nosources-source-map 模式**：在这个模式下，我们能看到错误出现的位置（包含行列位置），但是点进去却看不到源代码。这是为了保护源代码在生产环境中不暴露。\n\n### 写在最后\n\n虽然 Webpack 中支持各种各样的 Source Map 模式，但一般应用开发时我们只会用到其中的几种。其实在我们掌握了它们的特点过后，选择上就没有什么需要纠结的地方了。\n\n这里再分享一下我个人开发时的选择，供你参考。\n\n首先开发过程中（开发环境），我会选择 `cheap-module-eval-source-map`，原因有以下三点：\n\n- 我使用框架的情况会比较多，以 React 和 Vue.js 为例，无论是 JSX 还是 vue 单文件组件，Loader 转换后差别都很大，我需要调试 Loader 转换前的源代码。\n- 一般情况下，我编写的代码每行不会超过 80 个字符，对我而言能够定位到行到位置就够了，而且省略列信息还可以提升构建速度。\n- 虽然在这种模式下启动打包会比较慢，但大多数时间内我使用的 webpack-dev-server 都是在监视模式下重新打包，它重新打包的速度非常快。\n\n综上所述，开发环境下我会选择 `cheap-module-eval-source-map`。\n\n至于发布前的打包，也就是生产环境的打包，我选择 `none`，它不会生成 Source Map。原因很简单：\n\n- 首先，Source Map 会暴露我的源代码到生产环境。如果没有控制 Source Map 文件访问权限的话，但凡是有点技术的人都可以很容易的复原项目中涉及的绝大多数源代码，这非常不合理也不安全，我想很多人可能都忽略了这个问题。\n- 其次，调试应该是开发阶段的事情，你应该在开发阶段就尽可能找到所有问题和隐患，而不是到了生产环境中再去全民公测。如果你对自己的代码实在没有信心，我建议你选择 `nosources-source-map` 模式，这样出现错误可以定位到源码位置，也不至于暴露源码；或者 `hidden-source-map` 模式，出现问题通过工具手动引入 Source Map 文件。\n\n当然这些选择不是绝对的，我们理解这些模式之间的差异的目的，就是为了可以在不同环境中快速选择一个合适的模式，而不是寻求一个通用法则，开发行业也根本不会有绝对的通用法则！\n\n除此之外，我还要强调一点，Source Map 并不是 Webpack 特有的功能，它们两者的关系只是：Webpack 支持 Source Map。大多数的构建或者编译工具也都支持 Source Map 特性。希望你不要把它们二者捆绑到一起，混为一谈。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n","cover":"https://cdn.zce.me/assets/d6eb173a744c29c0.jpg","audio":"https://cdn.zce.me/audio/2020/04/webpack-07.mp3"},{"title":"如何使用 Dev Server 提高你的本地开发效率？","slug":"webpack-dev-server-improve-your-local-dev-efficiency","date":1587579797000,"updated":1673100032129,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","Efficiency"],"meta":{},"content":"\n你好，我是汪磊，通过前面几片文章的介绍，相信你已经了解了 Webpack 的相关概念、基本用法，以及核心工作原理，看似好像已经掌握了 Webpack，但是如果以目前的认知状态去应对日常的开发工作，其实还远远不够。\n\n因为“编写源代码 → Webpack 打包 → 运行应用 → 浏览器查看”这种周而复始的开发方式过于原始，在实际开发过程中，如果你还是按照这种方式来工作，开发效率必然会十分低下。\n\n那究竟该如何提高我们的开发效率呢？\n\n这里我先对一个较为理想的开发环境做出设想：\n\n- 首先，它必须能够使用 HTTP 服务运行而不是文件形式预览。这样的话，一来更接近生产环境状态，二来我们的项目可能需要使用 AJAX 之类的 API，以文件形式访问会产生诸多问题。\n- 其次，在我们修改完代码过后，Webpack 能够自动完成构建，然后浏览器可以即时显示最新的运行结果，这样就大大减少了开发过程中额外的重复操作，同时也会让我们更加专注，效率自然得到提升。\n- 最后，它还需要能提供 [Source Map](https://developer.mozilla.org/zh-CN/docs/Tools/Debugger/How_to/Use_a_source_map) 支持。这样一来，运行过程中出现的错误就可以快速定位到源代码中的位置，而不是打包后结果中的位置，更便于我们快速定位错误、调试应用。\n\n对于以上的这些需求 Webpack 都已经提供了相对应的功能，其中部分功能需要用到一些周边的工具，具体效果如下：\n\n<video src=https://cdn.zce.me/assets/f5c366fadb421e47.mp4 muted autoplay playsinline loop></video>\n\n所以，今天我们的主题就是：学习如何增强使用 Webpack 的开发体验。\n\n### Webpack 自动编译\n\n正如前面所说，如果我们每次修改完代码，都是通过命令行手动重复运行 Webpack 命令，从而得到最新的打包结果，那么这样的操作过程根本没有任何开发体验可言。\n\n针对上述这个问题，我们可以使用 Webpack CLI 提供的另外一种 watch 工作模式来解决。\n\n如果你之前了解过其它的一些构建工具，你应该对 watch 模式并不陌生。在这种模式下，Webpack 完成初次构建过后，项目中的源文件会被监视，一旦发生任何改动，Webpack 都会自动重新运行打包任务。\n\n具体的用法也非常简单，就是在启动 Webpack 时，添加一个 --watch 的 CLI 参数，这样的话，Webpack 就会以监视模式启动运行。在打包完成过后，CLI 不会立即退出，它会等待文件变化再次工作，直到我们手动结束它或是出现不可控的异常。\n\n在 watch 模式下我们就只需专注编码，不必再去手动完成编译工作了，相比于原始手动操作的方式，有了很明显的进步。\n\n我们还可以再开启另外一个命令行终端，同时以 HTTP 形式运行我们的应用，然后打开浏览器去预览应用。\n\n我们可以将浏览器移至屏幕的左侧，然后将编辑器移至右侧，此时我们尝试修改源代码，保存过后，以 watch 模式工作的 Webpack 就会自动重新打包，然后我们就可以在浏览器中刷新页面查看最新的结果，具体效果如下图所示：\n\n![Webpack watch 模式](https://cdn.zce.me/assets/d0170daf07001605.png)\n\n那此时我们的开发体验就是：**修改代码 → Webpack 自动打包 → 手动刷新浏览器 → 预览运行结果**。\n\n> P.S. 这里我使用的静态文件服务器是一个 npm 模块，叫作 [serve](https://github.com/vercel/serve)。\n\n此时距离我们的目标状态还差一点，如果浏览器能够在 Webpack 打包过后自动刷新，那我们的开发体验将会更好一些。\n\n如果你已经了解过一个叫作 [BrowserSync](https://www.browsersync.io) 的工具，你应该知道 BrowserSync 就可以帮我们实现文件变化过后浏览器自动刷新的功能。\n\n所以，我们就可以使用 BrowserSync 工具替换 serve 工具，启动 HTTP 服务，这里还需要同时监听 dist 目录下文件的变化，具体命令如下：\n\n```shell\n# 可以先通过 npm 全局安装 browser-sync 模块，然后再使用这个模块\n$ npm install browser-sync --global\n$ browser-sync dist --watch\n# 或者也可以使用 npx 直接使用远端模块\n$ npx browser-sync dist --watch\n```\n\n启动过后，我们回到编辑器，然后尝试修改源文件，保存完成以后浏览器就会自动刷新，显示最新结果。\n\n它的原理就是 Webpack 监视源代码变化，自动打包源代码到 dist 中，而 dist 中文件的变化又被 BrowserSync 监听了，从而实现自动编译并且自动刷新浏览器的功能，整个过程由两个工具分别监视不同的内容。\n\n这种 watch 模式 + BrowserSync 虽然也实现了我们的需求，但是这种方法有很多弊端：\n\n- 操作烦琐，我们需要同时使用两个工具，那么需要了解的内容就会更多，学习成本大大提高；\n- 效率低下，因为整个过程中， Webpack 会将文件写入磁盘，BrowserSync 再进行读取。过程中涉及大量磁盘读写操作，必然会导致效率低下。\n\n所以这只能算是“曲线救国”，并不完美，我们仍然需要继续改善。\n\n### Webpack Dev Server\n\n[webpack-dev-server](https://github.com/webpack/webpack-dev-server) 是 Webpack 官方推出的一款开发工具，根据它的名字我们就应该知道，它提供了一个开发服务器，并且将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起。\n\nWebpack 官方推出 webpack-dev-server 这款工具的初衷，就是为了提高开发者日常的开发效率，使用这个工具就可以解决我在开头所提出的问题。而且它是一个高度集成的工具，使用起来十分的方便。\n\nwebpack-dev-server 同样也是一个独立的 npm 模块，所以我们需要通过 npm 将 webpack-dev-server 作为项目的开发依赖安装。安装完成过后，这个模块为我们提供了一个叫作 webpack-dev-server 的 CLI 程序，我们同样可以直接通过 npx 直接去运行这个 CLI，或者把它定义到 npm scripts 中，具体操作如下：\n\n```shell\n# 安装 webpack-dev-server\n$ npm install webpack-dev-server --save-dev\n# 运行 webpack-dev-server\n$ npx webpack-dev-server\n```\n\n运行 webpack-dev-server 这个命令时，它内部会启动一个 HTTP Server，为打包的结果提供静态文件服务，并且自动使用 Webpack 打包我们的应用，然后监听源代码的变化，一旦文件发生变化，它会立即重新打包，大致流程如下：\n\n![Webpack Dev Server 工作流程]](workflow.png)\n\n不过这里需要注意的是，webpack-dev-server 为了提高工作速率，它并没有将打包结果写入到磁盘中，而是暂时存放在内存中，内部的 HTTP Server 也是从内存中读取这些文件的。这样一来，就会减少很多不必要的磁盘读写操作，大大提高了整体的构建效率。\n\n![使用内存](https://cdn.zce.me/assets/de64d7bedd8c1de2.png)\n\n我们还可以为 webpack-dev-server 命令传入一个 --open 的参数，用于自动唤起浏览器打开我们的应用。打开浏览器过后，此时如果你有两块屏幕，就可以把浏览器放到另外一块屏幕上，然后体验一边编码，一边即时预览的开发环境了。\n\n#### 配置选项\n\nWebpack 配置对象中可以有一个叫作 devServer 的属性，专门用来为 webpack-dev-server 提供配置，具体如下：\n\n```javascript\n// ./webpack.config.js\nconst path = require('path')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // ...\n  devServer: {\n    contentBase: path.join(__dirname, 'dist'),\n    compress: true,\n    port: 9000\n    // ...\n    // 详细配置文档：https://webpack.js.org/configuration/dev-server/\n  }\n}\n```\n\n具体有哪些配置我们就不在这里一一介绍了，你可以在它的[官网](https://webpack.js.org/configuration/dev-server/)中找到相对应的说明文档。\n\n接下来我们来看几个 webpack-dev-server 的常用功能。\n\n#### 静态资源访问\n\nwebpack-dev-server 默认会将构建结果和输出文件全部作为开发服务器的资源文件，也就是说，只要通过 Webpack 打包能够输出的文件都可以直接被访问到。但是如果你还有一些没有参与打包的静态文件也需要作为开发服务器的资源被访问，那你就需要额外通过配置“告诉” webpack-dev-server。\n\n具体的方法就是在 webpack-dev-server 的配置对象中添加一个对应的配置。我们回到配置文件中，找到 devServer 属性，它的类型是一个对象，我们可以通过这个 devServer 对象的 contentBase 属性指定额外的静态资源路径。这个 contentBase 属性可以是一个字符串或者数组，也就是说你可以配置一个或者多个路径。具体配置如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // ...\n  devServer: {\n    contentBase: 'public'\n  }\n}\n```\n\n我们这里将这个路径设置为项目中的 public 目录。可能有人会有疑问，之前我们在使用插件的时候已经将这个目录通过 copy-webpack-plugin 输出到了输出目录，按照刚刚的说法，所有输出的文件都可以直接被 serve，也就是能直接访问到，按道理应该不需要再作为开发服务器的静态资源路径了。\n\n确实是这样的，而且如果你能想到这一点，也就证明你真正理解了 webpack-dev-server 的文件加载规则。\n\n但是在实际使用 Webpack 时，我们一般都会把 copy-webpack-plugin 这种插件留在上线前的那一次打包中使用，而开发过程中一般不会用它。因为在开发过程中，我们会频繁重复执行打包任务，假设这个目录下需要拷贝的文件比较多，如果每次都需要执行这个插件，那打包过程开销就会比较大，每次构建的速度也就自然会降低。\n\n至于如何实现某些插件只在生产模式打包时使用，是额外的话题，所以具体的操作方式会在[后续文章](/2020/04/webpack-production-optimization/)中详细介绍。这里我们先移除 CopyWebpackPlugin，确保这里的打包不会输出 public 目录中的静态资源文件，然后回到命令行再次执行 webpack-dev-server。\n\n启动过后，我们打开浏览器，这里我们访问的页面文件和 bundle.js 文件均来自于打包结果。我们再尝试访问 favicon.ico，因为这个文件已经没有参与打包了，所以这个文件必然来源于 contentBase 中配置的目录了。\n\n![contentBase 中的 favicon.ico](https://cdn.zce.me/assets/ab0140c503daf9ed.png)\n\n#### Proxy 代理\n\n由于 webpack-dev-server 是一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。但是最终上线过后，我们的应用一般又会和后端服务部署到同源地址下。\n\n那这样就会出现一个非常常见的问题：在实际生产环境中能够直接访问的 API，回到我们的开发环境后，再次访问这些 API 就会产生跨域请求问题。\n\n可能有人会说，我们可以用跨域资源共享（CORS）解决这个问题。确实如此，如果我们请求的后端 API 支持 CORS，那这个问题就不成立了。但是并不是每种情况下服务端的 API 都支持 CORS。如果前后端应用是同源部署，也就是协议 / 域名 / 端口一致，那这种情况下，根本没必要开启 CORS，所以跨域请求的问题仍然是不可避免的。\n\n那解决这种开发阶段跨域请求问题最好的办法，就是在开发服务器中配置一个后端 API 的代理服务，也就是把后端接口服务代理到本地的开发服务地址。\n\nwebpack-dev-server 就支持直接通过配置的方式，添加代理服务。接下来，我们来看一下它的具体用法。\n\n这里我们假定 GitHub 的 API 就是我们应用的后端服务，那我们的目标就是将 GitHub API 代理到本地开发服务器中。\n\n我们可以先在浏览器中尝试访问其中的一个接口，具体结果如下图：\n\n![GitHub API](https://cdn.zce.me/assets/5b372f318871cbee.png)\n\nGitHub API 的 Endpoint 都是在根目录下，也就是说不同的 Endpoint 只是 URL 中的路径部分不同，例如 https://api.github.com/users 和 https://api.github.com/events。\n\n知道 API 地址的规则过后，我们回到配置文件中，在 devServer 配置属性中添加一个 proxy 属性，这个属性值需要是一个对象，对象中的每个属性就是一个代理规则配置。\n\n属性的名称是需要被代理的请求路径前缀，一般为了辨别，我都会设置为 /api。值是所对应的代理规则配置，我们将代理目标地址设置为 https://api.github.com，具体代码如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // ...\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'https://api.github.com'\n      }\n    }\n  }\n}\n```\n\n那此时我们请求 http://localhost:8080/api/users ，就相当于请求了 https://api.github.com/api/users。\n\n![默认代理](https://cdn.zce.me/assets/f9bd2591fcbb0a60.png)\n\n而我们真正希望请求的地址是 https://api.github.com/users，所以对于代理路径开头的 /api 我们要重写掉。我们可以添加一个 pathRewrite 属性来实现代理路径重写，重写规则就是把路径中开头的 /api 替换为空，pathRewrite 最终会以正则的方式来替换请求路径。\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // ...\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'https://api.github.com',\n        pathRewrite: {\n          '^/api': '' // 替换掉代理地址中的 /api\n        }\n      }\n    }\n  }\n}\n```\n\n这样我们代理的地址就正常了。\n\n![重写代理地址](https://cdn.zce.me/assets/57f4a6210e30ee8b.png)\n\n除此之外，我们还需设置一个 changeOrigin 属性为 true。这是因为默认代理服务器会以我们实际在浏览器中请求的主机名，也就是 localhost:8080 作为代理请求中的主机名。而一般服务器需要根据请求的主机名判断是哪个网站的请求，那 localhost:8080 这个主机名，对于 GitHub 的服务器来说，肯定无法正常请求，所以需要修改。\n\n将代理规则配置的 changeOrigin 属性设置为 true，就会以实际代理请求地址中的主机名去请求，也就是我们正常请求这个地址的主机名是什么，实际请求 GitHub 时就会设置成什么。\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // ...\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'https://api.github.com',\n        pathRewrite: {\n          '^/api': '' // 替换掉代理地址中的 /api\n        },\n        changeOrigin: true // 确保请求 GitHub 的主机名就是：api.github.com\n      }\n    }\n  }\n}\n```\n\n完成以后，打开命令行终端，运行 webpack-dev-server。然后打开浏览器，这里我们直接尝试请求 http://localhost:8080/api/users，得到的就是 GitHub 的用户数据。 因为这个地址已经被代理到了 GitHub 的用户数据接口。\n\n![代理后的 API](https://cdn.zce.me/assets/6fab2cefa64a3b88.png)\n\n此时，我们就可以回到代码中使用代理后的本地同源地址去请求后端接口，而不必担心出现跨域问题了。\n\n### 写在最后\n\n最后再来总结一下今天的内容，今天跟你分享了一个叫作 webpack-dev-server 的工具，它是 Webpack 周边工具中最重要的一个，作用就是提升开发者的开发体验，帮助开发者更快更高效的完成开发工作。\n\n当然 webpack-dev-server 提供的体验还不止如此，它还可以提供一种叫作“模块热替换”的开发体验，这一块内容相对复杂一些，我会在[后续文章](/2020/04/webpack-hot-module-replacement/)中详细介绍。\n\n另外我想说，现代化的前端开发过程已经非常方便了，如果你还在使用原始“刀耕火种”的方式进行开发，就一定要尝试一下这些现代化的工具。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n\n> Photo by [Luca Bravo](https://unsplash.com/@lucabravo) on [Unsplash](https://unsplash.com)\n","cover":"https://cdn.zce.me/assets/02783fcf0ad9b34e.jpg","audio":"https://cdn.zce.me/audio/2020/04/webpack-06.mp3"},{"title":"Webpack 运行机制与核心工作原理","slug":"webpack-operation-mechanism-and-core-working-principle","date":1587489197000,"updated":1673100032105,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","Principle"],"meta":{},"content":"\n你好，我是汪磊，在前面的文章中我们已经对 Webpack 两个最重要的特性：[Loader](/2020/04/how-to-load-assets-through-loader/) 和[插件](/2020/04/how-to-extend-webpack-by-plugin/)机制有了深入的了解，今天我们再来解读一下 Webpack 的运行机制和核心工作原理。\n\n### 工作过程简介\n\n其实 Webpack 官网首屏的英雄区就已经很清楚地描述了它的工作原理，如下图所示：\n\n![Webpack](https://cdn.zce.me/assets/1b57209bdcf74d61.png)\n\n那这里我们先来快速理解一下 Webpack 打包的核心工作过程。我们以一个普通的前端项目为例，项目中一般都会散落着各种各样的代码及资源文件，如下图所示：\n\n![项目中的资源文件](https://cdn.zce.me/assets/dfdbdb136fb6666d.png)\n\n比如 JS、CSS、图片、字体等，这些文件在 Webpack 的思想中都属于当前项目中的一个模块。Webpack 可以通过打包，将它们最终聚集到一起。Webpack 在整个打包的过程中：\n\n- 通过 Loader 处理特殊类型资源的加载，例如加载样式、图片；\n- 通过 Plugin 实现各种自动化的构建任务，例如自动压缩、自动发布。\n\n具体来看打包的过程，Webpack 启动后，会根据我们的配置，找到项目中的某个指定文件（一般这个文件都会是一个 JS 文件）作为入口。然后顺着入口文件中的代码，根据代码中出现的 import（ES Modules）或者是 require（CommonJS）之类的语句，解析推断出来这个文件所依赖的资源模块，然后再分别去解析每个资源模块的依赖，周而复始，最后形成整个项目中所有用到的文件之间的依赖关系树，下面这个动画生动的演示了这个过程：\n\n<video src=https://cdn.zce.me/assets/0353c417fdf2dde4.mp4 muted autoplay playsinline loop></video>\n\n有了这个依赖关系树过后， Webpack 会遍历（递归）这个依赖树，找到每个节点对应的资源文件，然后根据配置选项中的 Loader 配置，交给对应的 Loader 去加载这个模块，最后将加载的结果放入 bundle.js（打包结果）中，从而实现整个项目的打包，具体操作可以参考下面的动画：\n\n<video src=https://cdn.zce.me/assets/8a136a224ff5032c.mp4 muted autoplay playsinline loop></video>\n\n对于依赖模块中无法通过 JavaScript 代码表示的资源模块，例如图片或字体文件，一般的 Loader 会将它们单独作为资源文件拷贝到输出目录中，然后将这个资源文件所对应的访问路径作为这个模块的导出成员暴露给外部。\n\n整个打包过程中，Loader 机制起了很重要的作用，因为如果没有 Loader 的话，Webpack 就无法实现各种各样类型的资源文件加载，那 Webpack 也就只能算是一个用来合并 JS 模块代码的工具了。\n\n至于自定义插件机制，在[前面的文章](/2020/04/how-to-extend-webpack-by-plugin/)中我们也详细介绍过了，它并不会影响 Webpack 的核心工作过程，只是 Webpack 为了提供一个强大的扩展能力，它为整个工作过程的每个环节都预制了一个钩子，也就是说我们可以通过插件往 Webpack 工作过程的任意环节植入一些自定义的任务，从而扩展 Webpack 打包功能以外的能力。\n\n至此，你就已经了解到了 Webpack 的核心工作过程。\n\n### 工作原理剖析\n\n对于一般的应用开发过程来说，了解以上这些内容基本上就足以应对了，但如果你想了解 Webpack 整个工作过程的细节，那么你就需要更深入地了解刚刚说到的每一个环节，它们落实到代码层面到底做了些什么，或者说是如何实现的。\n\n在这种情况下，我们就必须有针对性的去“查阅”Webpack 的源代码了。注意这里我们强调的是“查阅”，而不是“阅读”。\n\n至于为什么要扣这个字眼，我们先卖个关子，今天的最后再来解释。\n\n既然是“查阅”，我们就必须要有个线索，否则挨个去看每个源代码，就是无意义的阅读。这里我们的思路就是顺着前面刚刚介绍的 Webpack 打包的核心工作过程，提炼出关键环节，然后再有针对性地去找每个环节的实现方式就可以了。\n\n这里我们先提炼出 Webpack 核心工作过程中的关键环节，明确“查阅”源码的思路：\n\n1. Webpack CLI 启动打包流程；\n2. 载入 Webpack 核心模块，创建 Compiler 对象；\n3. 使用 Compiler 对象开始编译整个项目；\n4. 从入口文件开始，解析模块依赖，形成依赖关系树；\n5. 递归依赖树，将每个模块交给对应的 Loader 处理；\n6. 合并 Loader 处理完的结果，将打包结果输出到 dist 目录。\n\n接下来我们将对上述关键环节中的部分内容进行详细介绍。\n\n#### 一、Webpack CLI\n\n从 Webpack 4 开始 Webpack 的 CLI 部分就被单独抽到了 [webpack-cli](https://github.com/webpack/webpack-cli) 模块中，目的是为了增强 Webpack 本身的灵活性。所以这一部分的内容我们需要找到 webpack-cli 所对应的源码。\n\n我们这里分析的是 v3.3.11 版本的 webpack-cli，你可以参考该版本的[源码固定链接](https://github.com/webpack/webpack-cli/tree/v3.3.11)。\n\n> P.S. 目前 webpack-cli 官方仓库默认分支下的代码不是 3.x 版本的。\n\nWebpack CLI 的作用就是将 CLI 参数和 Webpack 配置文件中的配置整合，得到一个完整的配置对象。\n\n这部分操作在 webpack-cli 的入口文件  bin/cli.js 中，这个文件中内容比较多，我们这里只截取部分核心代码，你可以对照截图中的行号找到源代码中对应的位置。\n\n首先，Webpack CLI 会通过 [yargs](https://github.com/yargs/yargs) 模块解析 CLI 参数，所谓 CLI 参数指的就是我们在运行 webpack 命令时通过命令行传入的参数，例如 --mode=production，具体位置如下：\n\n![使用 yargs 解析参数](https://cdn.zce.me/assets/432d94a48608402a.png)\n\n紧接着后面，调用了 bin/utils/convert-argv.js 模块，将得到的命令行参数转换为 Webpack 的配置选项对象，具体操作如下：\n\n![调用 convert-argv](https://cdn.zce.me/assets/e20b6b9958374a22.png)\n\n在 convert-argv.js 工作过程中，首先为传递过来的命令行参数设置了默认值，然后判断了命令行参数中是否指定了一个具体的配置文件路径，如果指定了就加载指定配置文件，反之则需要根据默认配置文件加载规则找到配置文件，具体代码如下：\n\n![convert-argv 内部逻辑](https://cdn.zce.me/assets/c443471fd4798263.png)\n\n找到配置文件过后，将配置文件中的配置和 CLI 参数中的配置合并，如果出现重复的情况，会优先使用 CLI 参数，最终得到一个完整的配置选项。\n\n有了配置选项过后，开始载入 Webpack 核心模块，传入配置选项，创建 Compiler 对象，这个 Compiler 对象就是整个 Webpack 工作过程中最核心的对象了，负责完成整个项目的构建工作。\n\n![执行 webpack 模块](run-https://cdn.zce.me/assets/1b57209bdcf74d61.png)\n\n#### 二、创建 Compiler 对象\n\n随着 Webpack CLI 载入 Webpack 核心模块，整个执行过程就到了 Webpack 模块中，所以这一部分的代码需要回到 Webpack 模块中，我这里分析的是 v4.43.0 版本的 Webpack，可参考这个版本的[源代码的固定链接](https://github.com/webpack/webpack/tree/v4.43.0)。\n\n同样，这里我们需要找到这个模块的入口文件，也就是 lib/webpack.js 文件。这个文件导出的是一个用于创建 Compiler 的函数，具体如下：\n\n![创建 Compiler](https://cdn.zce.me/assets/cb1677b2c2456a39.png)\n\n在这个函数中，首先校验了外部传递过来的 options 参数是否符合要求，紧接着判断了 options 的类型。\n\n根据这个函数中的代码，我们发现 options 不仅仅可以是一个对象，还可以是一个数组。如果我们传入的是一个数组，那么 Webpack 内部创建的就是一个 MultiCompiler，也就是说 Webpack 应该支持同时开启多路打包，配置数组中的每一个成员就是一个独立的配置选项。而如果我们传入的是普通的对象，就会按照我们最熟悉的方式创建一个 Compiler 对象，进行单线打包。\n\n![单路打包 or 多路打包](https://cdn.zce.me/assets/b709a9c2e5670b96.png)\n\n我们顺着主线接着往下看，如下图所示：在创建了 Compiler 对象过后，Webpack 就开始注册我们配置中的每一个插件了，因为再往后 Webpack 工作过程的生命周期就要开始了，所以必须先注册，这样才能确保插件中的每一个钩子都能被命中。\n\n![注册全部插件](https://cdn.zce.me/assets/d15ec6e90f77ac1d.png)\n\n#### 三、开始构建\n\n完成 Compiler 对象的创建过后，紧接着这里的代码开始判断配置选项中是否启用了监视模式，具体操作如下：\n\n![开始执行 Compiler](https://cdn.zce.me/assets/79122882ee02376d.png)\n\n- 如果是监视模式就调用 Compiler 对象的 watch 方法，以监视模式启动构建，但这不是我们主要关心的主线。\n- 如果不是监视模式就调用 Compiler 对象的 run 方法，开始构建整个应用。\n\n这个 run 方法定义在 Compiler 类型中，具体文件在 webpack 模块下的 lib/Compiler.js 中，代码位置如下：\n\n![Compiler 内部结构](https://cdn.zce.me/assets/0750346253106ba9.png)\n\n这个方法内部就是先触发了 beforeRun 和 run 两个钩子，然后最关键的是调用了当前对象的 compile 方法，真正开始编译整个项目，具体代码位置如下：\n\n![执行 compile](https://cdn.zce.me/assets/b517313302305be4.png)\n\ncompile 方法内部主要就是创建了一个 Compilation 对象，这个对象我们在[插件机制](/2020/04/how-to-extend-webpack-by-plugin/)中有提到，Compilation 字面意思是“合集”，实际上，你就可以理解为一次构建过程中的上下文对象，里面包含了这次构建中全部的资源和信息。\n\n![创建 Compilation 对象](https://cdn.zce.me/assets/d40624b8ca4807e1.png)\n\n创建完 Compilation 对象过后，紧接着触发了一个叫作 make 的钩子，进入整个构建过程最核心的 make 阶段。\n\n#### 四、make 阶段\n\nmake 阶段主体的目标就是：根据 entry 配置找到入口模块，开始依次递归出所有依赖，形成依赖关系树，然后将递归到的每个模块交给不同的 Loader 处理。\n\n![make 阶段](https://cdn.zce.me/assets/a9c04b2a44d7b867.png)\n\n由于这个阶段的调用过程并不像之前一样，直接调用某个对象的某个方法，而是采用事件触发机制，让外部监听这个 make 事件的地方开始执行，所以从这里往后的代码可能找起来会费点劲儿。\n\n这里我简单提示一下：想要知道这个事件触发后，哪些地方会开始执行，前提是得知道哪里注册了这个叫作 make 的事件。\n\nWebpack 的插件系统是基于官方自己的 [Tapable](https://github.com/webpack/tapable) 库实现的，我们想要知道在哪里注册了某个事件，必须要知道如何注册的事件。Tapable 的注册方式具体如下：\n\n![Tapable](https://cdn.zce.me/assets/9082e1497afb1350.png)\n\n所以，我们只需要通过开发工具搜索源代码中的 make.tap，就应该能够找到事件注册的位置，具体操作如下：\n\n![make.tap](https://cdn.zce.me/assets/70046433e63f052b.png)\n\n这里搜索到了六个插件中都注册了 make 事件，这些插件实际上是前面创建 Compiler 对象的时候创建的，刚刚因为没有影响，所以我们就忽略了：\n\n![内置插件](https://cdn.zce.me/assets/7adee84d720e0478.png)\n\n因为我们默认使用的就是单一入口打包的方式，所以这里最终会执行其中的 SingleEntryPlugin。\n\n![SingleEntryPlugin](https://cdn.zce.me/assets/66ab332acf210b4e.png)\n\n这个插件中调用了 Compilation  对象的 addEntry 方法，开始解析我们源代码中的入口文件，以此开始“顺藤摸瓜”式的寻找。\n\n因为时间的关系，我在这里就不再带你继续一步一步的往后探索每一个阶段了，你可以顺着我们刚刚的思路，私下继续去尝试。\n\n对于 make 阶段后续的流程，这里我们概括一下：\n\n1. SingleEntryPlugin 中调用了 Compilation 对象的 addEntry 方法，开始解析入口；\n2. addEntry 方法中又调用了 \\_addModuleChain 方法，将入口模块添加到模块依赖列表中；\n3. 紧接着通过 Compilation 对象的 buildModule 方法进行模块构建；\n4. buildModule 方法中执行具体的 Loader，处理特殊资源加载；\n5. build 完成过后，通过 [acorn](https://github.com/acornjs/acorn) 库生成模块代码的 AST 语法树；\n6. 根据语法树分析这个模块是否还有依赖的模块，如果有则继续循环 build 每个依赖；\n7. 所有依赖解析完成，build 阶段结束；\n8. 最后合并生成需要输出的 bundle.js 写入 dist 目录。\n\n### 写在最后\n\n今天的内容，我算是抛砖引玉，围绕着 Webpack 打包的核心工作过程，单独通过查阅对应源码的方式，深入理解了一下 Webpack “前半程”的工作原理，其实我重点想跟你分享的是**如何通过查阅源码来增强对技术理解的方式。**\n\n最后再来解释一下，为什么我要说查阅源代码而不是阅读源代码。\n\n其实我是想说，现在市面上很多的资料动不动就跟你说：“你一定要阅读 XXX 项目的源码”。而当你真的相信了这种说法，自己花费时间去尝试阅读源码的时候，大多数结果都是感觉看不懂，即使是你耗费了很多的时间，把 XXX 项目的源码啃下来了，结果仍然感觉没有太大进步。我不敢说这种“啃源码”的方式一点意义没有，只是投入回报比太低了。\n\n原因是，很多时候你都是为了证明你看过源码而去看的源码，这种目的就决定了，你的效率和效果都不会很好。为什么这么说呢？\n\n因为我们阅读源代码的目的，很多时候都是为了去看某个问题在内部具体是如何实现的。这种情况下我们都是带着问题去看的源码，这种阅读源码的情况越多，积累的就更多，解决问题的能力自然就可以得到提升。\n\n打个比方，源码就好像是牛津词典一样，你是应该没事抱着它一页一页的读，还是应该遇到不懂的单词再去查呢？答案显而易见。\n\n所以说，学习任何东西都需要一个清晰的目标，带着问题，一边学习一边找答案，而不是漫无目的学到哪里是哪里。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n\n> Photo by [Austin Distel](https://unsplash.com/@austindistel) on [Unsplash](https://unsplash.com)\n","cover":"https://cdn.zce.me/assets/99a0267b1140c4e7.jpg","audio":"https://cdn.zce.me/audio/2020/04/webpack-05.mp3"},{"title":"如何利用插件机制横向扩展 Webpack 的能力？","slug":"how-to-extend-webpack-by-plugin","date":1587399985000,"updated":1673100032089,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","Plugin"],"meta":{},"content":"\n你好，我是汪磊，上回说到 [Webpack 的 Loader 机制](/2020/04/how-to-load-assets-through-loader/)，今天我要跟你分享 Webpack 的另外一个重要的核心特性：插件机制。\n\nWebpack 插件机制的目的是为了增强 Webpack 在项目自动化构建方面的能力。通过[上一篇文章](/2020/04/how-to-load-assets-through-loader/)的介绍你应该知道，Loader 就是负责完成项目中各种各样资源模块的加载，从而实现整体项目的模块化，而 Plugin 则是用来解决项目中除了资源模块打包以外的其他自动化工作，所以说 Plugin 的能力范围更广，用途自然也就更多。\n\n我在这里先介绍几个插件最常见的应用场景：\n\n- 实现自动在打包之前清除 dist 目录（上次的打包结果）；\n- 自动生成应用所需要的 HTML 文件；\n- 根据不同环境为代码注入类似 API 地址这种可能变化的部分；\n- 拷贝不需要参与打包的资源文件到输出目录；\n- 压缩 Webpack 打包完成后输出的文件；\n- 自动发布打包结果到服务器实现自动部署。\n\n总之，有了 Plugin 的 Webpack 几乎“无所不能”。借助插件，我们就可以轻松实现前端工程化中绝大多数经常用到的功能，这也正是很多初学者会认为 “Webpack 就是前端工程化，或者前端工程化就是 Webpack” 的原因。\n\n那接下来我们通过一些常用插件的使用，具体聊聊 Webpack 的插件机制，最后再通过开发一个自己的插件，去理解插件的工作原理。\n\n### 体验插件机制\n\n这里我们先来体验几个最常见的插件，首先第一个就是用来自动清除输出目录的插件。\n\n通过之前的尝试，你可能已经发现，Webpack 每次打包的结果都是直接覆盖到 dist 目录。而在打包之前，dist 目录中就可能已经存入了一些在上一次打包操作时遗留的文件，当我们再次打包时，只能覆盖掉同名文件，而那些已经移除的资源文件就会一直累积在里面，最终导致部署上线时出现多余文件，这显然非常不合理。\n\n更为合理的做法就是在每次完整打包之前，自动清理 dist 目录，这样每次打包过后，dist 目录中就只会存在那些必要的文件。\n\nclean-webpack-plugin 这个插件就很好的实现了这一需求。它是一个第三方的 npm 包，我们需要先通过 npm 安装一下，具体操作如下：\n\n```shell\n$ npm install clean-webpack-plugin --save-dev\n```\n\n安装过后，我们回到 Webpack 的配置文件中，然后导入 clean-webpack-plugin 插件，这个插件模块导出了一个叫作 CleanWebpackPlugin 的成员，我们先把它解构出来，具体代码如下。\n\n```javascript\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n```\n\n回到配置对象中，添加一个 plugins 属性，这个属性就是专门用来配置插件的地方，它是一个数组，添加一个插件就是在这个数组中添加一个元素。\n\n绝大多数插件模块导出的都是一个类型，我们这里的 CleanWebpackPlugin 也不例外，使用它，就是通过这个类型创建一个实例，放入 plugins 数组中，具体代码如下：\n\n```javascript\n// ./webpack.config.js\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  plugins: [new CleanWebpackPlugin()]\n}\n```\n\n完成以后我们来测试一下 clean-webpack-plugin 插件的效果。回到命令行终端，再次运行 Webpack 打包，此时之前的打包结果就不会存在了，dist 目录中存放的就都是我们本次打包的结果。\n\n在这里，我只是希望通过这个非常简单的插件带你体验一下 Webpack 插件的使用。一般来说，当我们有了某个自动化的需求过后，可以先去找到一个合适的插件，然后安装这个插件，最后将它配置到 Webpack 配置对象的 plugins 数组中，这个过程唯一有可能不一样的地方就是，有的插件可能需要有一些配置参数。\n\n#### 用于生成 HTML 的插件\n\n除了自动清理 dist 目录，我们还有一个非常常见的需求，就是自动生成使用打包结果的 HTML，所谓使用打包结果指的是在 HTML 中自动注入 Webpack 打包生成的 bundle。\n\n在使用接下来这个插件之前，我们的 HTML 文件一般都是通过硬编码的方式，单独存放在项目根目录下的，这种方式有两个问题：\n\n1. 项目发布时，我们需要同时发布根目录下的 HTML 文件和 dist 目录中所有的打包结果，非常麻烦，而且上线过后还要确保 HTML 代码中的资源文件路径是正确的。\n2. 如果打包结果输出的目录或者文件名称发生变化，那 HTML 代码中所对应的 script 标签也需要我们手动修改路径。\n\n解决这两个问题最好的办法就是让 Webpack 在打包的同时，自动生成对应的 HTML 文件，让 HTML 文件也参与到整个项目的构建过程。这样的话，在构建过程中，Webpack 就可以自动将打包的 bundle 文件引入到页面中。\n\n相比于之前写死 HTML 文件的方式，自动生成 HTML 的优势在于：\n\n- HTML 也输出到 dist 目录中了，上线时我们只需要把 dist 目录发布出去就可以了；\n- HTML 中的 script 标签是自动引入的，所以可以确保资源文件的路径是正常的。\n\n具体的实现方式就需要借助于 html-webpack-plugin 插件来实现，这个插件也是一个第三方的 npm 模块，我们这里同样需要单独安装这个模块，具体操作如下：\n\n```shell\n$ npm install html-webpack-plugin --save-dev\n```\n\n安装完成过后，回到配置文件，载入这个模块，不同于 clean-webpack-plugin，html-webpack-plugin 插件默认导出的就是插件类型，不需要再解构内部成员，具体如下：\n\n```javascript\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n```\n\n有了这个类型过后，回到配置对象的 plugins 属性中，同样需要添加一下这个类型的实例对象，完成这个插件的使用，具体配置代码如下：\n\n```javascript\n// ./webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  plugins: [new CleanWebpackPlugin(), new HtmlWebpackPlugin()]\n}\n```\n\n最后我们回到命令行终端，再次运行打包命令，此时打包过程中就会自动生成一个 index.html 文件到 dist 目录。我们找到这个文件，可以看到文件中的内容就是一段使用了 bundle.js 的空白 HTML，具体结果如下：\n\n![默认输出 HTML](https://cdn.zce.me/assets/df86a0719e29ece4.png)\n\n至此，Webpack 就可以动态生成应用所需的 HTML 文件了，但是这里仍然存在一些需要改进的地方：\n\n- 对于生成的 HTML 文件，页面 title 必须要修改；\n- 很多时候还需要我们自定义页面的一些 meta 标签和一些基础的 DOM 结构。\n\n也就是说，还需要我们能够充分自定义这个插件最终输出的 HTML 文件。\n\n如果只是简单的自定义，我们可以通过修改 HtmlWebpackPlugin 的参数来实现。\n\n我们回到 Webpack 的配置文件中，这里我们给 HtmlWebpackPlugin 构造函数传入一个对象参数，用于指定配置选项。其中，title 属性设置的是 HTML 的标题，我们把它设置为 Webpack Plugin Simple。meta 属性需要以对象的形式设置页面中的元数据标签，这里我们尝试为页面添加一个 viewport 设置，具体代码如下：\n\n```javascript\n// ./webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  plugins: [\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      title: 'Webpack Plugin Sample',\n      meta: {\n        viewport: 'width=device-width'\n      }\n    })\n  ]\n}\n```\n\n完成以后回到命令行终端，再次打包，然后我们再来看一下生成的 HTML 文件，此时这里的 title 和 meta 标签就会根据配置生成，具体结果如下：\n\n![修改选项后输出 HTML](https://cdn.zce.me/assets/1175a51bc1bac530.png)\n\n如果需要对 HTML 进行大量的自定义，更好的做法是在源代码中添加一个用于生成 HTML 的模板，然后让 html-webpack-plugin 插件根据这个模板去生成页面文件。\n\n我们这里在 src 目录下新建一个 index.html 文件作为 HTML 文件的模板，然后根据我们的需要在这个文件中添加相应的元素。对于模板中动态的内容，可以使用 Lodash 模板语法输出，模板中可以通过 htmlWebpackPlugin.options 访问这个插件的配置数据，例如我们这里输出配置中的 title 属性，具体代码如下：\n\n```html\n<!-- ./src/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title><%= htmlWebpackPlugin.options.title %></title>\n  </head>\n  <body>\n    <div class=\"container\">\n      <h1>页面上的基础结构</h1>\n      <div id=\"root\"></div>\n    </div>\n  </body>\n</html>\n```\n\n有了模板文件过后，回到配置文件中，我们通过 HtmlWebpackPlugin 的 template 属性指定所使用的模板，具体配置如下：\n\n```javascript\n// ./webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  plugins: [\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      title: 'Webpack Plugin Sample',\n      template: './src/index.html'\n    })\n  ]\n}\n```\n\n完成以后我们回到命令行终端，运行打包命令，然后再来看一下生成的 HTML 文件，此时 HTML 中就都是根据模板生成的内容了，具体结果如下：\n\n![基于模板输出 HTML](https://cdn.zce.me/assets/e115bc41f986edd2.png)\n\n至此，你应该了解了如何通过 html-webpack-plugin 自定义输出 HTML 文件内容。\n\n关于 html-webpack-plugin 插件，除了自定义输出文件的内容，同时输出多个 HTML 文件也是一个非常常见的需求，除非我们的应用是一个单页应用程序，否则一定需要输出多个 HTML 文件。\n\n如果需要同时输出多个 HTML 文件，其实也非常简单，我们回到配置文件中，这里通过 HtmlWebpackPlugin 创建的对象就是用于生成 index.html 的，那我们完全可以再创建一个新的实例对象，用于创建额外的 HTML 文件。\n\n例如，这里我们再来添加一个 HtmlWebpackPlugin 实例用于创建一个 about.html 的页面文件，我们需要通过 filename 指定输出文件名，这个属性的默认值是 index.html，我们把它设置为 about.html，具体配置如下：\n\n```javascript\n// ./webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  plugins: [\n    new CleanWebpackPlugin(),\n    // 用于生成 index.html\n    new HtmlWebpackPlugin({\n      title: 'Webpack Plugin Sample',\n      template: './src/index.html'\n    }),\n    // 用于生成 about.html\n    new HtmlWebpackPlugin({\n      filename: 'about.html'\n    })\n  ]\n}\n```\n\n完成以后我们再次回到命令行终端，运行打包命令，然后我们展开 dist 目录，此时 dist 目录中就同时生成了 index.html 和 about.html 两个页面文件。\n\n根据这个尝试我们就应该知道，如果需要创建多个页面，就需要在插件列表中加入多个 HtmlWebpackPlugin 的实例对象，让每个对象负责一个页面文件的生成。\n\n当然了，对于同时输出多个 HTML，一般我们还会配合 Webpack 多入口打包的用法，这样就可以让不同的 HTML 使用不同的打包结果。不过关于多入口打包的用法不在今天的讨论范畴内，我们后面有机会再单独介绍。\n\n#### 用于复制文件的插件\n\n在我们的项目中一般还有一些不需要参与构建的静态文件，那它们最终也需要发布到线上，例如网站的 favicon、robots.txt 等。\n\n一般我们建议，把这类文件统一放在项目根目录下的 public 或者 static 目录中，我们希望 Webpack 在打包时一并将这个目录下所有的文件复制到输出目录。\n\n对于这种需求，我们可以使用 copy-webpack-plugin 插件来帮我们实现。\n\n同理，我们需要先安装一下 copy-webpack-plugin 插件，安装完成过后，回到配置文件中，导入这个插件类型。然后同样在 plugins 属性中添加一个这个类型的实例，具体代码如下：\n\n```javascript\n// ./webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  plugins: [\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      title: 'Webpack Plugin Sample',\n      template: './src/index.html'\n    }),\n    new CopyWebpackPlugin({\n      patterns: ['public'] // 需要拷贝的目录或者路径通配符\n    })\n  ]\n}\n```\n\n这个插件类型的构造函数需要我们传入一个字符串数组，用于指定需要拷贝的文件路径。它可以是一个通配符，也可以是一个目录或者文件的相对路径。我们这里传入的是 public 目录，表示将这个目录下所有文件全部拷贝到输出目录中。当然了，你还可以在这个数组中继续添加其它路径，这样它在工作时可以同时拷贝。\n\n配置完成以后回到命令行终端，再次运行 Webpack，此时 public 目录下的文件就会同时拷贝到输出目录中。\n\n至此，我们简单了解了几个非常常用的插件，这里的重点是，你不仅要学会使用这几个插件的使用，还要能够总结出大多数插件在使用上的共性。\n\n### 开发一个插件\n\n通过前面的介绍，我们知道相比于 Loader，插件的能力范围更宽，因为 Loader 只是在模块的加载环节工作，而插件的作用范围几乎可以触及 Webpack 工作的每一个环节。\n\n那么，这种插件机制是如何实现的呢？\n\n其实说起来也非常简单，Webpack 的插件机制就是我们在软件开发中最常见的钩子机制。\n\n钩子机制也特别容易理解，它有点类似于 Web 中的事件。在 Webpack 整个工作过程会有很多环节，为了便于插件的扩展，Webpack 几乎在每一个环节都埋下了一个钩子。这样我们在开发插件的时候，通过往这些不同节点上挂载不同的任务，就可以轻松扩展 Webpack 的能力。\n\n<video src=https://cdn.zce.me/assets/d7bf2fd7506c31bb.mp4 muted autoplay playsinline loop></video>\n\n具体有哪些预先定义好的钩子，我们可以参考官方文档的 API：\n\n- [Compiler Hooks](https://webpack.js.org/api/compiler-hooks/)；\n- [Compilation Hooks](https://webpack.js.org/api/compilation-hooks/)；\n- [JavascriptParser Hooks](https://webpack.js.org/api/parser/)。\n\n接下来，我们来开发一个自己的插件，看看具体如何往这些钩子上挂载任务。\n\n这里我的需求是，希望我们开发的这个插件能够自动清除 Webpack 打包结果中的注释，这样一来，我们的 bundle.js 将更容易阅读，如下图所示：\n\n![插件目标](https://cdn.zce.me/assets/7863edb1c8325cac.png)\n\n那这里我们同样在项目根目录下添加一个单独的 JS 文件。\n\n```diff\n └─ 04-webpack-plugins ······················· sample root dir\n    ├── public ······························· static dir\n    │   └── favicon.ico ······················ static file\n    ├── src ·································· source dir\n    │   └── main.js ·························· entry module\n    ├── package.json ························· package file\n+   ├── remove-comments-plugin.js ············ my plugin\n    └── webpack.config.js ···················· webpack config file\n```\n\nWebpack 要求我们的插件必须是一个函数或者是一个包含 apply 方法的对象，一般我们都会定义一个类型，在这个类型中定义 apply 方法。然后在使用时，再通过这个类型来创建一个实例对象去使用这个插件。\n\n所以我们这里定义一个 RemoveCommentsPlugin 类型，然后在这个类型中定义一个 apply 方法，这个方法会在 Webpack 启动时被调用，它接收一个 compiler 对象参数，这个对象是 Webpack 工作过程中最核心的对象，里面包含了我们此次构建的所有配置信息，我们就是通过这个对象去注册钩子函数，具体代码如下：\n\n```javascript\n// ./remove-comments-plugin.js\nclass RemoveCommentsPlugin {\n  apply(compiler) {\n    console.log('RemoveCommentsPlugin 启动')\n    // compiler => 包含了我们此次构建的所有配置信息\n  }\n}\n```\n\n知道这些过后，还需要明确我们这个任务的执行时机，也就是到底应该把这个任务挂载到哪个钩子上。\n\n我们的需求是删除 bundle.js 中的注释，也就是说只有当 Webpack 需要生成的 bundle.js 文件内容明确过后才可能实施。\n\n![emit 文档](https://cdn.zce.me/assets/b295a9ddda4e428c.png)\n\n那根据 API 文档中的介绍，我们找到一个叫作 emit 的钩子，这个钩子会在 Webpack 即将向输出目录输出文件时执行，非常符合我们的需求。\n\n我们回到代码中，通过 compiler 对象的 hooks 属性访问到 emit 钩子，再通过 tap 方法注册一个钩子函数，这个方法接收两个参数：\n\n- 第一个是插件的名称，我们这里的插件名称是 RemoveCommentsPlugin；\n- 第二个是要挂载到这个钩子上的函数；\n\n根据 API 文档中的提示，这里我们在这个函数中接收一个 compilation 对象参数，这个对象可以理解为此次运行打包的上下文，所有打包过程中产生的结果，都会放到这个对象中。\n\n我们可以使用这个对象中的 assets 属性获取即将写入输出目录的资源文件信息，它是一个对象，我们这里通过 for in 去遍历这个对象，其中键就是每个文件的名称，我们尝试把它打印出来，具体代码如下：\n\n```javascript\n// ./remove-comments-plugin.js\nclass RemoveCommentsPlugin {\n  apply(compiler) {\n    compiler.hooks.emit.tap('RemoveCommentsPlugin', compilation => {\n      // compilation => 可以理解为此次打包的上下文\n      for (const name in compilation.assets) {\n        console.log(name) // 输出文件名称\n      }\n    })\n  }\n}\n```\n\n完成以后，我们将这个插件应用到 Webpack 的配置中，然后回到命令行重新打包，此时打包过程就会打印我们输出的文件名称，代码如下：\n\n![插件启动运行](https://cdn.zce.me/assets/e9ae5e87868e3b96.png)\n\n我们再回到代码中，来打印一下每个资源文件的内容，文件内容需要通过遍历的值对象中的 source 方法获取，具体代码如下：\n\n```javascript\n// ./remove-comments-plugin.js\nclass RemoveCommentsPlugin {\n  apply(compiler) {\n    compiler.hooks.emit.tap('RemoveCommentsPlugin', compilation => {\n      // compilation => 可以理解为此次打包的上下文\n      for (const name in compilation.assets) {\n        // console.log(name)\n        console.log(compilation.assets[name].source()) // 输出文件内容\n      }\n    })\n  }\n}\n```\n\n回到命令行，再次打包，此时输出的文件内容也可以正常被打印。\n\n能够拿到文件名和文件内容后，我们回到代码中。这里需要先判断文件名是不是以 .js 结尾，因为 Webpack 打包还有可能输出别的文件，而我们的需求只需要处理 JS 文件。\n\n那如果是 JS 文件，我们将文件内容得到，再通过正则替换的方式移除掉代码中的注释，最后覆盖掉 compilation.assets 中对应的对象，在覆盖的对象中，我们同样暴露一个 source 方法用来返回新的内容。另外还需要再暴露一个 size 方法，用来返回内容大小，这是 Webpack 内部要求的格式，具体代码如下：\n\n```javascript\n// ./remove-comments-plugin.js\nclass RemoveCommentsPlugin {\n  apply(compiler) {\n    compiler.hooks.emit.tap('RemoveCommentsPlugin', compilation => {\n      // compilation => 可以理解为此次打包的上下文\n      for (const name in compilation.assets) {\n        if (name.endsWith('.js')) {\n          const contents = compilation.assets[name].source()\n          const noComments = contents.replace(/\\/\\*{2,}\\/\\s?/g, '')\n          compilation.assets[name] = {\n            source: () => noComments,\n            size: () => noComments.length\n          }\n        }\n      }\n    })\n  }\n}\n```\n\n完成以后回到命令行终端，再次打包，打包完成过后，我们再来看一下 bundle.js，此时 bundle.js 中每行开头的注释就都被移除了。\n\n![移除注释后的 bundle](https://cdn.zce.me/assets/fd11fa68b81dbc7b.png)\n\n以上就是我们实现一个移除注释插件的过程，通过这个过程我们了解了：插件都是通过往 Webpack 生命周期的钩子中挂载任务函数实现的。\n\n### 写在最后\n\n最后我们再来总结一下今天的内容：\n\n首先，我们简单了解了几个非常常用的插件，这些插件一般都适用于任何类型的项目。不管你有没有使用框架，或者使用的是哪一个框架，它们基本上都会用到，所以说，在这之后你最好能够仔细过一遍这些插件的官方说明，看看它们还可以有哪些特别的用法，做到心中有数。\n\n除此之外，社区中还提供了成百上千的插件，你并不需要也不可能全部认识。当你遇到一些具体的构建需求时，再去提炼你需求中的关键词然后搜索它们。\n\n例如，我想要压缩输出的图片，我会搜索 _imagemin webpack plugin_。\n\n![搜索结果](https://cdn.zce.me/assets/137e96e0c0a464e2.png)\n\n虽然说每个插件的作用不尽相同，但是在用法上基本都是类似的。\n\n其次，我们通过一个简单插件的开发过程，了解了插件机制的工作原理，总结下来就是一句话：**Webpack 为每一个工作环节都预留了合适的钩子，我们在扩展时只需要找到合适的时机去做合适的事情就可以了。**\n\n这种钩子机制又叫作面向切面编程（AOP），是软件工程中实现插件机制最常见的方式，如果你在以后的开发工作中有类似的需求，那钩子机制一定是最好的选择。而且对于使用 JavaScript 的开发者而言，实现面向切面编程其实也很容易，很多时候我们都会采用事件机制去实现这种编程模式。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n\n> Photo by [WebFactory Ltd](https://unsplash.com/@webfactoryltd) on [Unsplash](https://unsplash.com)\n","cover":"https://cdn.zce.me/assets/2dccd79d5e1bdace.jpg","audio":"https://cdn.zce.me/audio/2020/04/webpack-04.mp3"},{"title":"如何通过 Loader 实现特殊资源加载？","slug":"how-to-load-assets-through-loader","date":1587309133000,"updated":1673100032081,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化","Loader"],"meta":{},"content":"\n你好，我是汪磊，今天我要跟你分享的内容是如何通过 Loader 机制实现特殊资源加载，通过开发一个 Loader 深入理解 Webpack Loader 机制的原理。\n\n正如[开篇](/2020/04/webpack-the-cornerstone-of-modern-app/)中所讲到的，Webpack 想要实现的是整个前端项目的模块化，项目中的各种资源（包括 CSS 文件、图片等）都应该属于需要被管理的模块。换句话说， Webpack 不仅是 JavaScript 模块打包工具，还是整个前端项目（前端工程）的模块打包工具。这也就是说，我们可以通过 Webpack 去管理前端项目中任意类型的资源文件。\n\n因为 Webpack 实现不同种类资源模块加载的核心就是 Loader，所以今天我来和你聊聊 Webpack 的 Loader 机制。\n\n### 如何加载资源模块\n\n首先，我们尝试通过 Webpack 打包项目中的一个 CSS 文件，由此开始探索 Webpack 是如何加载资源模块的？\n\n在下面这个案例中，我们在项目的 src 目录下添加一个普通的样式文件 main.css，具体结构和样式代码如下所示：\n\n```diff\n └─ 03-webpack-loader ························ sample root dir\n    ├── src ·································· source dir\n+   │   └── main.css ························· main styles\n    ├── package.json ························· package file\n    └── webpack.config.js ···················· webpack config file\n```\n\n```css\n/* ./src/main.css */\nbody {\n  margin: 0 auto;\n  padding: 0 20px;\n  max-width: 800px;\n  background: #f4f8fb;\n}\n```\n\n然后将 Webpack 配置中的入口文件路径指定为 main.css 的文件路径，让 Webpack 直接打包 CSS 资源文件，具体配置如下所示：\n\n```javascript\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  // 样式文件路径\n  entry: './src/main.css',\n  output: {\n    filename: 'bundle.js'\n  }\n}\n```\n\n你可能会好奇：_Webpack 的打包入口不是应该是一个 JS 文件吗？为什么这里配置成了一个 CSS 文件呢？_\n\n其实 Webpack 并没有强制要求我们必须以 JS 文件作为打包入口，只是在绝大多数情况下，我们会用 JS 文件作为打包入口，因为 JS 文件才是程序的逻辑入口，以 JS 文件作为入口相对更合理。\n\n那么，我们这里为什么要使用 CSS 文件作为入口呢？\n\n其实就是单纯地为了尝试使用 Webpack 直接去打包 CSS 文件，关于同时打包 JS 和 CSS 的操作，待会儿会详细介绍。\n\n配置完成过后回到命令行终端再次运行 Webpack 打包命令，此时你会发现命令行报出了一个模块解析错误，具体错误如下所示：\n\n![](https://cdn.zce.me/assets/c7abc1e9c305b98e.png)\n\n错误信息大体的意思是说，在解析模块过程中遇到了非法字符，而且错误出现的位置就是在我们的 CSS 文件中。\n\n出现这个错误的原因是因为 Webpack 内部默认只能够处理 JS 模块代码，也就是说在打包过程中，它默认把所有遇到的文件都当作 JavaScript 代码进行解析，但是此处我们让 Webpack 处理的是 CSS 代码，而  CSS 代码是不符合 JavaScript 语法的，所以自然会报出模块解析错误。\n\n为了佐证 Webpack 默认只能够按照 JavaScript 语法解析模块，你可以尝试将 main.css 文件中的代码修改为一段 JavaScript 代码，然后重新运行 Webpack 打包来看一下结果。具体操作如下：\n\n```javascript\n/* ./src/main.css */\nconsole.log('This is a style sheet.')\n/* 这里这么写只是为了证明 Webpack 默认按照 JS 语法解析模块 */\n```\n\n![](https://cdn.zce.me/assets/57758706d8bda75e.png)\n\n> 注意：这里在 CSS 中编写 JS 代码只是为了证实我们的观点，并不是真的要这样使用。\n\n我们再次回到前面提到的错误描述中，如下所示：\n\n![](https://cdn.zce.me/assets/c7abc1e9c305b98e.png)\n\n这里有一个非常重要的提示：_You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. （我们需要用适当的加载器来处理这种文件类型，而当前并没有配置一个可以用来处理此文件的加载器）_。\n\n根据这个错误说明，我们发现**Webpack 是用 Loader（加载器）来处理每个模块的，而内部默认的 Loader 只能处理 JS 模块，如果需要加载其他类型的模块就需要配置不同的 Loader**。这也就引出了我们今天的主角：Loader。\n\n![](https://cdn.zce.me/assets/637b0a91779c6936.png)\n\n#### 加载器的使用方式\n\n需要的是一个可以加载 CSS 模块的 Loader，最常用到的是 css-loader。我们需要通过 npm 先去安装这个 Loader，然后在配置文件中添加对应的配置，具体操作和配置如下所示：\n\n```shell\n$ npm install css-loader --save-dev\n# or yarn add css-loader --dev\n```\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/main.css',\n  output: {\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, // 根据打包过程中所遇到文件路径匹配是否使用这个 loader\n        use: 'css-loader' // 指定具体的 loader\n      }\n    ]\n  }\n}\n```\n\n在配置对象的 module 属性中添加一个 rules 数组。这个数组就是我们针对资源模块的加载规则配置，其中的每个规则对象都需要设置两个属性：\n\n- 首先是 test 属性，它是一个正则表达式，用来匹配打包过程中所遇到文件路径，这里我们是以 `.css` 结尾；\n- 然后是 use 属性，它用来指定匹配到的文件需要使用的 loader，这里用到的是 css-loader。\n\n配置完成过后，我们回到命令行终端重新运行打包命令，打包过程就不会再出现错误了，因为这时 CSS 文件会交给 css-loader 处理过后再由 Webpack 打包。\n\n![](https://cdn.zce.me/assets/749ea76bcc0abfce.png)\n\n#### 样式模块加载的问题\n\n此时，如果你尝试在页面中使用这里输出的 bundle.js 文件，你会发现刚刚的这个 main.css 模块并没有工作。\n\n如果你之前有些经验，可能知道这个问题的解法，其实很简单，只需要再额外添加一个 style-loader，样式就可以正常工作了。\n\n不过只有解法没有原因不是我们的风格。下面我们来分析产生这个问题的真正原因，首先，我们找到刚刚生成的 bundle.js 文件，因为这个文件是 Webpack 打包后的结果，所有的模块都应该在这个文件中出现。\n\n由于默认打包入口在 Webpack 输出的结果中就是第一个模块，所以我们只需要看第一个模块目前是什么样的，如下图所示：\n\n![](https://cdn.zce.me/assets/2f5fdeafddcc7e2e.png)\n\n仔细阅读这个文件，你会发现 css-loader 的作用是将 CSS 模块转换为一个 JS 模块，具体的实现方法是将我们的 CSS 代码 push 到一个数组中，这个数组是由 css-loader 内部的一个模块提供的，但是整个过程并没有任何地方使用到了这个数组。\n\n因此这里样式没有生效的原因是：**css-loader 只会把 CSS 模块加载到 JS 代码中，而并不会使用这个模块。**\n\n所以这里我们还需要在 css-loader 的基础上再使用一个 style-loader，把 css-loader 转换后的结果通过 style 标签追加到页面上。\n\n安装完 style-loader 之后，我们将配置文件中的 use 属性修改为一个数组，将 style-loader 也放进去。这里需要注意的是，一旦配置多个 Loader，执行顺序是从后往前执行的，所以这里一定要将 css-loader 放在最后，因为必须要 css-loader 先把 CSS 代码转换为 JS 模块，才可以正常打包，具体配置如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/main.css',\n  output: {\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        // 对同一个模块使用多个 loader，注意顺序\n        use: ['style-loader', 'css-loader']\n      }\n    ]\n  }\n}\n```\n\n配置完成之后，再次回到命令行重新打包，此时 bundle.js 文件中会额外多出两个模块。篇幅的关系，我们这里不再仔细解读。**style-loader 的作用总结一句话就是，将 css-loader 中所加载到的所有样式模块，通过创建 style 标签的方式添加到页面上**。\n\n以上就是我们对 Loader 使用的一些探索，Loader 是 Webpack 实现整个前端模块化的核心。因为只有通过不同的 Loader，Webpack 才可以实现任何类型资源的加载。\n\n#### 通过 JS 加载资源模块\n\n正如刚刚所提到的，一般 Webpack 打包的入口还是 JavaScript。因为从某种程度上来说，打包入口就是应用的运行入口，而目前前端应用中的业务是由 JS 驱动的，所以更合理的做法还是把 JS 文件作为打包的入口，然后在 JS 代码中通过 import 语句去加载 CSS 文件。\n\n```diff\n └─ 03-webpack-loader ······················· sample root dir\n    ├── src ································· source dir\n    │   ├── style.css ······················· style module\n+   │   └── main.js ························· entry module\n    ├── package.json ························ package file\n    └── webpack.config.js ··················· webpack config file\n```\n\n```javascript\n// ./src/main.js\nimport './style.css'\n// app logic...\nconsole.log('App starts running~')\n```\n\n![](https://cdn.zce.me/assets/3bc9030f4d12ee53.png)\n\n即便是通过 JS 代码去加载的 CSS 模块，css-loader 和 style-loader 仍然可以正常工作。因为 Webpack 在打包过程中会循环遍历每个模块，然后根据配置将每个遇到的模块交给对应的 Loader 去处理，最后再将处理完的结果打包到一起。\n\n#### 为什么要在 JS 中加载其他资源\n\n说到这里，你可能会产生疑惑：Webpack 为什么要在 JS 中载入 CSS 呢？不是应该将样式和行为分离么？\n\n其实 Webpack 不仅是建议我们在 JavaScript 中引入 CSS，还会建议我们在代码中引入当前业务所需要的任意资源文件。因为真正需要这个资源的并不是整个应用，而是你此时正在编写的代码。这就是 Webpack 的设计哲学。\n\n可能你乍一想好像不太容易理解，你可以做一个假设：假设我们在开发页面上的某个局部功能时，需要用到一个样式模块和一个图片文件。如果你还是将这些资源文件单独引入到 HTML 中，然后再到 JS 中添加对应的逻辑代码。试想一下，如果后期这个局部功能不用了，你就需要同时删除 JS 中的代码和 HTML 中的资源文件引入，也就是同时需要维护这两条线。而如果你遵照 Webpack 的这种设计，所有资源的加载都是由 JS 代码控制，后期也就只需要维护 JS 代码这一条线了。\n\n所以说，通过 JavaScript 代码去引入资源文件，或者说是建立 JavaScript 和资源文件的依赖关系，具有明显的优势。因为 JavaScript 代码本身负责完成整个应用的业务功能，放大来说就是驱动了整个前端应用，而 JavaScript 代码在实现业务功能的过程中需要用到样式、图片等资源文件。如果建立这种依赖关系：\n\n- 一来逻辑上比较合理，因为 JS 确实需要这些资源文件配合才能实现整体功能；\n- 二来配合 Webpack 这类工具的打包，能确保在上线时，资源不会缺失，而且都是必要的。\n\n最后说一句题外话，学习新事物不是说学会它的所有用法你就能提高，因为这些照着文档操作基本上谁都可以做到，很多时候它的思想才是突破点。能搞明白新事物为什么这样设计，基本上你就算出道了。\n\n至于其他常用的加载器，我们在理解了 Loader 的机制过后，你可以通过官方的文档自行尝试。这里我罗列了几个开发经常用到的加载器，如下表所示：\n\n| 名称 | 链接 |\n| :-- | :-- |\n| file-loader | [https://webpack.js.org/loaders/file-loader](https://webpack.js.org/loaders/file-loader) |\n| url-loader | [https://webpack.js.org/loaders/url-loader](https://webpack.js.org/loaders/url-loader) |\n| babel-loader | [https://webpack.js.org/loaders/babel-loader](https://webpack.js.org/loaders/babel-loader) |\n| style-loader | [https://webpack.js.org/loaders/style-loader](https://webpack.js.org/loaders/style-loader) |\n| css-loader | [https://webpack.js.org/loaders/css-loader](https://webpack.js.org/loaders/css-loader) |\n| sass-loader | [https://webpack.js.org/loaders/sass-loader](https://webpack.js.org/loaders/sass-loader) |\n| postcss-loader | [https://webpack.js.org/loaders/postcss-loader](https://webpack.js.org/loaders/postcss-loader) |\n| eslint-loader | [https://github.com/webpack-contrib/eslint-loader](https://github.com/webpack-contrib/eslint-loader) |\n| vue-loader | [https://github.com/vuejs/vue-loader](https://github.com/vuejs/vue-loader) |\n\n我每接触到一个新的加载器，核心就是搞明白这个 Loader 内部到底做了什么事情，它的目标是什么，其次才是这个 Loader 的配置用法。\n\n### 开发一个 Loader\n\nLoader 作为 Webpack 的核心机制，内部的工作原理却非常简单。接下来我们一起来开发一个自己的 Loader，通过这个开发过程再来深入了解 Loader 的工作原理。\n\n这里我的需求是开发一个可以加载 markdown 文件的加载器，以便可以在代码中直接导入 md 文件。我们都应该知道 markdown 一般是需要转换为 html 之后再呈现到页面上的，所以我希望导入 md 文件后，直接得到 markdown 转换后的 html 字符串，如下图所示：\n\n![](https://cdn.zce.me/assets/0bd9037f83ca14a2.png)\n\n由于这里需要直观地演示，我就不再单独创建一个 npm 模块，而是就直接在项目根目录下创建一个 markdown-loader.js 文件，完成后你可以把这个模块发布到 npm 上作为一个独立的模块使用。\n\n项目结构与核心代码如下所示：\n\n```diff\n └─ 03-webpack-loader ······················· sample root dir\n    ├── src ································· source dir\n    │   ├── about.md ························ markdown module\n    │   └── main.js ························· entry module\n    ├── package.json ························ package file\n+   ├── markdown-loader.js ·················· markdown loader\n    └── webpack.config.js ··················· webpack config file\n```\n\n```markdown\n<!-- ./src/about.md -->\n\n# About\n\nthis is a markdown file.\n```\n\n```javascript\n// ./src/main.js\nimport about from './about.md'\nconsole.log(about)\n// 希望 about => '<h1>About</h1><p>this is a markdown file.</p>'\n```\n\n每个 Webpack 的 Loader 都需要导出一个函数，这个函数就是我们这个 Loader 对资源的处理过程，它的输入就是加载到的资源文件内容，输出就是我们加工后的结果。我们通过 `source` 参数接收输入，通过返回值输出。这里我们先尝试打印一下 `source`，然后在函数的内部直接返回一个字符串 `'hello loader ~'`，具体代码如下所示：\n\n```javascript\n// ./markdown-loader.js\nmodule.exports = source => {\n  // 加载到的模块内容 => '# About\\n\\nthis is a markdown file.'\n  console.log(source)\n  // 返回值就是最终被打包的内容\n  return 'hello loader ~'\n}\n```\n\n完成以后，我们回到 Webpack 配置文件中添加一个加载器规则，这里匹配到的扩展名是 `.md`，使用的加载器就是我们刚刚编写的这个 markdown-loader.js 模块，具体代码如下所示：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.md$/,\n        // 直接使用相对路径\n        use: './markdown-loader'\n      }\n    ]\n  }\n}\n```\n\n> 💡：这里的 `use` 属性不仅可以使用模块名称，还可以使用模块文件路径，这点与 Node 中的 `require` 函数是一样的。\n\n配置完成后，我们再次打开命令行终端运行打包命令，如下图所示：\n\n![](https://cdn.zce.me/assets/70d71704fd039ad1.png)\n\n打包过程中命令行确实打印出来了我们所导入的 Markdown 文件内容，这就意味着 Loader 函数的参数确实是文件的内容。\n\n但同时也报出了一个解析错误，说的是：_You may need an additional loader to handle the result of these loaders.（我们可能还需要一个额外的加载器来处理当前加载器的结果）_。\n\n那这究竟是为什么呢？其实 Webpack 加载资源文件的过程类似于一个工作管道，你可以在这个过程中依次使用多个 Loader，但是最终这个管道结束过后的结果必须是一段标准的 JS 代码字符串。\n\n![](https://cdn.zce.me/assets/86a9b3c8f32d461e.png)\n\n所以我们这里才会出现上面提到的错误提示，那解决的办法也就很明显了：\n\n- **直接在这个 Loader 的最后返回一段 JS 代码字符串；**\n- **再找一个合适的加载器，在后面接着处理我们这里得到的结果。**\n\n先来尝试第一种办法。回到 markdown-loader 中，我们将返回的字符串内容修改为 `console.log('hello loader~')`，然后再次运行打包，此时 Webpack 就不再会报错了，代码如下所示：\n\n```javascript\n// ./markdown-loader.js\nmodule.exports = source => {\n  // 加载到的模块内容 => '# About\\n\\nthis is a markdown file.'\n  console.log(source)\n  // 返回值就是最终被打包的内容\n  // return 'hello loader ~'\n  return 'console.log(\"hello loader ~\")'\n}\n```\n\n那此时打包的结果是怎样的呢？我们打开输出的 bundle.js，找到最后一个模块（因为这个 md 文件是后引入的），如下图所示：\n\n![](https://cdn.zce.me/assets/fff9c1aa57e58a5f.png)\n\n这个模块里面非常简单，就是把我们刚刚返回的字符串直接拼接到了该模块中。这也解释了刚刚 Loader 管道最后必须返回 JS 代码的原因，因为如果随便返回一个内容，放到这里语法就不通过了。\n\n#### 实现 Loader 的逻辑\n\n了解了 Loader 大致的工作机制过后，我们再回到 markdown-loader.js 中，接着完成我的需求。这里需要安装一个能够将 Markdown 解析为 HTML 的模块，叫作 marked。\n\n安装完成后，我们在 markdown-loader.js 中导入这个模块，然后使用这个模块去解析我们的 source。这里解析完的结果就是一段 HTML 字符串，如果我们直接返回的话同样会面临 Webpack 无法解析模块的问题，正确的做法是把这段 HTML 字符串拼接为一段 JS 代码。\n\n此时我们希望返回的代码是通过 `module.exports` 导出这段 HTML 字符串，这样外界导入模块时就可以接收到这个 HTML 字符串了。如果只是简单地拼接，那 HTML 中的换行和引号就都可能会造成语法错误，所以我这里使用了一个小技巧，具体操作如下所示：\n\n```javascript\n// ./markdown-loader.js\nconst marked = require('marked')\n\nmodule.exports = source => {\n  // 1. 将 markdown 转换为 html 字符串\n  const html = marked(source)\n  // html => '<h1>About</h1><p>this is a markdown file.</p>'\n  // 2. 将 html 字符串拼接为一段导出字符串的 JS 代码\n  const code = `module.exports = ${JSON.stringify(html)}`\n  return code\n  // code => 'export default \"<h1>About</h1><p>this is a markdown file.</p>\"'\n}\n```\n\n先通过 `JSON.stringify()` 将字段字符串转换为标准的 JSON 字符串，然后再参与拼接，这样就不会有问题了。\n\n我们回到命令行再次运行打包，打包后的结果就是我们所需要的了。\n\n除了 `module.exports` 这种方式，Webpack 还允许我们在返回的代码中使用 ES Modules 的方式导出，例如，我们这里将 `module.exports` 修改为 `export default`，然后运行打包，结果同样是可以的，Webpack 内部会自动转换 ES Modules 代码。\n\n```javascript\n// ./markdown-loader.js\nconst marked = require('marked')\n\nmodule.exports = source => {\n  const html = marked(source)\n  // const code = `module.exports = ${JSON.stringify(html)}`\n  const code = `export default ${JSON.stringify(html)}`\n  return code\n}\n```\n\n#### 多个 Loader 的配合\n\n我们还可以尝试一下刚刚说的第二种思路，就是在我们这个 markdown-loader 中直接返回 HTML 字符串，然后交给下一个 Loader 处理。这就涉及多个 Loader 相互配合工作的情况了。\n\n我们回到代码中，这里我们直接返回 marked 解析后的 HTML，代码如下所示：\n\n```javascript\n// ./markdown-loader.js\nconst marked = require('marked')\n\nmodule.exports = source => {\n  // 1. 将 markdown 转换为 html 字符串\n  const html = marked(source)\n  return html\n}\n```\n\n然后我们再安装一个处理 HTML 的 Loader，叫作 html-loader，代码如下所示：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.md$/,\n        use: ['html-loader', './markdown-loader']\n      }\n    ]\n  }\n}\n```\n\n安装完成过后回到配置文件，这里同样把 `use` 属性修改为一个数组，以便依次使用多个 Loader。不过同样需要注意，这里的执行顺序是从后往前，也就是说我们应该把先执行的 markdown-loader 放在后面，html-loader 放在前面。\n\n完成以后我们回到命令行终端再次打包，这里的打包结果仍然是可以的。\n\n至此，我们就完成了这个 markdown-loader 模块，其实整个过程重点在于 Loader 的工作原理和实现方式。\n\n### 写在最后\n\n总体来说，Loader 机制是 Webpack 最核心的机制，因为正是有了 Loader 机制，Webpack 才能足以支撑整个前端项目模块化的大梁，实现通过 Webpack 去加载任何你想要加载的资源。\n\n换个角度来说，也正是有了 Loader 这种扩展机制，社区才能不断地为 Webpack 添砖加瓦，形成今天 Webpack 在前端工程化中不可撼动的地位。\n\n如果我们想要玩转 Webpack，就必须加深对 Loader 机制和原理的理解。我们这里只是抛砖引玉，也希望你可以通过更多的尝试继续探索。\n\n除此之外，我还想说一点：Webpack 中实现的这种 “万物皆模块” 的理念值得我们深入思考。因为它确实打破了“在页面中引入各种资源”的这种传统的固化思维，让我们可以在业务代码中载入所需的一切资源，在真正意义上让 JavaScript 驱动一切。如果你之前饱受资源维护的痛苦，那这种方式一定值得尝试。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n","cover":"https://cdn.zce.me/assets/313ffda17d9d7159.png","audio":"https://cdn.zce.me/audio/2020/04/webpack-03.mp3"},{"title":"如何使用 Webpack 实现模块化打包？","slug":"how-to-use-webpack-modular-package","date":1587229144000,"updated":1673100032073,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化"],"meta":{},"content":"\n你好，我是汪磊，今天我要跟你分享的内容是如何使用 Webpack 实现模块化打包？\n\n相信通过[上篇文章](/2020/04/what-problem-does-webpack-solve/)内容的学习，你应该对前端模块化有了更完整的认识。在[上篇文章](/2020/04/what-problem-does-webpack-solve/)的最后我们提出了对模块化打包方案或工具的设想或者说是诉求：\n\n- 能够将散落的模块打包到一起；\n- 能够编译代码中的新特性；\n- 能够支持不同种类的前端资源模块。\n\n![Webpack、Parcel 和 Rollup](https://cdn.zce.me/assets/caa52a23dd6d13da.png)\n\n目前，前端领域有一些工具能够很好的满足以上这 3 个需求，其中最为主流的就是 [Webpack](https://webpack.js.org/)、[Parcel](https://parceljs.org/) 和 [Rollup](https://rollupjs.org/)，我们以 Webpack 为例：\n\n- Webpack 作为一个模块打包工具，本身就可以实现模块化代码打包的问题，通过 Webpack 我们可以将零散的 JavaScript 代码打包到一个 JS 文件中。\n- 对于有环境兼容问题的代码，Webpack 可以在打包过程中通过 Loader 机制对其实现编译转换，然后再进行打包。\n- 对于不同类型的前端模块，Webpack 支持在 JavaScript 中以模块化的方式载入任意类型的资源文件，例如，我们可以通过 Webpack 实现在 JavaScript 中加载 CSS 文件，被加载的 CSS 文件将会通过 `style` 标签的方式工作。\n\n除此之外，Webpack 还具备代码拆分的能力，它能够将应用中所有的模块按照我们的需要分块打包。这样一来，就不用担心全部代码打包到一起，产生单个文件过大，导致加载慢的问题。我们可以把应用初次加载所必需的模块打包到一起，其他的模块再单独打包，等到应用工作过程中实际需要用到某个模块，再异步加载该模块，实现增量加载，或者叫作渐进式加载，非常适合现代化的大型 Web 应用。\n\n当然，除了 Webpack，其他的打包工具也都类似。总之，所有的打包工具都是以实现模块化为目标，让我们可以在开发阶段更好的享受模块化带来的优势，同时又不必担心模块化在生产环境中产生新的问题。\n\n### Webpack 快速上手\n\nWebpack 作为目前最主流的前端模块打包器，提供了一整套前端项目模块化方案，而不仅仅局限于对 JavaScript 的模块化。通过 Webpack，我们可以轻松实现对前端项目开发过程中涉及到的资源进行模块化。\n\n因为 Webpack 的设计思想比较先进，起初的使用过程比较烦琐，再加上文档也晦涩难懂，所以在最开始的时候，Webpack 对开发者并不友好，但是随着版本的迭代，官方文档的不断更新，目前 Webpack 对开发者已经非常友好了。此外，随着 React 和 Vue.js 这类框架的普及，Webpack 也随之受到了越来越多的关注，目前已经覆盖绝大多数现代 Web 应用的开发过程。\n\n接下来我将通过一个案例，带你快速了解 Webpack 的基本使用，具体操作如下所示：\n\n```diff\n└─ 02-configuation\n   ├── src\n   │   ├── heading.js\n   │   └── index.js\n   └── index.html\n```\n\n```javascript\n// ./src/heading.js\nexport default () => {\n  const element = document.createElement('h2')\n  element.textContent = 'Hello webpack'\n  element.addEventListener('click', () => alert('Hello webpack'))\n  return element\n}\n```\n\n```javascript\n// ./src/index.js\nimport createHeading from './heading.js'\nconst heading = createHeading()\ndocument.body.append(heading)\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Webpack - 快速上手</title>\n  </head>\n  <body>\n    <script type=\"module\" src=\"src/index.js\"></script>\n  </body>\n</html>\n```\n\n> P.S. `type=\"module\"` 这种用法是 ES Modules 中提出的标准，用来区分加载的是一个普通 JS 脚本还是一个模块。\n\n在上面这个案例中，我们创建了两个 JS 文件，其中 `heading.js` 中以 ES Modules 的方式导出了一个创建元素的函数，然后在 `index.js` 中导入 `heading.js` 并使用了这个模块，最后在 html 文件中通过 `script` 标签，以模块化的方式引入了 `index.js`。\n\n按照 ES Modules 的标准，这里的 html 文件可以直接在浏览器中正常工作，但是对于不支持 ES Modules 标准的浏览器，直接使用就会出现错误，所以我们需要使用 Webpack 这样的工具，将我们这里按照模块化方式拆分的 JS 代码再次打包到一起，避免因为 ES Modules 造成的兼容问题。\n\n接下来我们就尝试引入 Webpack 去处理上述案例中的 JS 模块打包。由于 Webpack 是一个 npm 工具模块，所以我们先初始化一个 package.json 文件，用来管理 npm 依赖版本，完成之后，再来安装 Webpack 的核心模块以及它的 CLI 模块，具体操作如下：\n\n```shell\n$ npm init --yes\n$ npm i webpack webpack-cli --save-dev\n```\n\n> P.S. webpack 是 Webpack 的核心模块，webpack-cli 是 Webpack 的 CLI 程序，用来在命令行中调用 Webpack。\n\n安装完成之后，webpack-cli 所提供的 CLI 程序就会出现在 `node_modules/.bin` 目录当中，我们可以通过 npx 快速找到 CLI 并运行它，具体操作如下：\n\n```shell\n$ npx webpack --version\nv4.42.1\n```\n\n> P.S. npx 是 npm 5.2 以后新增的一个命令，可以用来更方便的执行远程模块或者项目 node_modules 中的 CLI 程序。\n\n这里我们使用的 Webpack 版本是 v4.42.1，有了 Webpack 后，就可以直接运行 webpack 命令来打包 JS 模块代码，具体操作如下：\n\n```shell\n$ npx webpack\n```\n\n这个命令在执行的过程中，Webpack 默认会自动从 `src/index.js` 文件开始打包，然后根据代码中的模块导入操作，自动将所有用到的模块代码打包到一起，具体操作如下图所示：\n\n![Webpack 命令执行结果](https://cdn.zce.me/assets/0f5433b4d565f38c.png)\n\n完成之后，控制台会提示：顺着 index.js 有两个 JS 文件被打包到了一起。与之对应的就是项目的根目录下多出了一个 dist 目录，我们的打包结果就存放在这个目录下的 main.js 文件中。\n\n这里我们回到 `index.html` 中修改引入文件的路径，由于打包后的代码就不会再有 `import` 和 `export` 了，所以我们可以删除 `type=\"module\"`，以普通 JS 文件的方式引入。再次回到浏览器中，查看这个页面，这时我们的代码仍然可以正常工作，`index.html` 的代码如下所示：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Webpack - 快速上手</title>\n  </head>\n  <body>\n    <script src=\"dist/main.js\"></script>\n  </body>\n</html>\n```\n\n我们也可以将 Webpack 命令定义到 npm scripts 中，这样每次使用起来会更加方便，具体如下：\n\n```json\n{\n  \"name\": \"01-getting-started\",\n  \"version\": \"0.1.0\",\n  \"main\": \"n/a\",\n  \"author\": \"zce <w@zce.me> (https://zce.me)\",\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"build\": \"webpack\"\n  },\n  \"devDependencies\": {\n    \"webpack\": \"^4.42.1\",\n    \"webpack-cli\": \"^3.3.11\"\n  }\n}\n```\n\n对于 Webpack 最基本的使用，总结下来就是：先安装 webpack 相关的 npm 包，然后使用 webpack-cli 所提供的命令行工具进行打包。\n\n### 配置 Webpack 的打包过程\n\nWebpack 4 以后的版本支持零配置的方式直接启动打包，整个过程会按照约定将 `src/index.js` 作为打包入口，最终打包的结果会存放到 `dist/main.js` 中。\n\n但很多时候这些默认的规则并不能满足我们的需求，例如，在下面这个案例中，我需要它的打包入口是 `src/main.js`，那此时我们通过配置文件的方式修改 Webpack 的默认配置，在项目的根目录下添加一个 `webpack.config.js` 文件，具体结构如下：\n\n```diff\n └─ 02-configuation\n    ├── src\n    │ ├── heading.js\n    │ └── main.js\n    ├── index.html\n    ├── package.json\n+   └── webpack.config.js ···················· Webpack 配置文件\n```\n\n`webpack.config.js` 是一个运行在 Node.js 环境中的 JS 文件，也就是说我们需要按照 CommonJS 的方式编写代码，这个文件可以导出一个对象，我们可以通过所导出对象的属性完成相应的配置选项。\n\n这里先尝试添加一个 `entry` 属性，这个属性的作用就是指定 Webpack 打包的入口文件路径。我们将其设置为 `./src/main.js`，具体代码如下所示：\n\n```javascript\n// ./webpack.config.js\nmodule.exports = {\n  entry: './src/main.js' // 注意这里的 ./ 不能省略\n}\n```\n\n配置完成之后，回到命令行终端重新运行打包命令，此时 Webpack 就会从 `src/main.js` 文件开始打包。\n\n除了 `entry` 的配置以外，我们还可以通过 `output` 属性设置输出文件的位置。`output` 属性的值必须是一个对象，通过这个对象的 `filename` 指定输出文件的文件名称，`path` 指定输出的目录，具体代码如下所示：\n\n```javascript\n// ./webpack.config.js\nconst path = require('path')\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.join(__dirname, 'output')\n  }\n}\n```\n\n> 💡：因为 `webpack.config.js` 是运行在 Node.js 环境中，所以可以直接在这个文件中使用 `path` 之类的 Node.js 内置模块。\n\n由于 Webpack 支持的配置有很多，篇幅的关系，这里我们就不一一介绍了，详细的文档你可以在 Webpack 的官网中找到：[https://webpack.js.org/configuration/#options](https://webpack.js.org/configuration/#options)\n\n#### 让配置文件支持智能提示\n\n在这里，我想跟你分享我在编写 Webpack 配置文件时用过的一个小技巧。因为 Webpack 的配置项比较多，而且很多选项都支持不同类型的配置方式，如果你刚刚接触 Webpack 的配置，这些配置选项一定会让你感到头大。如果开发工具能够为 Webpack 配置文件提供智能提示的话，这种痛苦就会减小很多，配置起来，效率和准确度也会大大提高。\n\n我们知道， VSCode 对于代码的智能提示是根据成员的类型推断出来的，换句话说，如果 VSCode 知道当前变量的类型，就可以给出正确的智能提示。即便你没有使用 TypeScript 这种类型友好的语言，也可以通过类型注释的方式去标注变量的类型。\n\n默认 VSCode 并不知道 Webpack 配置对象的类型，我们通过 `import` 的方式导入 Webpack 模块中的 `Configuration` 类型，然后通过类型注释的方式将配置对象标注为这个类型，这样我们在编写这个对象的内部结构时，就可以有正确的智能提示了，具体代码如下所示：\n\n```javascript\n// ./webpack.config.js\nimport { Configuration } from 'webpack'\n\n/**\n * @type {Configuration}\n */\nconst config = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  }\n}\nmodule.exports = config\n```\n\n需要注意的是：我们添加的 `import` 语句只是为了导入 Webpack 配置对象的类型，这样做的目的是为了标注 `config` 对象的类型，从而实现智能提示，也就是说，这段代码是写给 VSCode 看的。在配置完成后一定要记得注释掉这段辅助代码，因为在 Node.js 环境中默认还不支持 `import` 语句，如果执行这段代码会就会出现语法错误。\n\n```javascript\n// ./webpack.config.js\n// 一定记得运行 Webpack 前先注释掉这里。\n// import { Configuration } from 'webpack'\n/**\n * @type {Configuration}\n */\nconst config = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  }\n}\nmodule.exports = config\n```\n\n没有智能提示的效果，如下所示：\n\n<video src=https://cdn.zce.me/assets/76c29277fdd8a6b1.mp4 muted autoplay playsinline loop></video>\n\n加上类型标注实现智能提示的效果，如下所示：\n\n<video src=https://cdn.zce.me/assets/feb67ce0c7fab79c.mp4 muted autoplay playsinline loop></video>\n\n使用 import 语句导入 `Configuration` 类型的方式固然好理解，但是在不同的环境中还是会有各种各样的问题，例如我们这里在 Node.js 环境中，就必须要额外注释掉这个导入类型的语句，才能正常工作。\n\n所以我一般的做法是直接在类型注释中使用 `import` 动态导入类型，具体代码如下：\n\n```javascript\n// ./webpack.config.js\n/** @type {import('webpack').Configuration} */\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  }\n}\n```\n\n这种方式同样也可以实现载入类型，而且相比于在代码中通过 `import` 语句导入类型更为方便，也更为合理。\n\n不过需要注意一点，这种导入类型的方式并不是 ES Modules 中的 [Dynamic Imports](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import#动态import)，而是 TypeScript 中提供特性。虽然我们这里只是一个 JavaScript 文件，但是在 VSCode 中的类型系统都是基于 TypeScript 的，所以可以直接按照这种方式使用，详细信息你可以参考这种 [import-types](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types) 的文档。\n\n其次，这种 `@type` 类型注释的方式是基于 [JSDoc](https://jsdoc.app) 实现的。JSDoc 中类型注释的用法还有很多，详细可以参考[官方文档中对 @type 标签的介绍](https://jsdoc.app/tags-type.html)。\n\n### Webpack 工作模式\n\nWebpack 4 新增了一个工作模式的用法，这种用法大大简化了 Webpack 配置的复杂程度。你可以把它理解为 Webpack 针对不同环境的三组预设配置：\n\n- `production` 模式下，启动内置优化插件，自动优化打包结果，打包速度偏慢；\n- `development` 模式下，自动优化打包速度，添加一些调试过程中的辅助插件以便于更好的调试错误；\n- `none` 模式下，运行最原始的打包，不做任何额外处理，这种模式一般需要分析我们模块的打包结果时会用到。\n\n针对工作模式的选项，如果你没有配置一个明确的值，打包过程中命令行终端会打印一个对应的配置警告。在这种情况下 Webpack 将默认使用 `production` 模式去工作。\n\n想要修改 Webpack 工作模式的方式有两种：\n\n- 通过 CLI `--mode` 参数传入；\n- 通过配置文件设置 `mode` 属性。\n\n上述三种 Webpack 工作模式的详细差异我们不再赘述了，你可以在[官方文档](https://webpack.js.org/configuration/mode/)中查看：[https://webpack.js.org/configuration/mode/](https://webpack.js.org/configuration/mode/)\n\n### 打包结果运行原理\n\n最后，我们来一起解读一下 Webpack 打包后生成的 bundle.js 文件，深入了解 Webpack 是如何把这些模块合并到一起，而且还能正常工作的。\n\n为了更好的理解打包后的代码，我们先将 Webpack 工作模式设置为 `none`，这样 Webpack 就会按照最原始的状态进行打包，所得到的结果更容易理解和阅读。\n\n按照 `none` 模式打包完成后，我们打开最终生成的 bundle.js 文件，如下图所示：\n\n![最终生成的 bundle.js 文件](https://cdn.zce.me/assets/fcedd1b42d08f9f0.png)\n\n我们可以先把代码全部折叠起来，以便于了解整体的结构，如下图所示：\n\n> 💡：\n>\n> - VSCode 中折叠代码的快捷键是 `Ctrl + K`，`Ctrl + 0`（macOS：`Command + K`，`Command + 0`）\n\n![折叠后的 bundle.js 文件](https://cdn.zce.me/assets/d348c3ef2e0777b9.png)\n\n整体生成的代码其实就是一个立即执行函数，这个函数是 Webpack 工作入口 `webpackBootstrap`，它接收一个 `modules` 参数，调用时传入了一个数组。\n\n展开这个数组，里面的元素均是参数列表相同的函数。这里的函数对应的就是我们源代码中的模块，也就是说每个模块最终被包裹到了这样一个函数中，从而实现模块私有作用域，如下图所示：\n\n![模块函数](https://cdn.zce.me/assets/d1f402102c1bdafb.png)\n\n我们再来展开 Webpack 工作入口函数，如下图所示：\n\n![工作入口函数结构](https://cdn.zce.me/assets/7f303096e1cb1a99.png)\n\n这个函数内部并不复杂，而且注释也很清晰，最开始定义了一个 `installedModules` 对象用于存放或者缓存加载过的模块。紧接着定义了一个 `require` 函数，顾名思义，这个函数是用来加载模块的。再往后就是在 `require` 函数上挂载了一些其他的数据和工具函数，这些暂时不用关心。\n\n在这个函数的最后，调用了 `require` 函数，传入的模块 `id` 为 `0`，开始加载模块。模块 `id` 实际上就是模块数组的元素下标，也就是说，从这里开始加载源代码中所谓的入口模块，如下图所示：\n\n![从这里开始加载源代码中所谓的入口模块](https://cdn.zce.me/assets/3d05b4b3ba6145c6.png)\n\n为了更好的理解 bundle.js 的执行过程，你可以把它运行到浏览器中，然后通过 Chrome 的 Devtools 单步调试一下。调试过程我单独录制了一个视频，如下所示：\n\n<iframe src=\"//player.bilibili.com/player.html?aid=712514148&bvid=BV1uD4y197fc&cid=247327768&page=1\" width=\"800\" height=\"500\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe>\n\n### 写在最后\n\n整体上对于 Webpack 的基本使用其实并不复杂，特别是在 Webpack 4 以后，很多配置都已经被简化了，在这种配置并不复杂的前提下，开发人员对它的掌握程度主要就体现在了是否能够理解它的工作机制和原理上了。\n\n就拿 Webpack 打包过后的结果来说，大多数的开发者其实根本不会关心它内部的结构是怎样的，又是如何运行起来的，总觉得不需要关心，但是当这种“不用关心”的事情越积越多，整个开发过程不可控的点也会随之增多，当出现问题时，也就很难定位问题的根源了。\n\n其实通过我们的探索你会发现，当你打开“黑盒子”后，里面的东西并没有想象的那么复杂。很多时候你离“成功”就只有一步之遥，而驱使你走向“成功”的其实是你的好奇心。在我看来，好奇心应该是一个优秀开发者的基本素质，对待未知的好奇就是我们进步的源泉，与君共勉。\n\n最后我来总结一下今天的重点，你也可以通过这几个重点反思一下掌握与否：\n\n1. Webpack 是如何满足模块化打包需求的。\n2. Webpack 打包的配置方式以及一个可以实现配置文件智能提示的小技巧。\n3. Webpack 工作模式特性的作用。\n4. 通过 Webpack 打包后的结果是如何运行起来的？\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n","cover":"https://cdn.zce.me/assets/4aeb6becda568de4.png","audio":"https://cdn.zce.me/audio/2020/04/webpack-02.mp3"},{"title":"Webpack 究竟解决了什么问题","slug":"what-problem-does-webpack-solve","date":1587137815000,"updated":1673100032061,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化"],"meta":{},"content":"\n你好，我是汪磊，今天我要跟你分享的内容是 Webpack 背后的模块化以及它的发展过程。\n\n正如[开篇](/2020/04/webpack-the-cornerstone-of-modern-app/)中所描述的，Webpack 最初的目标就是实现前端项目的模块化，也就是说它所解决的问题是**如何在前端项目中更高效地管理和维护项目中的每一个资源**。\n\n所以如果你想要搞明白 Webpack ，就必须先对它想要解决的问题或者目标有一个充分的认识，带着问题再去理解它的很多特性，学习思路会更清晰，理解也会更深刻。\n\n在这一章中，我将带你简单了解前端模块化的发展史，以及这个过程中所出现的一些标准规范。有句话叫作：读史使人明智，希望通过学习本章的内容，能够为你在 Webpack 的理解上带来新的启示。\n\n### 模块化的演进过程\n\n随着互联网的深入发展，前端技术标准发生了巨大的变化。早期的前端技术标准根本没有预料到前端行业会有今天这个规模，所以在设计上存在很多缺陷，导致我们现在去实现前端模块化时会遇到诸多问题。虽然说，如今绝大部分问题都已经被一些标准或者工具解决了，但在这个演进过程中依然有很多东西值得我们思考和学习，所以接下来我想先介绍一下前端方向落实模块化的几个代表阶段。\n\n#### Stage 1 - 文件划分方式\n\n最早我们会基于文件划分的方式实现模块化，也就是 Web 最原始的模块系统。具体做法是将每个功能及其相关状态数据各自单独放到不同的 JS 文件中，约定每个文件是一个独立的模块。使用某个模块将这个模块引入到页面中，一个 `script` 标签对应一个模块，然后直接调用模块中的成员（变量 / 函数）。\n\n```text\n└─ stage-1\n   ├── module-a.js\n   ├── module-b.js\n   └── index.html\n```\n\n```javascript\n// module-a.js\nfunction foo() {\n  console.log('moduleA#foo')\n}\n```\n\n```javascript\n// module-b.js\nvar data = 'something'\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Stage 1</title>\n  </head>\n  <body>\n    <script src=\"module-a.js\"></script>\n    <script src=\"module-b.js\"></script>\n    <script>\n      // 直接使用全局成员\n      foo() // 可能存在命名冲突\n      console.log(data)\n      data = 'other' // 数据可能会被修改\n    </script>\n  </body>\n</html>\n```\n\n缺点：\n\n- 模块直接在全局工作，大量模块成员污染全局作用域；\n- 没有私有空间，所有模块内的成员都可以在模块外部被访问或者修改；\n- 一旦模块增多，容易产生命名冲突；\n- 无法管理模块与模块之间的依赖关系；\n- 在维护的过程中也很难分辨每个成员所属的模块；\n\n总之，这种原始“模块化”的实现方式完全依靠约定实现，一旦项目规模变大，这种约定就会暴露出种种问题，非常不可靠，所以我们需要尽可能解决这个过程中暴露出来的问题。\n\n#### Stage 2 – 命名空间方式\n\n后来，我们约定每个模块只暴露一个全局对象，所有模块成员都挂载到这个全局对象中，具体做法是在第一阶段的基础上，通过将每个模块“包裹”为一个全局对象的形式实现，这种方式就好像是为模块内的成员添加了“命名空间”，所以我们又称之为命名空间方式。\n\n```javascript\n// module-a.js\nwindow.moduleA = {\n  method1: function () {\n    console.log('moduleA#method1')\n  }\n}\n```\n\n```javascript\n// module-b.js\nwindow.moduleB = {\n  data: 'something',\n  method1: function () {\n    console.log('moduleB#method1')\n  }\n}\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Stage 2</title>\n  </head>\n  <body>\n    <script src=\"module-a.js\"></script>\n    <script src=\"module-b.js\"></script>\n    <script>\n      moduleA.method1()\n      moduleB.method1()\n      // 模块成员依然可以被修改\n      moduleA.data = 'foo'\n    </script>\n  </body>\n</html>\n```\n\n这种命名空间的方式只是解决了命名冲突的问题，但是其它问题依旧存在。\n\n#### Stage 3 – IIFE\n\n使用立即执行函数表达式（IIFE，Immediately-Invoked Function Expression）为模块提供私有空间。具体做法是将每个模块成员都放在一个立即执行函数所形成的私有作用域中，对于需要暴露给外部的成员，通过挂到全局对象上的方式实现。\n\n```javascript\n// module-a.js\n;(function () {\n  var name = 'module-a'\n\n  function method1() {\n    console.log(name + '#method1')\n  }\n\n  window.moduleA = {\n    method1: method1\n  }\n})()\n```\n\n```javascript\n// module-b.js\n;(function () {\n  var name = 'module-b'\n\n  function method1() {\n    console.log(name + '#method1')\n  }\n\n  window.moduleB = {\n    method1: method1\n  }\n})()\n```\n\n这种方式带来了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问，这就解决了前面所提到的全局作用域污染和命名冲突的问题。\n\n#### Stage 4 - IIFE 依赖参数\n\n在 IIFE 的基础之上，我们还可以利用 IIFE 参数作为依赖声明使用，这使得每一个模块之间的依赖关系变得更加明显。\n\n```javascript\n// module-a.js\n;(function ($) {\n  // 通过参数明显表明这个模块的依赖\n  var name = 'module-a'\n\n  function method1() {\n    console.log(name + '#method1')\n    $('body').animate({ margin: '200px' })\n  }\n\n  window.moduleA = {\n    method1: method1\n  }\n})(jQuery)\n```\n\n### 模块加载的问题\n\n以上 4 个阶段是早期的开发者在没有工具和规范的情况下对模块化的落地方式，这些方式确实解决了很多在前端领域实现模块化的问题，但是仍然存在一些没有解决的问题。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Evolution</title>\n  </head>\n  <body>\n    <script src=\"https://unpkg.com/jquery\"></script>\n    <script src=\"module-a.js\"></script>\n    <script src=\"module-b.js\"></script>\n    <script>\n      moduleA.method1()\n      moduleB.method1()\n    </script>\n  </body>\n</html>\n```\n\n最明显的问题就是：模块的加载。在这几种方式中虽然都解决了模块代码的组织问题，但模块加载的问题却被忽略了，我们都是通过 `script` 标签的方式直接在页面中引入的这些模块，这意味着模块的加载并不受代码的控制，时间久了维护起来会十分麻烦。试想一下，如果你的代码需要用到某个模块，如果 HTML 中忘记引入这个模块，又或是代码中移除了某个模块的使用，而 HTML 还忘记删除该模块的引用，都会引起很多问题和不必要的麻烦。\n\n更为理想的方式应该是在页面中引入一个 JS 入口文件，其余用到的模块可以通过代码控制，按需加载进来。\n\n### 模块化规范的出现\n\n除了模块加载的问题以外，目前这几种通过约定实现模块化的方式，不同的开发者在实施的过程中会出现一些细微的差别，因此，为了统一不同开发者、不同项目之间的差异，我们就需要制定一个行业标准去规范模块化的实现方式。\n\n再接合我们刚刚提到的模块加载的问题，我们现在的需求就是两点：\n\n- 一个统一的模块化标准规范；\n- 一个可以自动加载模块的基础库。\n\n提到模块化规范，你可能会想到 CommonJS 规范，它是 Node.js 中所遵循的模块规范，该规范约定，一个文件就是一个模块，每个模块都有单独的作用域，通过 `module.exports` 导出成员，再通过 `require` 函数载入模块。现如今的前端开发者应该对其有所了解，但是如果我们想要在浏览器端直接使用这个规范，那就会出现一些新的问题。\n\n如果你对 Node.js 的模块加载机制有所了解，那么你应该知道，CommonJS 约定的是以同步的方式加载模块，因为 Node.js 执行机制是在启动时加载模块，执行过程中只是使用模块，所以这种方式不会有问题。但是如果要在浏览器端使用同步的加载模式，就会引起大量的同步模式请求，导致应用运行效率低下。\n\n所以在早期制定前端模块化标准时，并没有直接选择 CommonJS 规范，而是专门为浏览器端重新设计了一个规范，叫作 AMD （ Asynchronous Module Definition） 规范，即异步模块定义规范。同期还推出了一个非常出名的库，叫作 Require.js，它除了实现了 AMD 模块化规范，本身也是一个非常强大的模块加载器。\n\n在 AMD 规范中约定每个模块通过 `define()` 函数定义，这个函数默认可以接收两个参数，第一个参数是一个数组，用于声明此模块的依赖项；第二个参数是一个函数，参数与前面的依赖项一一对应，每一项分别对应依赖项模块的导出成员，这个函数的作用就是为当前模块提供一个私有空间。如果在当前模块中需要向外部导出成员，可以通过 `return` 的方式实现。\n\n![](https://cdn.zce.me/assets/fa8015607e1cadee.png)\n\n除此之外，Require.js 还提供了一个 `require()` 函数用于自动加载模块，用法与 `define()` 函数类似，区别在于 `require()` 只能用来载入模块，而 `define()` 还可以定义模块。当 Require.js 需要加载一个模块时，内部就会自动创建 `script` 标签去请求并执行相应模块的代码。\n\n![](https://cdn.zce.me/assets/178af76a93535bd9.png)\n\n目前绝大多数第三方库都支持 AMD 规范，但是它使用起来相对复杂，而且当项目中模块划分过于细致时，就会出现同一个页面对 JS 文件的请求次数过多的情况，从而导致效率降低。在当时的环境背景下，AMD 规范为前端模块化提供了一个标准，但这只是一种妥协的实现方式，并不能成为最终的解决方案。\n\n同期出现的规范还有淘宝的 Sea.js，只不过它实现的是另外一个标准，叫作 CMD，这个标准类似于 CommonJS，在使用上基本和 Require.js 相同，可以算上是重复的轮子。但随着前端技术的发展，Sea.js 后来也被 Require.js 兼容了。如果你感兴趣可以课后了解一下 [Seajs 官网](https://seajs.github.io/seajs/docs/)。\n\n![](https://cdn.zce.me/assets/e745578c983171c5.png)\n\n### 模块化的标准规范\n\n尽管上面介绍的这些方式和标准都已经实现了模块化，但是都仍然存在一些让开发者难以接受的问题。\n\n随着技术的发展，JavaScript 的标准逐渐走向完善，可以说，如今的前端模块化已经发展得非常成熟了，而且对前端模块化规范的最佳实践方式也基本实现了统一。\n\n- 在 Node.js 环境中，我们遵循 CommonJS 规范来组织模块。\n- 在浏览器环境中，我们遵循 ES Modules 规范。\n\n![](https://cdn.zce.me/assets/fef958ba9b5b47ca.png)\n\n而且在最新的 Node.js 提案中表示，Node 环境也会逐渐趋向于 ES Modules 规范，也就是说作为现阶段的前端开发者，应该重点掌握 ES Modules 规范。\n\n因为 CommonJS 属于内置模块系统，所以在 Node.js 环境中使用时不存在环境支持问题，只需要直接遵循标准使用 `require` 和 `module.exports` 即可。\n\n但是对于 ES Modules 规范来说，情况会相对复杂一些。我们知道 ES Modules 是 ECMAScript 2015（ES6）中才定义的模块系统，也就是说它是近几年才制定的标准，所以肯定会存在环境兼容的问题。在这个标准刚推出的时候，几乎所有主流的浏览器都不支持。但是随着 Webpack 等一系列打包工具的流行，这一规范才开始逐渐被普及。\n\n经过 5 年的迭代， ES Modules 已发展成为现今最主流的前端模块化标准。相比于 AMD 这种社区提出的开发规范，ES Modules 是在语言层面实现的模块化，因此它的标准更为完善也更为合理。而且目前绝大多数浏览器都已经开始能够原生支持 ES Modules 这个特性了，所以说在未来几年，它还会有更好的发展，短期内应该不会有新的轮子出现了。\n\n综上所述，如何在不同的环境中去更好的使用 ES Modules 将是你需要重点考虑的问题。\n\n### ES Modules 特性\n\n那对于 ES Modules 的学习，可以从两个维度入手。首先，你需要了解它作为一个规范或者说标准，到底约定了哪些特性和语法；其次，你需要学习如何通过一些工具和方案去解决运行环境兼容带来的问题。\n\n![](https://cdn.zce.me/assets/c3a9c01e73cbdf08.png)\n\n针对 ES Modules 本身的一些特性本章不做赘述，你可以参考：\n\n- [MDN 官方的详细资料](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)\n- [ECMAScript 官方详细资料](http://www.ecma-international.org/ecma-262/6.0/#sec-modules)\n\n### 模块打包工具的出现\n\n模块化可以帮助我们更好地解决复杂应用开发过程中的代码组织问题，但是随着模块化思想的引入，我们的前端应用又会产生了一些新的问题，比如：\n\n- 首先，我们所使用的 ES Modules 模块系统本身就存在环境兼容问题。尽管现如今主流浏览器的最新版本都支持这一特性，但是目前还无法保证用户的浏览器使用情况。所以我们还需要解决兼容问题。\n- 其次，模块化的方式划分出来的模块文件过多，而前端应用又运行在浏览器中，每一个文件都需要单独从服务器请求回来。零散的模块文件必然会导致浏览器的频繁发送网络请求，影响应用的工作效率。\n- 最后，谈一下在实现 JS 模块化的基础上的发散。随着应用日益复杂，在前端应用开发过程中不仅仅只有 JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题。而且从宏观角度来看，这些文件也都应该看作前端应用中的一个模块，只不过这些模块的种类和用途跟 JavaScript 不同。\n\n对于开发过程而言，模块化肯定是必要的，所以我们需要在前面所说的模块化实现的基础之上引入更好的方案或者工具，去解决上面提出的 3 个问题，让我们的应用在开发阶段继续享受模块化带来的优势，又不必担心模块化对生产环境所产生的影响。\n\n接下来我们先对这个更好的方案或者工具提出一些设想：\n\n- 第一，它需要具备编译代码的能力，也就是将我们开发阶段编写的那些包含新特性的代码转换为能够兼容大多数环境的代码，解决我们所面临的环境兼容问题。\n\n  ![](https://cdn.zce.me/assets/57b1dfd6db1432a8.png)\n\n- 第二，能够将散落的模块再打包到一起，这样就解决了浏览器频繁请求模块文件的问题。这里需要注意，只是在开发阶段才需要模块化的文件划分，因为它能够帮我们更好地组织代码，到了实际运行阶段，这种划分就没有必要了。\n\n  ![](https://cdn.zce.me/assets/d8b647a70d672cd0.png)\n\n- 第三，它需要支持不同种类的前端模块类型，也就是说可以将开发过程中涉及的样式、图片、字体等所有资源文件都作为模块使用，这样我们就拥有了一个统一的模块化方案，所有资源文件的加载都可以通过代码控制，与业务代码统一维护，更为合理。\n\n  ![](https://cdn.zce.me/assets/19a5fbffe01d5bc2.png)\n\n针对上面第一、第二个设想，我们可以借助 Gulp 之类的构建系统配合一些编译工具和插件去实现，但是对于第三个可以对不同种类资源进行模块化的设想，就很难通过这种方式去解决了，所以就有了我们接下来要介绍的主题：前端模块打包工具。\n\n### 写在最后\n\n本章重点介绍了前端模块化的发展过程和最终的统一的 ES Modules 标准，这些都是我们深入学习 Webpack 前必须要掌握的内容，同时也是现代前端开发者必不可少的基础储备，请你务必要掌握。\n\n学到这里，你可能会有这样的疑问，本章的内容是否偏离了主题？但其实我想传达的思想是，虽然 Webpack 发展到今天，它的功能已经非常强大了，但依然改变不了它是一个模块化解决方案的初衷。你可以看到， Webpack 官方的 Slogan 仍然是：_A bundler for javascript and friends（一个 JavaScript 和周边的打包工具）_。\n\n从另外一个角度来看，Webpack 从一个“打包工具”，发展成现在开发者眼中对整个前端项目的“构建系统”，表面上似乎只是称呼发生了变化，但是这背后却透露出来一个信号：模块化思想是非常伟大的，伟大到可以帮你“统治”前端整个项目。这也足以见得模块化思想背后还有很多值得我们思考的内容。\n\n总的来说，我们可以把 Webpack 看作现代化前端应用的“管家”，这个“管家”所践行的核心理论就是“模块化”，也就是说**Webpack 以模块化思想为核心，帮助开发者更好的管理整个前端工程。**\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n\n> Photo by [Simon Goetz](https://unsplash.com/@slgoetz) on [Unsplash](https://unsplash.com)\n","cover":"https://cdn.zce.me/assets/b3b5e4b904716c86.jpg","audio":"https://cdn.zce.me/audio/2020/04/webpack-01.mp3"},{"title":"Webpack：现代化前端应用的基石","slug":"webpack-the-cornerstone-of-modern-app","date":1587048085000,"updated":1673100032053,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Webpack","工程化","模块化"],"meta":{},"content":"\n经过最近几年的爆炸式发展，前端已经绝不再是简简单单的页面开发了，从早期只是配合后端“切图”，到现在已经能够独立驱动整个业务，这背后就需要引入更多的思想、框架和工具。比如：\n\n- 现阶段的大型应用就要求前端必须要有独立的项目，独立的项目想要有足够的效率就必须进行工程化。\n- 具有复杂数据状态的应用开发过程就必须要有合适的框架，采用数据驱动开发的方式增强可维护性。\n- 复杂项目结构必须进行模块化管理，一来提高部分公共内容的可复用性，二来增强团队并行协作能力。\n- 重复规律性的工作必须采用自动化工具实现，一来提高效率，二来避免人为出错。\n\n这里的大多数问题现如今都有很成熟的解法，那我今天要跟你分享的主题就是其中最具有代表性的 Webpack。因为想要在现代化前端开发工作中有足够的开发效率，你一定离不开 Webpack 相关技术栈，不管是对于项目代码的模块化，还是一些规律性的重复工作，甚至是整个前端项目的工程化，Webpack 都能够帮你轻松搞定。\n\n### 提升前端生产力的利器\n\n我个人觉得 **Webpack 应该是现代化前端开发的基石，也是目前前端生产力的代名词**。\n\n当然在日常工作中，确实有奉行“够用就行”工作态度的开发者，但我认为这是他们还没有意识到这些新技术新方案可能带来的成效。\n\n最近正在招募一个前端研发团队，看了很多简历，也面试了很多前端开发者，发现基本上每一个人的简历上都洋洋洒洒写着 Vue.js、React 这样的主流框架，但是一旦问及使用这类框架进行开发时用到的一些基础设施，却开始支支吾吾，甚至直接表示：“_我只要用官方 CLI 就好了啊_”。\n\n确实，这些框架的官方推出这种高度集成的 CLI 工具，目的就是降低开发者的使用成本，但是对于一个优秀的开发人员而言，只会使用这种“黑盒工具”是远远不够的，因为这种“黑盒工具”大多数采用的都是通用的配置，而优秀的开发人员应该学会“因地制宜”，根据实际情况更灵活地去使用每一个工具。\n\n当然，仔细想想，这个问题也好理解，毕竟很多前端开发者都是在这些框架和工具的成熟期（2017 年以后）才进入的这个行业，所以对它们背后的事情自然是要陌生一些。而我有幸经历了整个前端工程化工具生态的发展过程，加上在这之前很长的开发经历，所以对这个过程中诞生的工具和思想自然会理解地更为深刻。\n\n我深知这些内容对你日常开发工作中解决问题能力的影响，很多开发者在日常工作中遇到问题不能快速地定位和解决，就是因为缺乏对这种底层或者基础的足够了解。因此，很多时候我会把对 Webpack 这类工具的认知程度，当作辨别开发人员优秀与否的分水岭。\n\n### Webpack 与模块化开发\n\n那说到 Webpack，就不得不提模块化开发，因为 Webpack 最早的出发点就是去实践前端方向的模块化开发。想要搞明白 Webpack，就先得搞明白它所要解决的问题，所以我这里先唠叨两句模块化的事情。\n\n**模块化，可以说是当下最重要的前端开发范式之一**。随着前端应用的日益复杂化，我们的项目已经逐渐膨胀到了不得不花大量时间去管理的程度。而模块化就是一种最主流的项目组织方式，它通过把复杂的代码按照功能划分为不同的模块单独维护，从而提高开发效率、降低维护成本。\n\n<video src=https://cdn.zce.me/assets/507ce52d89c7025e.mp4 muted autoplay playsinline loop></video>\n\n但是“模块化”，本身仅仅是一个思想或者说是一个理论，并不包含具体的实现。所以接下来，我们会一起学习如何使用 Webpack 在前端项目中实践模块化思想，以及目前行业中其他的一些优秀方案。\n\n可能你会问：Webpack 不应该是一个构建工具么？怎么还扯上了这么多东西？这也是目前绝大多数前端开发者都会有的疑问。你如果会有这种疑问，一多半还是因为你还不够了解 Webpack，或者所了解的内容还停留在表象层面。毕竟，Webpack 太强大了，强大到很容易让你忽略了它的本质。\n\nWebpack 本质上仍然还是一个模块化打包工具，它通过“万物皆模块”这种设计思想，巧妙地实现了整个前端项目的模块化。在 Webpack 的理念中，前端项目中的任何资源都可以作为一个模块，任何模块都可以经过 Loader 机制的处理，最终再被打包到一起。\n\nWebpack 本身的架构中有两个很核心的特性，分别是 Loader 机制和插件机制。正是因为它的插件机制形成了非常繁荣的生态，所以造就了它现在“无所不能”的现状，所以让 Webpack 慢慢发展成了现在很多前端开发者眼中的构建系统。\n\n### 我是如何设计这个系列的？\n\n如果你现在每天都只是在使用 Vue CLI 或者 create-react-app 这样高度集成的 CLI，面对特殊资源加载、打包过程优化、资源代码分块、Tree-shaking 这样相对复杂的需求无从下手；又或是你初入前端行业，只有一些简单的前端开发经验，我都诚意推荐你跟着这个系列好好学习一下 Webpack 以及对前端模块的实践，这对你日后掌握 React 和 Vue.js 这类框架的高级用法非常有帮助。\n\n这个系列文章整体基于 Webpack 最新的 `v4.42.1` 版本展开（尽管现在已经有新版本出现，但是这也不妨碍你理解我想要表达的内容），按照我一贯深入浅出、全面体系化的风格进行介绍，内容主要分为 4 个模块：\n\n- **Webpack 背景介绍**：包括模块化所解决的问题、模块化标准的演进过程、ES Modules 标准规范。希望你通过这个模块，能够了解 Webpack 这类工具解决的到底是什么问题。\n- **Webpack 核心特性**：包括基本特性、配置方式、工作模式、基本工作原理、Loader 机制、插件机制。希望你学习完这个模块，能够完全掌握 Webpack 的基本使用，理解 Webpack 打包过程和打包结果的工作原理，同时也能够自己开发 Webpack 的 Loader 和插件。\n- **Webpack 高阶内容**：包括 Source Map、模块热替换（HMR）机制、Proxy、Webpack Dev Server 等周边技能的使用，以及 Tree-shaking、sideEffects、Code Spliting 等高级特性的实践，再有就是常用优化插件、三种 hash 的最佳实践、打包速度优化，以更于你能更熟练地使用 Webpack 的高级特性，为开发效率添砖加瓦。\n- **其他同类优秀方案**：Rollup、Parcel。希望通过这个模块的介绍，让你能够了解到一些 Webpack 同类的优秀方案，以及它们设计上的不同，这些都能够让你在工作中应对不同的项目、不同的需求时可以有更多的选择。\n\n这个系列对你的知识储备要求不会太高，主要就是掌握 JavaScript 编程，了解一些 Node.js 基础，当然最好还能了解一些 React、Vue.js 之类应用型框架的基本使用，这样可以帮助你更快速地定位我所描述的一些问题场景。\n\n### 写作最后\n\n最后，我还是想再次强调一个点：一个合格的前端开发者必须夯实基础，深入地理解所使用的技术，而不是浮于表面，保持“够用就行”的技术认知；在这之后，才是去丰富自己的技术栈。就好像我们经常说的，马步扎不稳，学会再多的招数也只是花拳绣腿。\n\n相信经过这个系列文章的分享，你一定可以更深度、更全面地认识 Webpack，建立对 Webpack 整体的知识体系，掌握自定义和扩展 Webpack 的方法和技巧，更高效地使用 Webpack 解决实际项目开发中的需求和问题。\n\n此外，我也希望我在文中所提出的一些问题和思考能够引起你的注意，因为设计的动机和思想才是学习每一个技术的关键所在：只掌握技术的使用，你的理解可能只能达到 6 ～ 7 成；只有真正搞明白新事物为什么这么设计，才能做到一通百通。这也正是近几年，技术圈很多人经常吐槽“学不动了”的根本原因。\n\n正所谓“悟则通，通则达”，单纯地学习前人的做法而不去思考为什么，你就永远只能做最“累”的人。特别是在技术日新月异的时代，所有人都在持续学习，只有掌握核心精髓，更快更忧，你才能跑得最远。\n\n好的学习，需要实践，也需要沟通和反馈，欢迎你在留言区给我分享你的学习感悟，以及成长过程中的经验与成就。\n\n以上就是今天全部的内容，我是汪磊，我们下期再见 👋\n","cover":"https://cdn.zce.me/assets/de3fbc9cf98c62d8.png","audio":"https://cdn.zce.me/audio/2020/04/webpack-00.mp3"},{"title":"快乐成长，活出生命","slug":"enjoy-yourself","date":1582362780000,"updated":1673100032053,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["日志"],"tags":[],"meta":{},"content":"\n我的小少爷，今天是你的 3 岁生日，爸爸在北京祝你生日快乐。特殊时期，爸爸不在你身边，希望你能够健健康康、快乐成长。享受生命，不管别的，开心就够了～\n","cover":"https://cdn.zce.me/assets/9df9af65cb82bf0f.jpg"},{"title":"大时代小访客","slug":"big-time-small-visitors","date":1578909540000,"updated":1673100032053,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["日志"],"tags":[],"meta":{},"content":"\n昨晚在爱奇艺上线了《爱情公寓》系列的最终季，我看了三集。由于本身并没有抱着太高的要求，所以整体感觉还不错。\n\n不过不得不说第一集的时候明显感觉大家都没太进入「状态」，整体局面略显尴尬。特别是新加入的「咖喱酱」同学的第一场戏，确实并没有多出彩。\n\n就目前我个人的感觉来说，编剧可能是为了卸下来之前主演身上的人设包袱，从而给观众一个更美好的交代，否则两对 CP 应该是不会这么就结婚的。至于卸下来的包袱就必须得有人来承担，于是乎就有了这三个新成员：诸葛大力、赵海堂和咖喱酱。其实用心观察你很容易能够发现，这三个人设其实都可以看到之前出现在主角身上的一些特点。\n\n这些并不关键，毕竟这种类型的电视剧就是填补生活的空白，娱乐大众罢了。只是在还没上线之前，包括上线之后，网络上大量的吐槽让我感觉不太舒服。\n\n其中最主要的吐槽无外乎「没得抄了」。关于这一点，我想说的是现在的人好像都陷入了一种不「喷」不显能耐的状态，甚至还有很多人花了大量时间去收集所谓的「证据」。有这个时间去做一些有价值的事情不好么。一个娱乐化的东西，需要这么较真么？如果你真的非得较这个真，那我想问，我们从小到大，看的每一本书、每一部电影，听的每一首歌，都是正版了么？我们有尊重原著、尊重作者了么？我们生活中存在的抄袭还少么？为什么在自己身上就是「正常」，在别人或者社会上出现就是「丑陋」的呢？\n\n其实很多时候并不是事物本身发生了变化，更多的可能是我们自身看待事物的眼光发生了变化，又或是自身就发生了变化。总而言之，时刻保持清醒，是在这个信息泛滥的时代的立足的根本。人云亦云太可怕，毕竟大多数人都是是因为网络才知道的这些负面消息。\n\n> 对事情 对世界 对别人，轻松些 放开些，笑的一定是我\n>\n> —— 《大时代小访客》\n\n最后，希望大家善待网络、善待自己。\n","cover":"https://cdn.zce.me/assets/6168d5be76610abd.jpg"},{"title":"2020 重新启航","slug":"2020-sail-again","date":1577837880000,"updated":1673100032049,"sections":[],"draft":false,"featured":true,"comment":false,"authors":[],"categories":["日志"],"tags":[],"meta":{},"content":"\n再见 2019，你好 2020。\n\n2020 一切归零，重新起航。\n\n注定我们的 2020 年将是非常特殊的一年。\n\n即便是诸多不顺，但是我相信一切终将安好，归于平静。\n\n> Photo by [Denise Karis](https://unsplash.com/@photostuff) on [Unsplash](https://unsplash.com)\n","cover":"https://cdn.zce.me/assets/067d85f533088f0a.jpg"},{"title":"发现生活中的美好","slug":"beauty-of-life","date":1577755080000,"updated":1673100032049,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["旅行"],"tags":[],"meta":{},"content":"\n<!-- TODO: -->\n","cover":"https://cdn.zce.me/assets/cc9c60be09ff5ad1.jpg"},{"title":"前端工程化 - 脚手架工具","slug":"frontend-engineering-scaffolding","date":1566416069000,"updated":1673100032045,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["工程化"],"meta":{},"content":"\n在对前端工程化的整体有了初步的认识之后，我们顺着一个项目的开发过程，先从脚手架开始，探讨前端工程化在项目创建环节中的具体表现。\n\n脚手架可以简单理解为用来自动帮我们创建项目基础文件的工具。看似很普通的需求，背后却饱含哲学，因为除了创建文件，它更重要的是提供给开发者一些约定或规范。\n\n### 脚手架的本质作用\n\n通常我们在开发相同类型的项目时都会使用一些相同的约定，其中包括：\n\n- 相同的文件组织结构\n- 相同的代码开发范式\n- 相同的模块依赖\n- 相同的工具模块配置\n- 相同的基础代码\n\n这样一来就会出现在搭建新项目时有大量重复工作要做。脚手架工具就是用来解决此类问题的。我们可以通过脚手架工具快速搭建特定类型项目的基础骨架结构，然后基于这个基础结构进行后续的开发工作。\n\n如果你用过一些例如 Visual Studio 或者 Eclipse 这样的大型 IDE，它们创建项目的过程实际上就是一个脚手架的工作流程。以 Android Studio 为例：\n\n一、创建项目\n\n![创建 Android 项目](https://cdn.zce.me/assets/ac290343afbe0987.png)\n\n二、选择项目类型\n\n![选择项目类型](https://cdn.zce.me/assets/742e151a328b6eb9.png)\n\n三、填写项目属性和相关配置\n\n![填写项目属性和相关配置](https://cdn.zce.me/assets/b6cb88a701834160.png)\n\n四、得到基础的项目骨架结构\n\n![得到项目结构](https://cdn.zce.me/assets/8bd2efdb3917559d.png)\n\n而前端项目创建过程中，由于技术选型多样，又没有一个权威的统一标准，所以前端方向的脚手架都是独立的工具，而且相对复杂。但是本质上所有的脚手架目标都是一样的，它们都是为了解决在创建项目过程中的重复工作。\n\n### 常用的脚手架工具\n\n目前市面上有很多成熟的前端脚手架工具，但是大都是为特定类型的项目服务的（提供集成的工程化方案），例如：\n\n- create-react-app → React 项目\n- vue-cli → Vue.js 项目\n- angular-cli → Angular 项目\n\n这些工具的实现方式也都大同小异，无外乎就是根据你提供的一些信息自动生成一个项目所需要的特定文件结构及相关配置。不过它们一般只用于自身所服务的框架项目。\n\n还有一些以 Yeoman 为代表的通用型项目脚手架工具，它可以根据一套模板生成一个对应的项目结构。这种类型的脚手架一般都很灵活，容易扩展。\n\n除了以上这些创建项目时才会用到的脚手架工具，还有一类脚手架也非常有用，代表性的工具叫做 Plop，它用来在项目开发过程中创建特定类型文件。例如创建一个新的组件或是一个新的模块，因为这些组件或者模块一般都有特定的几个文件组成，而且每个文件都需要有一些基本的结构，相对于手动创建，脚手架更为便捷稳定。\n\n接下来我们挑选几个有代表性的工具做深入探究。\n\n### Yeoman\n\n![Yeoman Logo](https://cdn.zce.me/assets/f029c5055094d50b.png)\n\n时至当下 React、Vue.js 和 Angular 大行其道，而且这些框架官方都提供了更为集成的脚手架工具链，所以大家在讨论脚手架时最先想到的往往都是 create-react-app 和 vue-cli 这样的工具。对于这一类的工具因为太过针对某个技术，而且使用上也非常普及，我就不做过多介绍了。\n\n这里我们着重探讨 Yeoman，因为 Yeoman 作为最老牌、最强大、最通用的脚手架工具，它有更多值得我们借鉴和学习的地方。\n\nYeoman 官方的定义是一款用于创造现代化 Web 应用的脚手架工具，不同于 vue-cli 这样的工具，Yeoman 更像是一个脚手架的运行平台，我们可以通过 Yeoman 搭配不同的 Generator 创建任何类型的项目，也就是说我们可以通过创建自己的 Generator 从而定制我们自己的前端脚手架。\n\nYeoman 的优点同样也是它的缺点。在很多专注基于单一框架开发的人眼中「Yeoman 过于通用，不够专注」，所以他们更愿意使用像 vue-cli 这类的脚手架，这也是这类工具成功的原因。\n\n但是这并不妨碍我们去学习它，那接下来我们就快速了解一下 yeoman 的用法以及 generator 的工作原理，为我们后面开发自己的脚手架做出准备。\n\n#### Yeoman 基本使用\n\nYeoman 是基于 Node.js 开发的一个工具模块，使用它的第一步自然是通过 NPM 在全局范围安装它（前提需要有正常的 Node.js 环境）：\n\n```shell\n$ npm install yo --global # or yarn global add yo\n```\n\n通过之前的介绍，我们应该知道，单单只有 `yo` 这个模块是不够的，因为 Yeoman 是需要搭配特定的 Generator 使用的。我们需要找到用于生成我们想要的类型项目的 Generator，例如：我们想要生成一个 Node module 项目，我们可以使用 `generator-node`，使用的方式同样也是将其安装到全局范围：\n\n```shell\n$ npm install generator-node --global # or yarn global add generator-node\n```\n\n有了这两个模块过后，我们就可以通过运行命令去使用 Yeoman 帮我们创建一个新的 Node Module 项目：\n\n```shell\n$ cd path/to/project-dir\n$ mkdir my-module\n$ yo node\n```\n\n![运行 yo node 命令](https://cdn.zce.me/assets/fa0ea9fa6ee7a260.png)\n\n#### Yeoman Sub Generator\n\n有时候我们并不需要创建完整的项目结构，可能只是需要在已有项目基础之上创建某种类型的项目文件。例如给一个项目创建 README.md，又或是在一个原有项目之上某些配置文件，你可以使用 Yeoman 的 Sub Generator 特性来实现。这里我们可以使用 `node:cli` 这个 Sub Generator 来为我们的模块添加 cli 支持，让其成为一个 cli 应用：\n\n```shell\n$ cd path/to/project-dir/my-module\n$ yo node:cli\n```\n\n此时命令行终端会提示是否覆盖 `package.json`，我们选择 Yes：\n\n```shell\n$ yo node:cli\n conflict package.json\n? Overwrite package.json? overwrite\n    force package.json\n   create lib\\cli.js\n```\n\n值得注意的是，并不是每个 Generator 都提供 Sub Generator，所以我们在使用之前，需要通过你所使用的 Generator 官方文档来明确。\n\n#### Yeoman 的常规使用步骤\n\n由于 Yeoman 是一个通用型的脚手架工具，所以我们几乎可以使用它去创建任何类型的项目。使用 Yeoman 一般需要遵循以下几个步骤：\n\n1. 明确你的需求；\n2. 找到合适的 Generator；\n3. 全局范围安装找到的 Generator；\n4. 通过 Yo 运行对应的 Generator；\n5. 通过命令行交互填写选项；\n6. 生成你所需要的项目结构；\n\n例如，我们需要创建一个网页应用：\n\n1. 通过 https://yeoman.io/generators/ 寻找需要的 Generator；\n2. 运行 `npm i generator-xxx -g` 全局范围安装此 Generator；\n3. 创建项目根目录，在此目录中运行 `yo xxx` 启动脚手架；\n4. 完成选项回答；\n\n#### 自定义 Generator\n\n通过前面对 Yeoman 基本使用的介绍，我们发现通过不同的 Generator 可以生成不同的项目，也就是说我们可以创造自己的 Generator 去帮我们生成自定义的项目结构。\n\n即便是市面上已经有很多的 Generator，我们还是有创造 Generator 的必要，因为市面上的 Generator 都是通用的，而我们实际开发过程中还是会出现一部分基础代码甚至业务代码在同类型项目中还是一样，我们可以把这些公共的部分都放到脚手架中生成，让脚手架工具的价值最大化。\n\n例如，我们在创建 Vue.js 项目时，默认情况下官方的脚手架工具只会创建一个最基础的项目骨架，但是这并不包括我们需要经常用到的模块，例如 axios、vue-router、vuex。你需要在每次项目创建过后再去引入这些模块，再去编写一些基础的使用代码。试想一下，如果我们把这些也放入到脚手架中，那么这个问题就不存在了。\n\n那么，自定义 Generator 应该如何具体去实现呢？接下来我们就通过自定义一个带有一定基础代码的 Vue.js 项目脚手架来跟大家介绍。\n\n##### 创建 Generator 模块\n\n创建 Generator 实际上就是创建一个 NPM 模块，一个基本的 Generator 结构如下：\n\n```text\n├─ generators/ ········································ 生成器目录\n│  └─ app/ ············································ 默认生成器目录\n│     └─ index.js ····································· 默认生成器实现\n└─ package.json ······································· 模块包配置文件\n```\n\n如果你需要提供多个 Sub Generator，你可以在 `app` 的同级目录添加一个新的生成器目录，例如：\n\n```diff\n ├─ generators/ ········································ 生成器目录\n │  ├─ app/ ············································ 默认生成器目录\n │  │  └─ index.js ····································· 默认生成器实现\n+│  └─ component/ ······································ 其他生成器目录\n+│     └─ index.js ····································· 其他生成器实现\n └─ package.json ······································· 模块包配置文件\n```\n\n此时我们的这个模块就支持 `yo my-generator:component` 这种 Sub Generator 的用法。\n\n同时，Yeoman Generator 还支持直接将生成器目录放到项目根目录下：\n\n```text\n├─ app/ ··············································· 默认生成器目录\n│  └─ index.js ········································ 默认生成器实现\n├─ other/ ············································· 其他生成器目录\n│  └─ index.js ········································ 其他生成器实现\n└─ package.json ······································· 模块包配置文件\n```\n\n除了特定的结构，还有一个与普通的 NPM 模块所不同的是，Yeoman Generator 模块的名称必须是 `generator-<name>` 的格式。\n\n> 如果你需要你的模块在 Yeoman 官方的 Generator 列表中出现，你可以在模块的 `keywords` 属性中添加 `yeoman-generator`。\n\n接下来我们来做一些具体的演示：\n\n1. 创建一个 `generator-sample` 的文件夹作为模块目录\n2. 在此目录下通过 `npm init` 创建 `package.json`\n3. 安装 `yeoman-generator` 模块依赖\n4. 按照结构要求创建 `generators/app/index.js` 文件\n\n```javascript\n// generators/app/index.js\n// 此文件为 Generator 的核心入口\n// 需要导出一个继承自 Yeoman Generator 的类型\n// Yeoman Generator 工作时会自动调用在此类型中定义的一些生命周期方法\n// 我们可以通过调用父类中提供的一些工具方法实现一些类似文件写入的功能\n\nconst Generator = require('yeoman-generator')\n\nmodule.exports = class extends Generator {\n  // Yeoman 自动在生成文件阶段调用此方法\n  // 我们尝试在此方法中往项目目录写入文件\n  writing() {\n    // destinationPath 可以自动获取生成文件的完整路径\n    const output = this.destinationPath('temp.txt')\n    const contents = Math.random().toString()\n    // fs 模块常用 API：https://yeoman.io/authoring/file-system.html\n    this.fs.write(output, contents)\n  }\n}\n```\n\n这样一个最简单的 Generator 就有完成了。\n\n回到命令行，通过 `npm link` 把这个模块链接至全局范围，使之成为一个全局模块包。这样 Yeoman 就可以找到它了。\n\n准备就绪，我们尝试使用 Yeoman 运行这个生成器：\n\n```shell\n$ yo sample\n```\n\n##### 根据模板创建文件\n\n很多时候我们需要自动创建的文件有很多，文件内容也相对复杂，这种情况下我们可以使用模板创建文件，这样会更加便捷：\n\n1. 在生成器目录下添加 `templates` 目录\n2. 将需要生成的文件都放入 `templates` 目录作为模板\n3. 模板中需要填充动态内容的地方采用 EJS 模板语法输出\n4. 生成文件时通过 `this.fs.copyTpl()` 方法去使用这些模板生成对应文件\n\n```html\n<!-- generators/app/templates/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title><%= title %></title>\n  </head>\n  <body>\n    <h1><%= title %></h1>\n  </body>\n</html>\n```\n\n```javascript\n// generators/app/index.js\nconst Generator = require('yeoman-generator')\n\nmodule.exports = class extends Generator {\n  writing() {\n    // 模板文件路径\n    const tmpl = this.templatePath('index.html')\n    // 输出文件路径\n    const output = this.destinationPath('index.html')\n    // 模板数据上下文\n    const data = { title: 'Hello world' }\n    // 生成文件\n    this.fs.copyTpl(tmpl, output, data)\n  }\n}\n```\n\n##### 接收用户输入数据\n\n对于模板中动态的数据一般我们需要通过命令行交互的方式询问使用者获取，在 Generator 中我们可以通过实现 prompting 方法，在此方法中通过 `this.prompt()` 方法实现与用户交互：\n\n```javascript\nconst Generator = require('yeoman-generator')\n\nmodule.exports = class extends Generator {\n  async prompting() {\n    // Yeoman 在询问用户环节自动执行此方法\n    // 在此方法中可以调用父类的 prompt 发出对用户的询问\n    const answers = await this.prompt([\n      {\n        type: 'input',\n        name: 'title',\n        message: 'Your project title',\n        default: this.appname // appname 默认为项目文件夹名称\n      }\n    ])\n\n    // answers => { title: 'user input' }\n    this.answers = answers\n  }\n\n  writing() {\n    // 模板文件路径\n    const tmpl = this.templatePath('index.html')\n    // 输出文件路径\n    const output = this.destinationPath('index.html')\n    // 模板数据上下文\n    const data = this.answers\n    // 生成文件\n    this.fs.copyTpl(tmpl, output, data)\n  }\n}\n```\n\n> 更多用法及高级内容请参见：https://yeoman.io/authoring/\n\n#### Vue Generator 案例\n\n接下来我们就按照之前的设想，自定义一个带有一定基础代码的 Vue.js 项目脚手架。\n\n1. 按照设想情况完成一个项目结构\n2. 将此项目结构中全部的文件拷贝至 `templates` 目录\n3. 模板中需要填充动态内容的地方采用 EJS 模板语法输出\n4. 遍历文件列表生成每一个文件\n\n需要注意的是如果模板文件中存在的 EJS 模板标记不希望被转换，则需要使用 `<%%` 转义。\n\n```javascript\nconst templates = [\n  '.browserslistrc',\n  '.editorconfig',\n  '.env.development',\n  '.env.production',\n  '.eslintrc.js',\n  '.gitignore',\n  'babel.config.js',\n  'package.json',\n  'postcss.config.js',\n  'README.md',\n  'yarn.lock',\n  'public/favicon.ico',\n  'public/index.html',\n  'src/App.vue',\n  'src/main.js',\n  'src/router.js',\n  'src/assets/logo.png',\n  'src/components/HelloWorld.vue',\n  'src/store/actions.js',\n  'src/store/getters.js',\n  'src/store/index.js',\n  'src/store/mutations.js',\n  'src/store/state.js',\n  'src/utils/request.js',\n  'src/views/About.vue',\n  'src/views/Home.vue'\n]\n```\n\n#### 发布 Generator\n\n因为 Generator 实际上就是 NPM 模块，所以发布 Generator 实际上就是发布 NPM 模块。我们只需要将自己写好的 Generator 模块通过 NPM 形式发布为公开模块即可。\n\n如果你需要你的模块在 Yeoman 官方的 Generator 列表中出现，你可以在模块的 `keywords` 属性中添加 `yeoman-generator`。\n\n### Plop\n\n除了像 Yeoman 这样大型的脚手架工具，还有一些小型的脚手架工具也非常出色，这里跟大家安利一款我个人经常使用的一个小型的脚手架工具 Plop。\n\nPlop 其实是一款主要用于创建项目中特定类型文件的小工具，有点类似于 Yeoman 的 Sub Generator。不过它不是独立使用的，一般我们会把 Plop 集成到项目中，用于自动化创建项目中同类型文件。\n\n接下来我们通过两个案例的对比，去体会一下 Plop 的作用及优势。\n\n屏幕上给出来的是两个相同的 React 项目，所不同的是右侧的项目中集成了 Plop 工具。\n\n具体的差异要从我们日常开发中经常面临的问题说起，那就是我们在项目开发过程中需要重复创建同类型的文件。\n\n例如我们这个案例中，每个页面上的组件都是由三个文件组成的，分别是 js 文件 css 文件 test.js 文件，那么，如果我们每次创建一个新的 React 组件，我们都需要新建三个文件，而且每个文件中还有一些基础代码。整个过程非常繁琐，而且不容易统一。\n\n在右侧的项目中使用了 Plop，面对相同的问题，使用 Plop 就方便很多，我们只需要在命令行中运行 Plop，命令行就会询问我们一些信息，然后自动帮我们创建这些文件，确保每次创建的文件都是统一的。\n\n#### 具体使用 Plop\n\n接下来我们一起了解一下 Plop 的具体使用：\n\n1. 将 plop 模块作为项目开发依赖安装\n2. 在项目根目录下创建一个 `plopfile.js` 文件\n3. 在 `plopfile.js` 文件中定义脚手架任务\n\n例如用于生成 Node.js 项目中的控制器：\n\n```javascript\n// plopfile.js\nmodule.exports = plop => {\n  plop.setGenerator('controller', {\n    description: 'application controller logic',\n    prompts: [\n      {\n        type: 'input',\n        name: 'name',\n        message: 'controller name'\n      }\n    ],\n    actions: [\n      {\n        type: 'add',\n        path: 'src/{{name}}.js',\n        templateFile: 'plop-templates/controller.hbs'\n      }\n    ]\n  })\n}\n```\n\n完事过后我们就可以通过 Plop 提供的 CLI 去启动这个生成器：\n\n```shell\nyarn plop controller\n```\n\n> 其他细节参考官网：https://plopjs.com\n\n### 脚手架工具的实现原理\n\n### 开发一款通用脚手架工具\n\nzce-cli\n\n---\n\n- https://segmentfault.com/a/1190000004896264\n- https://segmentfault.com/a/1190000011768994\n- https://segmentfault.com/a/1190000010665132\n- https://www.infoq.cn/article/C*jeqvVjOK5vMgqA8euZ\n- https://blog.csdn.net/fair_feng/article/details/72865140\n- https://blog.csdn.net/sinat_17775997/article/details/87867741\n- https://blog.csdn.net/qlwangcong518/article/details/87894308\n- https://blog.csdn.net/weixin_44199478/article/details/89024489\n- https://github.com/wangfupeng1988/read-notes/blob/master/book/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%BD%93%E7%B3%BB%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E8%B7%B5.md\n","cover":"https://cdn.zce.me/assets/be4b7a52f807a1a5.png"},{"title":"前端工程化 - 概述","slug":"frontend-engineering-summary","date":1566329550000,"updated":1673100032045,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["工程化"],"meta":{},"content":"\n前端工程化是指遵循一定的标准和规范，通过工具提高开发效率、降低维护成本的一种手段。近些年被广泛的关注和探讨，究其原因，主要是因为前端应用的功能要求不断提高，业务逻辑日益复杂。\n\n作为当下互联网时代唯一不可或缺的技术，前端占据了整个开发行业的「半壁江山」。从传统的网站到现在的 H5、移动 App、桌面应用以及小程序，前端技术几乎无所不能的全面覆盖。\n\n在这些表象的背后实际上是前端行业对开发人员的技能要求发生了天翻地覆的变化，以往“写 Demo，套模板，调页面”这种刀耕火种的方式已经完全不符合当下对开发效率的要求。前端工程化就是在这样的背景下被提上台面，成为前端工程师必要的手段之一。\n\n### 解决的问题\n\n技术是为了解决问题而存在的，前端工程化也不例外，这里我列举一些大家在日常开发过程中经常会面临的一些问题（不仅限于此）：\n\n- 想要使用 ES6、ES7 这些新特性，但是兼容有问题\n- 想要使用 Less / Sass / PostCSS 增强 CSS 的编程性，但是运行环境不能直接支持\n- 想要使用模块化的方式提高项目的可维护性，同样运行环境不能直接支持\n- 项目部署上线前需要手动压缩资源文件，过程中需要手动上传代码到服务器，还容易出错\n- 多人协作开发，无法硬性统一大家的代码风格\n- 从仓库中 pull 回来的代码质量无法保证\n- 部分功能开发时需要等待后端服务接口提前完成\n\n我们将这些问题归纳、总结为以下这几点：\n\n- 传统语言或语法的弊端\n- 无法使用模块化 / 组件化\n- 重复的机械式工作\n- 代码风格、格式无法统一\n- 仓库代码质量无法保证\n- 依赖后端服务接口支持\n- 整体依赖后端项目\n\n### 具体表现\n\n接下来，我就以最简单的项目开发流程为例，看看前端工程化在这个过程的表现，让大家先从整体角度对前端工程化有一个全面的认识。\n\n从项目的创建、到编码、再到预览、再到提交、最后到部署，每一个环节我们都可以通过工程化的方式大大提到工作效率，具体来说就是：\n\n1. 创建项目过程我们可以使用脚手架工具自动完成；\n2. 编码过程我们可以通过编译或者转化工具提前使用一些新特性，利用格式化和代码检查工具自动检测和修复代码中的基础问题；\n3. 预览时再通过 Web Server 自动预览并享受热更新的体验，并且可以使用 Mock 的方式在后端服务接口未完成的情况下，直接开发具体的业务功能；\n4. 到了代码提交环节，我们可以使用 Git Hook 自动化的在提交之前做出项目检查，确保不会提交有问题的代码，甚至连提交的日志都可以严格限制格式；\n5. 最后在部署阶段，我可以使用一行命令代替传统手动的 FTP 上传，甚至还可以实现在代码提交过后自动部署到服务器；\n\n### 工程化 ≠ 工具\n\n现阶段由于部分工具的「过于强大」，例如 Webpack，很多新手误认为工程化就是 Webpack，有了 Webpack 就是有了工程化。其实不然，工具并非工程化的核心，工程化的核心应该是对项目的一种规划或者架构，工具只是落地实现的手段。\n\n以一个普通项目为例，落实工程化的第一件事是规划整体项目的工作流架构，包括：\n\n1. 文件的组织结构\n2. 源代码的开发范式\n3. 语言或者语法规范\n4. 前后端分离方式\n5. 其他对开发阶段的需求\n\n有了整体的规划过后，再来具体考虑选择搭配使用哪些具体的工具，配置具体的选项。这才是一个工程化的过程。\n\n当然你也可以从一些集成式的工程化方案中找到思路，例如：\n\n- create-react-app\n- vue-cli\n- angular-cli\n\n可能很多人会认为这些就是脚手架工具，其实不然，不同于之前提到的工具，这些应该属于特定类型的项目中官方给出的集成式工程化方案。就拿 vue-cli 来说，创建项目、约定项目结构、提供开发服务、编译、Lint，这些都是集成在其中的。\n\n### 厥功至伟的 Node.js\n\n当然这一切都归功于 Node.js，如果说 AJAX 给前端带来了新的生命力，那么 Node.js 对于前端而言，除了让 JavaScript 有了新的舞台，它还给整个前端行业带来了一次「工业革命」，可以毫不夸张的说没有 Node.js 就没有今天的前端。\n\n接下来的很长一段时间中，我们用到的工具几乎都是使用 Node.js 开发的，所以说前端工程化由 Node.js 强力驱动。\n\n### 总结\n\n当然工程化在我看来是一个非常庞大的概念，也一直在不断成长的过程中，值得强调的是：不管它如何发展，始终都只是为了解决问题而存在，切莫为了技术而技术。\n\n接下来我们就通过五个专题具体学习如何在这些维度落实前端工程化。\n","cover":"https://cdn.zce.me/assets/28406e0a7886925b.jpg"},{"title":"Electron 跨平台桌面应用开发","slug":"electron-desktop-app","date":1565294100000,"updated":1673100032045,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Electron"],"meta":{},"content":"\n[Electron](https://electronjs.org/) 是一个运行平台，它能够让我们通过 HTML + CSS + JavaScript 开发桌面应用程序。\n\n核心原理就是 Electron 中将 Chromium（Chrome 的内核）和 Node.js 打包到了一起，通过 Chromium 提供 WebView 从而实现 UI 编程能力，通过 Node.js 提供 APIs 从而实现系统接口调用。\n\n![Electron 运行环境结构](https://cdn.zce.me/assets/3b43b7cc0631b932.png)\n\n简单来说就是，在 Electron 中我们可以像在 Web 开发中一样，通过 HTML + CSS 完成 UI 开发，通过 JavaScript（ECMAScript）调用 APIs 实现业务功能，只不过这里的 APIs = Web APIs + Node APIs。\n\n![](https://cdn.zce.me/assets/0b343ef9deb2a1d0.png)\n\n## 快速上手\n\n一个最基本的 Electron 项目需要有如下的几个必要文件：\n\n```text\nyour-app/\n├── index.html\n├── main.js\n└── package.json\n```\n\n与 Web 所不同的是，这里 Electron 启动的入口是 JavaScript 文件，也就是这里的 `main.js` 文件（简单示例）。\n\n```javascript\n// main.js\nconst { app, BrowserWindow } = require('electron')\n\napp.on('ready', () => {\n  // 创建浏览器窗口\n  const win = new BrowserWindow({\n    width: 800,\n    height: 600\n  })\n\n  // 加载 index.html 文件\n  win.loadFile('index.html')\n})\n```\n\n在这个 JavaScript 文件中创建页面窗口用于加载所需要在界面上显示的页面文件 `index.html`。更完整的 `main.js` 应该如下：\n\n```javascript\nconst { app, BrowserWindow } = require('electron')\n\n// 保持对 window 对象的全局引用，如果不这么做的话，\n// 当 JavaScript 对象被垃圾回收的时候，\n// window 对象对应的窗口将会自动被关闭\nlet win\n\nconst createWindow = () => {\n  // 创建浏览器窗口。\n  win = new BrowserWindow({\n    width: 800,\n    height: 600,\n    webPreferences: {\n      nodeIntegration: true\n    }\n  })\n\n  // 加载 index.html 文件\n  win.loadFile('index.html')\n\n  // 打开开发者工具\n  win.webContents.openDevTools()\n\n  // 当 window 被关闭，这个事件会被触发。\n  win.on('closed', () => {\n    // 取消引用 window 对象，如果你的应用支持多窗口的话，\n    // 通常会把多个 window 对象存放在一个数组里面，\n    // 与此同时，你应该删除相应的元素。\n    win = null\n  })\n}\n\n// Electron 会在初始化后并准备创建浏览器窗口时，调用这个函数。\n// 部分 API 在 ready 事件触发后才能使用。\napp.on('ready', createWindow)\n\n// 当全部窗口关闭时退出。\napp.on('window-all-closed', () => {\n  // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，\n  // 否则绝大部分应用及其菜单栏会保持激活。\n  if (process.platform !== 'darwin') {\n    app.quit()\n  }\n})\n\napp.on('activate', () => {\n  // 在 macOS 上，当单击 dock 图标并且没有其他窗口打开时，\n  // 通常在应用程序中重新创建一个窗口。\n  if (win === null) {\n    createWindow()\n  }\n})\n\n// 在这个文件中，你可以续写应用剩下主进程代码。\n// 也可以拆分成几个文件，然后用 require 导入。\n```\n\n`index.html` 中可以是任何你想要呈现的内容。你也可以使用不同的库和框架，这与 Web 中没什么两样，所不同的是，**当你 `BrowserWindow` → `webPreferences` → `nodeIntegration` 设置为 `true` 时，你可以在页面的脚本中使用 Node APIs。**这看起来非常棒，但是要小心使用这个特性，因为如果你加载的不是本地的脚本，那就存在风险。\n\n### 案例：文件编辑器\n\n为了体现 Electron 的能力，我们通过一个简单的记事本应用案例来感受。\n\n克隆基础项目结构代码：\n\n```shell\n$ git clone https://github.com/electron/electron-quick-start.git onetext --depth 1\n$ cd onetext\n$ rm -rf .git\n```\n\n安装项目依赖的模块：\n\n```shell\n$ yarn # or npm install\n```\n\n页面结构与样式：\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Editor</title>\n    <style>\n      html,\n      body {\n        margin: 0;\n        width: 100%;\n        height: 100%;\n        overflow: hidden;\n      }\n\n      #editor {\n        box-sizing: border-box;\n        padding: 3%;\n        width: 100%;\n        height: 100%;\n        border: 1px solid #ddd;\n        outline: 0;\n        font-size: 14px;\n        resize: none;\n      }\n    </style>\n  </head>\n  <body>\n    <textarea id=\"editor\" autofocus></textarea>\n    <script src=\"./renderer.js\"></script>\n  </body>\n</html>\n```\n\n页面脚本文件 `renderer.js`：\n\n```javascript\n// renderer.js\nconst os = require('os')\nconst fs = require('fs')\nconst path = require('path')\n\nconst editor = document.getElementById('editor')\n\nconst filename = path.join(os.homedir(), 'foo.txt')\n\nconst save = () => {\n  fs.writeFileSync(filename, editor.value)\n}\n\nconst open = () => {\n  editor.value = fs.readFileSync(filename, 'utf8')\n}\n\ndocument.addEventListener('keydown', e => {\n  if (e.ctrlKey && e.keyCode === 83) {\n    save()\n    return false\n  }\n  if (e.ctrlKey && e.keyCode === 79) {\n    open()\n    return false\n  }\n})\n```\n\n当然 Electron 模块中提供了更合适的 APIs，用于提示用户保存文件位置、让用户选择打开某个文件：\n\n```javascript\nconst fs = require('fs')\nconst { dialog } = require('electron').remote\n\nconst editor = document.getElementById('editor')\n\nconst save = () => {\n  const filename = dialog.showSaveDialogSync()\n  filename && fs.writeFileSync(filename, editor.value)\n}\n\nconst open = () => {\n  const result = dialog.showOpenDialogSync({ properties: ['openFile'] })\n  if (!result) return\n  const filename = result[0]\n  editor.value = fs.readFileSync(filename, 'utf8')\n}\n\ndocument.addEventListener('keydown', e => {\n  if (e.ctrlKey && e.keyCode === 83) {\n    save()\n    return false\n  }\n  if (e.ctrlKey && e.keyCode === 79) {\n    open()\n    return false\n  }\n})\n```\n\n注意事项：\n\n1. 在渲染进程中使用 Node APIs 需要开启当前 `BrowserWindow` 的 `nodeIntegration`（针对 Electron 5 以上版本）。\n2. 由于渲染进程是运行在 Chromium 中的，所以不管是样式还是脚本都不需要考虑兼容其他环境问题，你可以放心大胆的使用新特性。\n\n通过以上的示例，我们应该就可以体会到 Electron 开发的过程，以及 Electron 的内部组成。\n\n## 主进程与渲染进程\n\nElectron 中有两种进程类型，分别为「主进程」和「渲染进程」，它们的职责和能力各不相同：\n\n通过 Electron 直接启动运行的脚本，运行这个脚本的进程被称为「主进程」。 一个 Electron 应用总是有且只有一个主进程。一般我们都会在这个进程中管理整个应用，所以我个人也把它称之为「调度进程」。\n\n通过 `BrowserWindow` 创建的页面窗口运行在单独的进程当中，称之为「渲染进程」。负责展示页面以及运行页面上所需要的脚本。\n\n![主进程与渲染进程](https://cdn.zce.me/assets/56b250ccd8946f23.png)\n\n## With Framework\n\n接下来我们再来了解一下，如何配合使用 React 或者 Vue.js 这样的 UI 框架开发 Electron 应用。\n\n如果你不需要使用 JSX 或者单文件组件这些特性，你可以直接把这些框架当作库，直接在页面中使用。\n\n当然，就现阶段来说，大家很自然的会把这些有特性和框架捆绑，总是用 A 就必须要用 B，所以这里还是需要推荐给大家一个我觉得非常方便的集成环境。\n\n### electron-webpack\n\n[electron-webpack](https://github.com/electron-userland/electron-webpack) 其实是一个通过 webpack 编译 Electron 代码的集成工具，通过简单的配置就可以支持 React 和 Vue.js，当然你也可以让它支持更多。\n\n它要求你有通过特定的项目结构编写代码：\n\n```text\nmy-project/\n├─ src/\n│  ├─ main/\n│  │  └─ index.js\n│  ├─ renderer/\n│  │  └─ index.js\n│  └─ common/\n└─ static/\n```\n\n我们可通过官方提供的模板快速创建这样结构的项目：\n\n```shell\n$ git clone https://github.com/electron-userland/electron-webpack-quick-start.git my-project --depth 1\n$ cd my-project\n$ rm -rf .git\n\n# install dependencies\n$ yarn # or npm install\n```\n\n这个项目中提供了一些有用的 scripts：\n\n```shell\n# run application in development mode\nyarn dev\n\n# compile source code and create webpack output\nyarn compile\n\n# `yarn compile` & create build with electron-builder\nyarn dist\n\n# `yarn compile` & create unpacked build with electron-builder\nyarn dist:dir\n```\n\n### 使用 Vue.js\n\n由于 electron-webpack 中会自动加载 Vue.js 所需的 loader，所以只需要安装对应的模块，Vue.js 单文件组件将自动工作。\n\n```shell\nyarn add vue electron-webpack-vue --dev\n```\n\n### 使用 React\n\n同理，React 的工作也只需要安装相应的模块：\n\n```shell\nyarn add react react-dom @babel/preset-react --dev\n```\n\n## 打包和发布\n\n我们可以使用类似 [electron-builder](https://www.electron.build) 的一些集成工具轻松完成跨平台打包任务。\n\n刚刚介绍的 electron-webpack 的初始项目模板中就包含了此工具的使用。\n\n> 我最近在重写一个基于 Vue.js + TypeScript 的 Electron 骨架项目，如需自取：\n>\n> https://github.com/zce/electron-boilerplate\n\n[^1]: https://medium.com/developers-writing/building-a-desktop-application-with-electron-204203eeb658\n","cover":"https://cdn.zce.me/assets/21a89ed42e17380e.png"},{"title":"使用 Node.js 构建 OAuth 2.0 服务","slug":"building-oauth2-service-with-nodejs","date":1561576049000,"updated":1673100032041,"sections":[],"draft":true,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Node.js","OAuth"],"meta":{},"content":"\n### 引文\n\n最近在一个交流群里面看到一些朋友\n\n### OAuth 2.0 到底是什么\n\n关于「OAuth 2.0 到底是什么」，[阮一峰的文章](http://www.ruanyifeng.com/blog/2019/04/oauth_design.html)中举了一个非常好的例子，很好的通过生活中的一个场景诠释了 OAuth 协议解决的问题。\n\n### 我能否开发一个提供给第三方使用的 OAuth 2.0 服务\n\n答案自然是肯定的，但是前提是你对 OAuth 2.0 的理解不能仅仅停留在能够接入第三方 OAuth 服务，你必须充分理解 OAuth 授权的完整过程以及每一个环节客户端和服务端各自都做了哪些事情。\n\n那接下来我们就一起来简单聊聊这些：\n\n### 具体实现方式\n\n### 体验一下我开发的这个\n\nhttps://www.jianshu.com/p/7febbe553c83\n"},{"title":"Gatsby 快速上手","slug":"gatsby-quick-start","date":1561568759000,"updated":1673100032041,"sections":[],"draft":true,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Gatsby"],"meta":{},"content":"\nTODO: Start enjoying the fun of creation...\n"},{"title":"使用 Vue.js 开发 Electron 应用：基础","slug":"using-electron-with-vue-the-basics","date":1561562992000,"updated":1673100032041,"sections":[],"draft":true,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Vue.js","Electron"],"meta":{},"content":""},{"title":"使用 TypeScript 开发 Vue.js 应用","slug":"vue-with-typescript","date":1561562992000,"updated":1673100032041,"sections":[],"draft":true,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Vue.js","TypeScript"],"meta":{},"content":""},{"title":"快速掌握 AJAX - 跨域","slug":"ajax-cross-domain","date":1546278939000,"updated":1673100032041,"sections":[],"draft":true,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["AJAX"],"meta":{},"content":""},{"title":"快速掌握 AJAX - 基础","slug":"ajax-essential","date":1546172918000,"updated":1673100032041,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["AJAX"],"meta":{},"content":"\n## 背景介绍\n\n在了解 AJAX 之前我们可以简单的认为「JavaScript 能力有限」，因为在此之前 Web 平台提供所有的 API 都只停留在「单机」的阶段。\n\n这样就会造成一些无法实现的功能，例如：\n\n- 无法在实现用户登录功能时，当用户输入邮箱地址显示用户对应的头像\n- 无法在实现用户注册功能时，当用户输入邮箱或者用户名就提示是否存在\n- 无法在实现留言板功能时，实时看到最新的用户留言\n\n> 思考：为什么做不到这些呢？\n\n![browser-server](https://cdn.zce.me/assets/16ce556d3fe529d8.png)\n\n这些功能的开发最终都卡在一个相同的问题上：所需要的数据存放在服务端，我们无法通过已知的 API 获取到服务端存放的数据。\n\n在此之前，我们可以通过以下几种方式让浏览器发出对服务端的请求，获得服务端的数据：\n\n- 地址栏输入地址，回车，刷新\n- 特定元素的 href 或 src 属性\n- 表单提交\n\n这些方案都是我们无法通过或者很难通过代码的方式进行编程（对服务端发出请求并且接受服务端返回的响应），**如果我们可以通过 JavaScript 直接发送网络请求，那么 Web 的可能就会更多，随之能够实现的功能也会更多，至少不再是只能开发「单机游戏」。**\n\n> 对 XXX 进行编程指的就是用代码的方式操作它。\n\n### Google Suggest\n\nAJAX（Asynchronous JavaScript and XML），最早出现在 2005 年的 [Google Suggest](http://google-suggest.tumblr.com/)，是在浏览器端进行网络编程（发送请求、接收响应）的技术方案，它使我们可以通过 JavaScript 直接获取服务端最新的内容而不必重新加载页面。让 Web 更能接近桌面应用的用户体验。\n\n![google-suggest](https://cdn.zce.me/assets/484bfff50f1a9d84.png)\n\n## AJAX 定义\n\n> 全称：Asynchronous Javascript And XML\n\n说白了，**AJAX 就是浏览器提供的一套 API，可以通过 JavaScript 调用，从而实现通过代码控制请求与响应。实现通过 JavaScript 进行网络编程。**\n\n至于 **XML**：最早在客户端与服务端之间传递数据时所采用的数据格式就是 XML。\n\n> BTW. 个人认为应用层开发大多数情况下无外乎就是通过特定的逻辑将一堆 API 调用拼凑在一起罢了，没有太多技术含量。\n\n### 应用场景总结\n\n对于每一个未知的技术，我们在了解了过后第一反应就是在什么情况下用？\n\nAJAX 一般在开发中的用途我总结为以下四类：\n\n- 按需获取数据\n- 对用户输入的数据进行校验\n- 自动更新页面上内容\n- 提升用户体验 - 无刷新的体验\n\n## 快速上手\n\nAJAX API 中核心提供的是一个 `XMLHttpRequest` 类型，所有的 AJAX 操作都需要使用到这个类型。\n\n使用 AJAX 的过程可以类比平常我们访问网页过程：\n\n```javascript\n// 1. 创建一个 XMLHttpRequest 类型的对象 —— 相当于打开了一个浏览器\nvar xhr = new XMLHttpRequest()\n// 2. 打开与一个网址之间的连接 —— 相当于在地址栏输入访问地址\nxhr.open('GET', '/time')\n// 3. 通过连接发送一次请求 —— 相当于回车或者点击访问发送请求\nxhr.send(null)\n// 4. 指定 xhr 状态变化事件处理函数 —— 相当于处理网页呈现后的操作\nxhr.onreadystatechange = function () {\n  // 通过 xhr 的 readyState 判断此次请求的响应是否接收完成\n  if (this.readyState === 4) {\n    // 通过 xhr 的 responseText 获取到响应的响应体\n    console.log(this.responseText)\n  }\n}\n```\n\n> 注意：涉及到 AJAX 操作的页面不能使用文件协议访问（文件的方式访问）\n\n### readyState\n\n由于 `readystatechange` 事件是在 `xhr` 对象状态变化时触发（不单是在得到响应时），也就意味着这个事件会被触发多次，所以我们有必要了解每一个状态值代表的含义：\n\n| readyState | 状态描述 | 说明 |\n| --- | --- | --- |\n| 0 | UNSENT | 代理（XHR）被创建，但尚未调用 `open()` 方法。 |\n| 1 | OPENED | `open()` 方法已经被调用，建立了连接。 |\n| 2 | HEADERS_RECEIVED | `send()` 方法已经被调用，并且已经可以获取状态行和响应头。 |\n| 3 | LOADING | 响应体下载中， `responseText` 属性可能已经包含部分数据。 |\n| 4 | DONE | 响应体下载完成，可以直接使用 `responseText`。 |\n\n#### 时间轴\n\n```flow\ns=>start: UNSENT\no1=>operation: OPENED\no2=>operation: HEADERS_RECEIVED\no3=>operation: LOADING\ne=>end: DONE\n\ns(right)->o1(right)->o2(right)->o3(right)->e\n```\n\n```flow\ns=>start: 初始化\no1=>operation: 建立连接\no2=>operation: 接收到响应头\no3=>operation: 响应体加载中\ne=>end: 加载完成\n\ns(right)->o1(right)->o2(right)->o3(right)->e\n```\n\n```javascript\nvar xhr = new XMLHttpRequest()\nconsole.log(xhr.readyState)\n// => 0\n// 初始化 请求代理对象\n\nxhr.open('GET', '/time')\nconsole.log(xhr.readyState)\n// => 1\n// open 方法已经调用，建立一个与服务端特定端口的连接\n\nxhr.send()\n\nxhr.addEventListener('readystatechange', function () {\n  switch (this.readyState) {\n    case 2:\n      // => 2\n      // 已经接受到了响应报文的响应头\n\n      // 可以拿到头\n      // console.log(this.getAllResponseHeaders())\n      console.log(this.getResponseHeader('server'))\n      // 但是还没有拿到体\n      console.log(this.responseText)\n      break\n\n    case 3:\n      // => 3\n      // 正在下载响应报文的响应体，有可能响应体为空，也有可能不完整\n\n      // 在这里处理响应体不保险（不可靠）\n      console.log(this.responseText)\n      break\n\n    case 4:\n      // => 4\n      // 一切 OK （整个响应报文已经完整下载下来了）\n\n      // 这里处理响应体\n      console.log(this.responseText)\n      break\n  }\n})\n```\n\n通过理解每一个状态值的含义得出一个结论：一般我们都是在 `readyState` 值为 `4` 时，执行响应的后续逻辑。\n\n```javascript\nxhr.onreadystatechange = function () {\n  if (this.readyState === 4) {\n    // 后续逻辑......\n  }\n}\n```\n\n### 遵循 HTTP\n\n本质上 XMLHttpRequest 就是 JavaScript 在 Web 平台中发送 HTTP 请求的手段，所以我们发送出去的请求任然是 HTTP 请求，同样符合 HTTP 约定的格式：\n\n```javascript\n// 设置请求报文的请求行\nxhr.open('GET', '/time')\n// 设置请求头\nxhr.setRequestHeader('Accept', 'text/plain')\n// 设置请求体\nxhr.send(null)\n\nxhr.onreadystatechange = function () {\n  if (this.readyState === 4) {\n    // 获取响应状态码\n    console.log(this.status)\n    // 获取响应状态描述\n    console.log(this.statusText)\n    // 获取响应头信息\n    console.log(this.getResponseHeader('Content-Type')) // 指定响应头\n    console.log(this.getAllResponseHeaders()) // 全部响应头\n    // 获取响应体\n    console.log(this.responseText) // 文本形式\n    console.log(this.responseXML) // XML 形式，了解即可不用了\n  }\n}\n```\n\n> 参考链接：\n>\n> - https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\n> - https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n> - ssqwqqdeveloper.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n\n## 具体用法\n\n### GET 请求\n\n> 通常在一次 GET 请求过程中，参数传递都是通过 URL 地址中的 `?` 参数传递。\n\n```javascript\nvar xhr = new XMLHttpRequest()\n// GET 请求传递参数通常使用的是问号传参\n// 这里可以在请求地址后面加上参数，从而传递数据到服务端\nxhr.open('GET', '/delete?id=1')\n// 一般在 GET 请求时无需设置响应体，可以传 null 或者干脆不传\nxhr.send(null)\nxhr.onreadystatechange = function () {\n  if (this.readyState === 4) {\n    console.log(this.responseText)\n  }\n}\n\n// 一般情况下 URL 传递的都是参数性质的数据，而 POST 一般都是业务数据\n```\n\n### POST 请求\n\n> POST 请求过程中，都是采用请求体承载需要提交的数据。\n\n```javascript\nvar xhr = new XMLHttpRequest()\n// open 方法的第一个参数的作用就是设置请求的 method\nxhr.open('POST', '/add')\n// 设置请求头中的 Content-Type 为 application/x-www-form-urlencoded\n// 标识此次请求的请求体格式为 urlencoded 以便于服务端接收数据\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\n// 需要提交到服务端的数据可以通过 send 方法的参数传递\n// 格式：name=zhangsan&age=18\nxhr.send('name=zhangsan&age=18')\nxhr.onreadystatechange = function () {\n  if (this.readyState === 4) {\n    console.log(this.responseText)\n  }\n}\n```\n\n### 同步与异步\n\n关于同步与异步的概念在生活中有很多常见的场景，举例说明。\n\n> - 同步：一个人在同一个时刻只能做一件事情，在执行一些耗时的操作（不需要看管）不去做别的事，只是等待\n> - 异步：在执行一些耗时的操作（不需要看管）去做别的事，而不是等待\n\n`xhr.open()` 方法第三个参数要求传入的是一个 `bool` 值，其作用就是设置此次请求是否采用异步方式执行，默认为 `true`，如果需要同步执行可以通过传递 `false` 实现：\n\n```javascript\nconsole.log('before ajax')\nvar xhr = new XMLHttpRequest()\n// 默认第三个参数为 true 意味着采用异步方式执行\nxhr.open('GET', '/time', true)\nxhr.send(null)\nxhr.onreadystatechange = function () {\n  if (this.readyState === 4) {\n    // 这里的代码最后执行\n    console.log('request done')\n  }\n}\nconsole.log('after ajax')\n```\n\n如果采用同步方式执行，则代码会卡死在 `xhr.send()` 这一步：\n\n```javascript\nconsole.log('before ajax')\nvar xhr = new XMLHttpRequest()\n// 同步方式\nxhr.open('GET', '/time', false)\n// // 同步方式 执行需要 先注册事件再调用 send，否则 readystatechange 无法触发\n// xhr.onreadystatechange = function () {\n//   if (this.readyState === 4) {\n//     // 这里的代码最后执行\n//     console.log('request done')\n//   }\n// }\nxhr.send(null)\n// 因为 send 方法执行完成 响应已经下载完成\nconsole.log(xhr.responseText)\nconsole.log('after ajax')\n```\n\n演示同步异步差异。\n\n所以一定在发送请求 `send()` 之前注册 `readystatechange`（不管同步或者异步）\n\n- 为了让这个事件可以更加可靠（一定触发），一定是先注册\n\n> 了解同步模式即可，切记不要使用同步模式。\n\n至此，我们已经大致了解了 AJAX 所的提供的基本 API 。\n\n### XMLHttpRequest API 总结\n\n> https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\n\n### 属性\n\n- `readyState`\n- `status`\n- `responseText`\n- `responseXML`\n- `onreadystatechange`\n\n### 方法\n\n- `open(method, url, async)`\n- `send(requsetBody)`\n- `setRequestHeader(key, value)`\n- `getResponseHeader(key)`\n\n## 响应数据格式\n\n> 提问：如果希望服务端返回一个复杂数据，该如何处理？\n\n关心的问题就是服务端发出何种格式的数据，这种格式如何在客户端用 JavaScript 解析。\n\n### XML\n\n一种数据描述手段\n\n老掉牙的东西，简单演示一下，不在这里浪费时间，基本现在的项目不用了。\n\n淘汰的原因：数据冗余太多\n\n### JSON\n\n也是一种数据描述手段，类似于 JavaScript 字面量方式\n\n服务端采用 JSON 格式返回数据，客户端按照 JSON 格式解析数据。\n\n> **注意**：\n>\n> - 不管是 JSON 也好，还是 XML，只是在 AJAX 请求过程中用到，并不代表它们与 AJAX 之间有必然的联系，它们只是数据协议罢了。\n> - 不管服务端是采用 XML 还是采用 JSON 本质上都是将数据返回给客户端。\n> - 服务端应该根据响应内容的格式设置一个合理的 Content-Type。\n\n### 处理响应数据渲染\n\n客户端中拿到请求的数据过后最常见的就是把这些数据呈现到界面上。\n\n如果数据结构简单，可以直接通过字符串操作（拼接）的方式处理，但是如果数据过于复杂，字符串拼接维护成本太大，就不推荐了，可以使用模版引擎或者 ES6 提供的模板字符串。\n\n> 模板引擎有很多种，使用方式大同小异，目的都是为了可以更容易的将数据渲染到 HTML 字符串中。\n\n## 缓存问题\n\n缓存问题指的是：多次 AJAX GET 请求同一个 URL 得到的结果是相同的，目前绝大多数浏览器已经没有这个问题了，只有早期的 IE 浏览器（<= IE 9）任然存在这个问题\n\n```javascript\nvar xhr = new XMLHttpRequest()\nxhr.open('GET', '/time')\nxhr.send(null)\nxhr.onreadystatechange = function () {\n  if (this.readyState !== 4) return\n  console.log(this.responseText)\n  // => 每次得到的结果都是相同的\n}\n```\n\n### 解决方案\n\n#### URL 加戳\n\n这个办法的核心就是让浏览器认为每次请求的地址都是不同的。\n\n> 不同的 querystring 会被浏览器认为是不同的地址，浏览器会忽略客户端缓存。\n\n```javascript\nvar xhr = new XMLHttpRequest()\nxhr.open('GET', '/time?t=' + Date.now())\nxhr.send(null)\nxhr.onreadystatechange = function () {\n  if (this.readyState !== 4) return\n  console.log(this.responseText)\n  // =>\n}\n```\n\n#### 服务端设置响应头\n\n由服务端通过 HTTP 响应报文中的响应头告知客户端浏览器不要缓存当前地址。\n\n```javascript\napp.get('/time', (req, res) => {\n  res.set('Cache-Control', 'no-cache')\n  res.set('Pragma', 'no-cache')\n  res.set('Expires', '-1')\n  res.send(Date.now().toString())\n})\n```\n\n了解即可，更多的情况下前端开发中还是通过加戳的方式解决此问题，因为在前端可控范围之内。\n\n## 兼容方案\n\nXMLHttpRequest 在老版本浏览器（IE5/6）中有兼容问题，可以通过另外一种方式代替。\n\n```javascript\nvar xhr = window.XMLHttpRequest\n  ? new XMLHttpRequest()\n  : new ActiveXObject('Microsoft.XMLHTTP')\n// xhr 的成员相同\n```\n\n## XMLHttpRequest 2.0\n\n介绍完老版本的问题，接下来介绍一下新版本的特性。\n\nHTML5 中对 XMLHttpRequest 类型全面升级，更易用，更强大\n\n### onload / onprogress\n\n```javascript\nvar xhr = new XMLHttpRequest()\nxhr.open('GET', '/time')\nxhr.onload = function () {\n  // onload readyState => 4\n  // 只在请求完成时触发\n  console.log(this.readyState)\n}\nxhr.onprogress = function (e) {\n  // onprogress readyState => 3\n  // 只在请求进行中触发\n  console.log(this.readyState)\n  // e.loaded  在周期性调用中接受到了多少信息。\n  // e.total  该请求一共有多少信息。\n}\nxhr.send(null)\n```\n\n> - https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestEventTarget/onload\n> - https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestEventTarget/onprogress\n\n### response 属性\n\n以对象的形式表述响应体，其类型取决于 `responseType` 的值。你可以尝试设置 `responseType` 的值，以便通过特定的类型请求数据。\n\n```javascript\nvar xhr = new XMLHttpRequest()\nxhr.open('GET', '/api/users')\n// 主观认为服务端返回的响应体为 JSON 格式\nxhr.responseType = 'json'\nxhr.onload = function () {\n  console.log(this.response)\n  // => Array 而不是 JSON String\n}\nxhr.send(null)\n```\n\n> `responseType` 要在调用 `open()` 初始化请求之后，在调用 `send()` 发送请求到服务器之前设置方可生效。\n\n| 值 | 描述 |\n| --- | --- |\n| \"\" | 将 responseType 设为空字符串与设置为\"text\"相同， 是默认类型 （实际上是 DOMString）。 |\n| \"arraybuffer\" | response 是一个包含二进制数据的 JavaScript ArrayBuffer 。 |\n| \"blob\" | response 是一个包含二进制数据的 Blob 对象 。 |\n| \"document\" | response 是一个 HTML Document 或 XML XMLDocument ，这取决于接收到的数据的 MIME 类型。请参阅 HTML in XMLHttpRequest 以了解使用 XHR 获取 HTML 内容的更多信息。 |\n| \"json\" | response 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为 JSON 解析得到的。 |\n| \"text\" | response 是包含在 DOMString 对象中的文本。 |\n\n### FormData\n\n以前 AJAX 操作只能提交字符串，现在可以提交 **二进制** 的数据。\n\n```javascript\nvar formElement = document.querySelector('form#login')\n\n// 表单数据对象\nvar data = new FormData(formElement)\n// 额外文本内容\ndata.append('key', 'value')\n// 额外文件内容\ndata.append('file', dom.files[0])\n\nvar xhr = new XMLHttpRequest()\nxhr.open('POST', '/api/upload')\nxhr.send(data)\nxhr.onload = function () {\n  console.log(this.responseText)\n}\n```\n\n> https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\n\n## 封装 AJAX 库\n\n### 自己封装一个 AJAX 函数\n\n> 这里主要是为了了解封装的过程，一般情况在开发中都是使用第三方提供的 AJAX 库，因为它们可能更加严谨。\n\n为了在后续的开发过程中可以更方便的使用这套 API，一般的做法都是将其封装到一个函数中以便调用。\n\n```javascript\n/**\n * 发送一个 AJAX 请求\n * @param  {string}   url    请求地址\n * @param  {string}   method 请求方法\n * @param  {Object}   params 请求参数\n * @param  {function} done   请求完成过后需要做的事情（委托/回调）\n */\nfunction ajax(url, method, params, done) {\n  // 统一转换为大写便于后续判断\n  method = method.toUpperCase()\n\n  // 对象形式的参数转换为 urlencoded 格式\n  var pairs = []\n  for (var key in params) {\n    pairs.push(key + '=' + params[key])\n  }\n  var querystring = pairs.join('&')\n\n  var xhr = window.XMLHttpRequest\n    ? new XMLHttpRequest()\n    : new ActiveXObject('Microsoft.XMLHTTP')\n\n  xhr.addEventListener('readystatechange', function () {\n    if (this.readyState !== 4) return\n\n    // 尝试通过 JSON 格式解析响应体\n    try {\n      done(JSON.parse(this.responseText))\n    } catch (e) {\n      done(this.responseText)\n    }\n  })\n\n  // 如果是 GET 请求就设置 URL 地址 问号参数\n  if (method === 'GET') {\n    url += '?' + querystring\n  }\n\n  xhr.open(method, url)\n\n  // 如果是 POST 请求就设置请求体\n  var data = null\n  if (method === 'POST') {\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\n    data = querystring\n  }\n  xhr.send(data)\n}\n\najax('get', '/getsomthing', { id: 123 }, function (data) {\n  console.log(data)\n})\n\najax('post', '/addsomthing', { foo: 'posted data' }, function (data) {\n  console.log(data)\n})\n```\n\n> 提示：回调函数的概念\n>\n> - 函数就可以理解为一个想要做的事情，函数体中约定了这件事情做的过程，直到调用时才开始工作。\n> - 回调函数可以理解为生活中委托的概念。\n\n> **委托**：将函数作为参数传递，就像是你将一个事情交给别人，你制定这件事怎么做，但是具体的是由别人去做，这就是委托的概念\n\n### jQuery 中的 AJAX\n\njQuery 中有一套专门针对 AJAX 的封装，功能十分完善，经常使用，需要着重注意。\n\n> 一个你会用我会用他会用到的点，就一定有一个已经封装好的\n\n> 参考：\n>\n> - http://www.jquery123.com/category/ajax/\n> - http://www.w3school.com.cn/jquery/jquery_ref_ajax.asp\n\n#### \\$.ajax\n\n```javascript\n$.ajax({\n  url: '/time',\n  type: 'get',\n  dataType: 'json',\n  data: { id: 1 },\n  beforeSend: function (xhr) {\n    console.log('before send')\n  },\n  success: function (data) {\n    console.log(data)\n  },\n  error: function (xhr) {\n    console.log(xhr)\n  },\n  complete: function (xhr) {\n    console.log('request completed')\n  }\n})\n```\n\n常用选项参数介绍：\n\n- url：请求地址\n- type：请求方法，默认为 `get`\n- dataType：服务端响应数据类型\n- contentType：请求体内容类型，默认 `application/x-www-form-urlencoded`\n- data：需要传递到服务端的数据，如果 GET 则通过 URL 传递，如果 POST 则通过请求体传递\n- timeout：请求超时时间\n- beforeSend：请求发起之前触发\n- success：请求成功之后触发（响应状态码 200）\n- error：请求失败触发\n- complete：请求完成触发（不管成功与否）\n\n#### \\$.get\n\nGET 请求快捷方法\n\n`$.get(url, data, callback)`\n\n#### \\$.post\n\nPOST 请求快捷方法\n\n`$.post(url, data, callback)`\n\n#### 全局事件处理\n\n> 参考：http://www.jquery123.com/category/ajax/global-ajax-event-handlers/\n\n#### 其他常见 API\n\n- `$(selector).load()` - 局部区域加载服务端返回的内容，有点类似 `iframe`\n- `$.getJSON()` - 忽略服务端响应的 `Content-Type` 响应头，主观按照 JSON 格式解析响应体\n- `$.getScript()` - 加载并执行服务端返回的一段 JavaScript 代码\n\n### Axios\n\n> https://github.com/axios/axios\n\nAxios 是目前应用最为广泛的 AJAX 封装库，相对于 jQuery 的优势在于支持 `Promise`、功能更强劲、职责更单一，后期会专门介绍到。\n\n```javascript\naxios\n  .get('/time')\n  .then(function (res) {\n    console.log(res.data)\n  })\n  .catch(function (err) {\n    console.error(err)\n  })\n```\n\n## 总结\n\n假设你是一位刚刚进入 JavaScript 领域的开发者，至此，你应该是已经了解到了 AJAX 基础所有的方方面面了，后续可能会再分享一些关于 AJAX 的经验和技巧，感兴趣的可以持续关注。\n","cover":"https://cdn.zce.me/assets/4e1c63cae7246b97.png"},{"title":"Node.js 中途岛","slug":"nodejs-midway","date":1512058080000,"updated":1673100032041,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Node.js"],"meta":{},"content":"\n## 纵观 Web 架构\n\n个人认为：当前时代下，应用程序的本质就两点：\n\n1. 将数据友好的呈现给用户\n2. 将用户的输入存储到数据之中\n\n在 Web 这一应用环境中核心角色：\n\n- 数据库\n- 服务器\n- 浏览器\n\n我们以一个带有表单页面的功能为例，其整个流程：\n\n1. 用户通过浏览器（User Agent）发起对服务器（Web Server）的请求\n2. 服务器根据用户的请求到数据库中取出相应的数据\n3. 将数据结合模板转换为 HTML 代码返回给浏览器\n4. 浏览器渲染 HTML，呈现页面给用户\n5. 用户在页面（表单）中填写内容\n6. 通过浏览器将所填写数据提交到服务器\n7. 服务器接收数据，经过整理，保存至数据库\n\n在这样一个相对原始的过程中，有很多事情需要做，粗暴的说也就需要写很多代码。而在以前这个过程中绝大多数的事情都是由后端完成的，可以毫不夸张的说：后端驱动着整个项目。\n\n那前端在干什么？\n\n在这样一种状态下，前端就是给后端「打杂」，没有任何发挥的空间，完全是一个服务于后端的角色。\n\n为什么要变？\n\n答案很简单：\n\n1. 需求在变、用户体验的要求在变，如果一直这样发展下去，后端将不堪重负。\n2. 背后的原因更多的是合理性的问题，决定用户看到什么、以何种形式看到应该是前端的工作。\n\n这里我们要讨论的是：这些事情都应该由哪个角色（前端开发人员、后端开发人员）去完成？\n\n## 基于 AJAX 的前后端分离\n\n### 架构方案\n\n![基于 AJAX 的前后端分离方案](https://cdn.zce.me/assets/29c033a0ae031423.png)\n\n### 面临的问题\n\n1. 能力问题（鉴权、缓存、路由定制）\n2. 环境问题\n\n## 基于中间层的前后端分离\n\n### 架构方案\n\n![基于 Node.js 中间层的前后端分离方案](https://cdn.zce.me/assets/e859cecc7cf8cc8a.png)\n\n[^淘宝前后端分离实践]\n\n### 优势\n\n1. 略微增加成本的情况下给前端更大的发挥空间\n2. 完全可控的路由\n3. 完全可控的服务端逻辑\n4. 接口重组、Bigpipe\n5. 服务端渲染、良好的 SEO 支持\n6. 后端更为专注，完全从数据出发\n7. 不用为特定业务单独提供接口\n\n### 案例：商品列表页实现\n\n1. 用户浏览器对应用服务器（Node.js）发起页面请求\n2. 应用服务器接收并校验请求参数（分类 ID、分页页码、排序条件、属性筛选）\n3. 应用服务器调用服务层（PHP）提供的数据接口获取对应分类和商品信息数据\n4. 应用服务器将所获取的数据通过页面模板渲染为 HTML（服务端渲染）\n5. 应用服务器将渲染的结果返回给用户浏览器\n6. 浏览器解析并渲染页面\n7. 用户进行页面行为操作，比如下一页、按照价格排序等\n8. 用户浏览器再次对应用服务器发起 AJAX 请求（JavaScript 实现）\n9. 应用服务器接收 AJAX 请求，根据逻辑调用服务接口，将最终组织完成的数据通过 JSON 方式返回\n10. 浏览器接收 JSON 数据，通过客户端模板渲染到页面中（客户端渲染）\n\n> P.S.其中 8-10 为客户端 AJAX 调用应用服务器，目的为了增强用户体验，减少服务器压力\n\n## 为什么选 Node.js\n\n1. 几乎没有语言成本\n2. 事件驱动、非阻塞\n\n[^淘宝前后端分离实践]: https://2014.jsconfchina.com/slides/herman-taobaoweb/\n"},{"title":"基于 Node.js 的前后端分离解决方案","slug":"nodejs-based-frontend-and-backend-separation-solution","date":1511882992000,"updated":1673100032041,"sections":[],"draft":true,"featured":false,"comment":false,"authors":[],"categories":["教程"],"tags":["Node.js"],"meta":{},"content":""},{"title":"Let’s Rock","slug":"rock","date":1495238400000,"updated":1673100032041,"sections":[],"draft":false,"featured":true,"comment":false,"authors":[],"categories":[],"tags":[],"meta":{},"content":"\nLet's Rock (stylized with single quotation marks) is the ninth studio album by American rock duo the Black Keys. It was released on June 28, 2019, through Easy Eye Sound/Nonesuch Records.[4]\n\nIt was their first release since Turn Blue (2014), marking the longest gap between studio albums in their career.\n\nAfter collaborating with producer Danger Mouse for their previous four records, the duo decided to self-produce Let's Rock and to eschew keyboards in favor of a basic recording approach of guitar, drums, and vocals. Drummer Patrick Carney called the album \"an homage to electric guitar\".\n\nLet's Rock was preceded by the singles \"Lo/Hi\", \"Eagle Birds\", and \"Go\".[5] \"Lo/Hi\" topped Billboard's Mainstream Rock, Adult Alternative Songs, Rock Airplay, and Alternative Songs charts in the US simultaneously, making it the first song ever to do so.[6]\n\nLet's Rock received generally positive reviews, with many critics calling it a well-crafted if unoriginal album.\n\n> Photo by [William Krause](https://unsplash.com/@williamk) on [Unsplash](https://unsplash.com)\n","cover":"https://cdn.zce.me/assets/12a3fbfe9b46c99d.jpg","video":"https://cdn.zce.me/video/2020/02/javascript-async-calls.mp4"},{"title":"Welcome","slug":"welcome","date":1463702400000,"updated":1673100032033,"sections":[],"draft":false,"featured":true,"comment":false,"authors":[],"categories":[],"tags":[],"meta":{},"content":"\n👋 Welcome, it's great to have you here.\n\nWe know that first impressions are important, so we've populated your new site with some initial **getting started** posts that will help you get familiar with everything in no time. This is the first one!\n\n**A few things you should know upfront**:\n\n1. Ghost is designed for ambitious, professional publishers who want to actively build a business around their content. That's who it works best for.\n2. The entire platform can be modified and customised to suit your needs. It's very powerful, but does require some knowledge of code. Ghost is not necessarily a good platform for beginners or people who just want a simple personal blog.\n3. For the best experience we recommend downloading the [Ghost Desktop App](https://ghost.org/downloads/) for your computer, which is the best way to access your Ghost site on a desktop device.\n\nGhost is made by an independent non-profit organisation called the Ghost Foundation. We are 100% self funded by revenue from our [Ghost(Pro)](https://ghost.org/pricing) service, and every penny we make is re-invested into funding further development of free, open source technology for modern publishing.\n\nThe version of Ghost you are looking at right now would not have been made possible without generous contributions from the open source [community](https://github.com/TryGhost).\n\n## Next up, the editor\n\nThe main thing you'll want to read about next is probably: [the Ghost editor](). This is where the good stuff happens.\n\n> _By the way, once you're done reading, you can simply delete the default **Ghost** user from your team to remove all of these introductory posts!_\n\n## Image\n\n![](https://static.ghost.org/v2.0.0/images/welcome-to-ghost.jpg)\n","cover":"https://cdn.zce.me/assets/ada974c752fa9d54.jpg"},{"title":"Hello world","slug":"hello-world","date":699022800000,"updated":1673100032033,"sections":[],"draft":false,"featured":false,"comment":false,"authors":["汪磊","汪子文"],"categories":[],"tags":[],"meta":{},"content":"\nWelcome to Next.js, Next.js is a fastest frontend for the modern web. This is your first post. Edit or delete it, then start writing!\n\n欢迎使用 Next.js，Next.js 是一款非常优秀的现代化 Web 框架，它基于 React 的基础之上。这是你的第一篇文章。编辑或删除它，然后开始写作吧！\n\n<!-- > Photo by [Maxwell Nelson](https://unsplash.com/@maxcodes) on [Unsplash](https://unsplash.com) -->\n","cover":"https://cdn.zce.me/assets/5773189865951bc8.png"},{"title":"样式风格","slug":"style-guide","date":0,"updated":1673100032025,"sections":[],"draft":false,"featured":false,"comment":false,"authors":[],"categories":[],"tags":[],"meta":{},"content":"\n这篇文章内容无意义，仅用于排版样式的展示。\n\nBelow is just about everything you’ll need to style in the theme. Check the source code to see the many embedded elements within paragraphs.\n\n---\n\n### Headings\n\n# Heading 1\n\nDoloremque dolor voluptas est sequi omnis. Pariatur ut aut. Sed enim tempora qui veniam qui cum vel. Voluptas odit at vitae minima. In assumenda ut. Voluptatem totam impedit accusantium reiciendis excepturi aut qui accusamus praesentium.\n\n## Heading 2\n\nDoloremque dolor voluptas est sequi omnis. Pariatur ut aut. Sed enim tempora qui veniam qui cum vel. Voluptas odit at vitae minima. In assumenda ut. Voluptatem totam impedit accusantium reiciendis excepturi aut qui accusamus praesentium.\n\n### Heading 3\n\nDoloremque dolor voluptas est sequi omnis. Pariatur ut aut. Sed enim tempora qui veniam qui cum vel. Voluptas odit at vitae minima. In assumenda ut. Voluptatem totam impedit accusantium reiciendis excepturi aut qui accusamus praesentium.\n\n#### Heading 4\n\nDoloremque dolor voluptas est sequi omnis. Pariatur ut aut. Sed enim tempora qui veniam qui cum vel. Voluptas odit at vitae minima. In assumenda ut. Voluptatem totam impedit accusantium reiciendis excepturi aut qui accusamus praesentium.\n\n##### Heading 5\n\nDoloremque dolor voluptas est sequi omnis. Pariatur ut aut. Sed enim tempora qui veniam qui cum vel. Voluptas odit at vitae minima. In assumenda ut. Voluptatem totam impedit accusantium reiciendis excepturi aut qui accusamus praesentium.\n\n###### Heading 6\n\nDoloremque dolor voluptas est sequi omnis. Pariatur ut aut. Sed enim tempora qui veniam qui cum vel. Voluptas odit at vitae minima. In assumenda ut. Voluptatem totam impedit accusantium reiciendis excepturi aut qui accusamus praesentium.\n\n---\n\n## Paragraph\n\nIt's very easy to make some words **bold** and other words _italic_ with Markdown. You can even [link to Google!](http://google.com)\n\nLorem ipsum dolor sit amet, test link adipiscing elit. This is strong. Nullam dignissim convallis est. Quisque aliquam. This is emphasized. Donec faucibus. Nunc iaculis suscipit dui. 53 = 125. Water is H2O. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. The New York Times (That’s a citation). Underline. Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.\n\nHTML and CSS are our tools. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. To copy a file type COPY filename. Dinner’s at 5:00. Let’s make that 7. This text has been struck.\n\n#### Emphasis\n\n_This text will be italic_\\\n_This will also be italic_\\\n**This text will be bold**\\\n**This will also be bold**\\\n_You **can** combine them_\n\n#### Preformatted Text\n\nThe silver swan, who living had no note,\\\nWhen death approached, unlocked her silent throat;\\\nLeaning her breast against the reedy shore,\\\nThus sung her first and last, and sung no more:\\\nFarewell, all joys; O death, come close mine eyes;\\\nMore geese than swans now live, more fools than wise.\n\n#### Text-level semantics\n\nThe [a element](#foo) example\\\nThe <abbr>abbr element</abbr> and <abbr title=\"Title text\">abbr element with title</abbr> examples\\\nThe **b element** example\\\nThe <cite>cite element</cite> example\\\nThe `code element` example\\\nThe ~~del element~~ example\\\nThe <dfn>dfn element</dfn> and <dfn title=\"Title text\">dfn element with title</dfn> examples\\\nThe _em element_ example\\\nThe _i element_ example\\\nThe <ins>ins element</ins> example\\\nThe <kbd>kbd element</kbd> example\\\nThe <mark>mark element</mark> example\\\nThe <q>q element <q>inside</q> a q element</q> example\\\nThe <s>s element</s> example\\\nThe <samp>samp element</samp> example\\\nThe <small>small element</small> example\\\nThe <span>span element</span> example\\\nThe <strong>strong element</strong> example\\\nThe <sub>sub element</sub> example\\\nThe <sup>sup element</sup> example\\\nThe <var>var element</var> example\\\nThe <u>u element</u> example\n\n#### Footnotes\n\nYou can create footnotes like this[^footnote].\n\n---\n\n### List Types\n\n#### Ordered List\n\nSometimes you want numbered lists:\n\n1. List Item 1\n2. List Item 2\n3. Nested list item A\n4. Nested list item B\n5. List Item 3\n\n#### Unordered List\n\nSometimes you want bullet points:\n\n- List Item 1\n- List Item 2\n  - Nested list item A\n  - Nested list item B\n- List Item 3\n\nAlternatively,\n\n- Start a line with a star\n- Profit!\n\nBut I have to admit, tasks lists are my favorite:\n\n- [x] This is a complete item\n- [ ] This is an incomplete item\n\n#### Definition List\n\n<dl>\n  <dt>Definition List Title</dt>\n  <dd>This is a definition list division.</dd>\n  <dt>Definition</dt>\n  <dd>An exact statement or description of the nature, scope, or meaning of something: <em>our definition of what constitutes poetry.</em></dd>\n</dl>\n\n---\n\n### Blockquotes\n\nLet’s keep it simple. Italics are good to help set it off from the body text. Be sure to style the citation.\n\n> Good afternoon, gentlemen. I am a HAL 9000 computer. I became operational at the H.A.L. plant in Urbana, Illinois on the 12th of January 1992. My instructor was Mr. Langley, and he taught me to sing a song. If you’d like to hear it I can sing it for you.\n>\n> — [HAL 9000](http://en.wikipedia.org/wiki/HAL_9000)\n\nAnd here’s a bit of trailing text.\n\n---\n\n### Table\n\nIf you want to embed table, this is how you do it:\n\n| TABLE HEADER 1 | TABLE HEADER 2 | TABLE HEADER 3 |\n| -------------- | -------------- | -------------- |\n| Division 1     | Division 2     | Division 3     |\n| Division 1     | Division 2     | Division 3     |\n| Division 1     | Division 2     | Division 3     |\n\n| Name   | Age     | Sex | Location |\n| ------ | ------- | --- | -------- | ------ |\n| Naruto | Uzumaki | 16  | Male     | Konoha |\n| Sakura | Haruno  | 16  | Female   | Konoha |\n\n---\n\n### Code\n\nCode can be presented inline, like `<?php bloginfo('stylesheet_url'); ?>`, or within a `<pre>` block. Because we have more specific typographic needs for code, we’ll specify Consolas and Monaco ahead of the browser-defined monospace font.\n\n```css\n.banner {\n  width: 750px;\n  height: 420px;\n}\n\n.banner image {\n  width: 100%;\n  height: 100%;\n}\n```\n\n```javascript\nimport React from 'react'\n\nimport { Wrapper } from '../components'\n\nexport default () => (\n  <Wrapper title=\"Hello world\">\n    <h1>Hello world</h1>\n  </Wrapper>\n)\n```\n\n---\n\n### Media\n\nLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore.\n\n#### Wide Image\n\n![Wide Image](https://cdn.zce.me/assets/564cbd264aa21156.jpg)\n\n#### Big Image\n\n![Big Image](https://cdn.zce.me/assets/3f0bc141b01ef5b4.jpg)\n\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\n\n#### Small Image\n\nLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore.\n\n![Small Image](https://cdn.zce.me/assets/b1c63df6750fc11d.jpg)\n\nLabore et dolore.\n\n[^footnote]: Here is the _text_ of the **footnote**.\n","cover":"https://cdn.zce.me/assets/30b14e37031b8c12.png"}]